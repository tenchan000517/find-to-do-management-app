# ウエイト・リソースベース自動スケジューリング実装フェーズ計画

**作成日**: 2025年6月30日  
**フェーズ名**: 次世代ウエイト・リソースベース自動スケジューリング実装  
**期間**: 4-5日  
**優先度**: CRITICAL  
**前提条件**: 基本自動スケジューリング完了済み

---

## 🎯 フェーズ目標

### **最終目標**
時間指定ではなく「**ウエイト・リソース管理**」による真に実用的な自動スケジューリングシステム構築

### **現在の問題**
- 時間ベースの配置は学生・多忙な社会人には不適切
- 個人のリソース制約・生活パターンを無視
- 将来のタスク逼迫を予測しない近視眼的配置
- 個人予定との統合不足

### **完了後の状態**
- **ユーザー別リソースプロファイル**による制約管理
- **タスクウエイト見積もり**による現実的配置
- **先読み配置アルゴリズム**による将来破綻回避
- **個人予定統合**による実生活対応

---

## 📋 フェーズ分割

### **Phase A: データモデル設計** (1日)

#### **A1: ユーザーリソースプロファイル設計**
- **ファイル**: `/src/types/resource-profile.ts`
- **実装内容**:
  ```typescript
  interface UserResourceProfile {
    id: string;
    userId: string;
    userType: 'student' | 'employee' | 'freelancer' | 'entrepreneur';
    commitmentRatio: number; // 0.1-1.0 (利用可能時間の割合)
    dailyCapacity: {
      lightTaskSlots: number;    // 軽いタスク可能数/日
      heavyTaskSlots: number;    // 重いタスク可能数/日
      totalWeightLimit: number;  // 1日の総ウエイト上限
      continuousWorkHours: number; // 連続作業可能時間
    };
    timeConstraints: {
      unavailableHours: string[];     // 利用不可時間帯
      preferredWorkHours: string[];   // 推奨作業時間帯
      maxWorkingHours: number;        // 1日最大作業時間
    };
    workingPattern: {
      productiveHours: string[];      // 生産性高い時間帯
      focusCapacity: 'low' | 'medium' | 'high';  // 集中力
      multitaskingAbility: number;   // マルチタスク能力 0-1
    };
    personalConstraints: {
      schoolSchedule?: string[];      // 学生: 授業時間
      workingHours?: string[];        // 社会人: 勤務時間  
      familyTime?: string[];          // 家族時間
      personalCommitments?: string[]; // 個人的約束
    };
    preferences: {
      earlyStart: boolean;            // 早朝作業可能
      lateWork: boolean;              // 夜間作業可能
      weekendWork: boolean;           // 週末作業可能
      breakFrequency: 'low' | 'medium' | 'high'; // 休憩頻度
    };
    createdAt: string;
    updatedAt: string;
  }
  ```

#### **A2: タスクウエイト・見積もりシステム設計**
- **ファイル**: `/src/types/task-weight.ts`
- **実装内容**:
  ```typescript
  interface TaskWeightProfile {
    id: string;
    taskId: string;
    estimatedWeight: number;        // 1-10 (軽作業～重作業)
    estimatedDuration: number;      // 予想作業時間(分)
    estimatedDays: number;          // 完了までの予想日数
    complexityLevel: 'simple' | 'medium' | 'complex' | 'expert';
    canSplit: boolean;              // 分割実行可能
    splitMinimumDuration: number;   // 分割時の最小作業時間
    dependsOnTasks: string[];       // 依存タスクID
    blocksOtherTasks: string[];     // このタスクが完了を阻むタスク
    urgencyScore: number;           // 1-10 (緊急度)
    importanceScore: number;        // 1-10 (重要度)
    energyRequirement: 'low' | 'medium' | 'high'; // 必要エネルギー
    creativityRequirement: 'low' | 'medium' | 'high'; // 創造性要求
    focusRequirement: 'low' | 'medium' | 'high';     // 集中力要求
    collaborationNeeded: boolean;   // 他者との協力必要
    resourcesNeeded: string[];      // 必要リソース
    optimalTimeOfDay: 'morning' | 'afternoon' | 'evening' | 'flexible';
    deadlineBuffer: number;         // 締切バッファ(日)
    riskLevel: 'low' | 'medium' | 'high'; // 遅延リスク
    autoGeneratedFrom?: 'appointment' | 'project' | 'template'; // 自動生成元
    createdAt: string;
    updatedAt: string;
  }
  ```

#### **A3: 先読み予測システム設計**
- **ファイル**: `/src/types/prediction.ts`
- **実装内容**:
  ```typescript
  interface FuturePrediction {
    userId: string;
    predictionDate: string;
    weeklyCapacityPrediction: {
      week1: CapacityPrediction;
      week2: CapacityPrediction;
      week3: CapacityPrediction;
      week4: CapacityPrediction;
    };
    monthlyTrends: {
      expectedTaskIncrease: number;   // 予想タスク増加率
      seasonalFactors: number;        // 季節要因
      personalEventImpact: number;    // 個人イベント影響
    };
    riskAlerts: {
      overloadRisk: 'low' | 'medium' | 'high';
      burnoutRisk: 'low' | 'medium' | 'high';
      deadlineMissRisk: 'low' | 'medium' | 'high';
    };
    recommendations: string[];
    calculatedAt: string;
  }

  interface CapacityPrediction {
    availableCapacity: number;      // 利用可能容量%
    scheduledWeight: number;        // 既定ウエイト
    flexibleWeight: number;         // 調整可能ウエイト
    riskDays: string[];            // リスクの高い日
    recommendedActions: string[];   // 推奨アクション
  }
  ```

### **Phase B: コアアルゴリズム実装** (2日)

#### **B1: リソース制約エンジン実装**
- **ファイル**: `/src/lib/scheduling/resource-constraint-engine.ts`
- **機能**:
  - ユーザーリソースプロファイル解析
  - 個人予定との衝突検知
  - 制約違反チェック
  - 利用可能時間枠計算

#### **B2: ウエイトベース配置アルゴリズム実装**
- **ファイル**: `/src/lib/scheduling/weight-based-scheduler.ts`
- **機能**:
  - タスクウエイト解析
  - 最適配置計算
  - 分割タスク管理
  - 依存関係処理

#### **B3: 先読み予測エンジン実装**
- **ファイル**: `/src/lib/scheduling/future-prediction-engine.ts`
- **機能**:
  - 将来容量予測
  - パツパツ期間検知
  - 前倒し推奨
  - リスクアラート生成

### **Phase C: API統合・UI実装** (1日)

#### **C1: 新APIエンドポイント実装**
- **ファイル**: `/src/app/api/ai/resource-schedule/route.ts`
- **機能**:
  - リソースプロファイル考慮
  - ウエイトベース生成
  - 個人予定統合
  - 先読み配置

#### **C2: 既存UI拡張**
- **ファイル**: `/src/hooks/useResourceScheduleGenerator.ts`
- **機能**:
  - useScheduleGeneratorの拡張
  - リソース情報取得
  - ウエイト表示
  - 予測アラート表示

#### **C3: 設定UI実装**
- **ファイル**: `/src/components/ResourceProfileSetup.tsx`
- **機能**:
  - リソースプロファイル設定
  - ユーザータイプ選択
  - 制約時間設定
  - プレビュー機能

### **Phase D: 品質保証・最適化** (1日)

#### **D1: アルゴリズム精度向上**
- パフォーマンステスト
- エッジケース対応
- 精度調整

#### **D2: 統合テスト**
- 全体フロー検証
- エラーハンドリング
- ユーザビリティテスト

---

## 🛠️ 実装詳細

### **Phase A1: UserResourceProfile 詳細設計**

```typescript
// /src/types/resource-profile.ts
export interface UserResourceProfile {
  id: string;
  userId: string;
  
  // 基本属性
  userType: 'student' | 'employee' | 'freelancer' | 'entrepreneur' | 'parent' | 'retiree';
  commitmentRatio: number; // 0.1-1.0
  
  // 容量設定
  dailyCapacity: {
    lightTaskSlots: number;    // 軽タスク: 1-10個/日
    heavyTaskSlots: number;    // 重タスク: 0-3個/日
    totalWeightLimit: number;  // 総重量: 5-20/日
    continuousWorkHours: number; // 連続: 1-8時間
  };
  
  // 時間制約
  timeConstraints: {
    unavailableHours: string[];     // ["09:00-17:00"] (勤務時間)
    preferredWorkHours: string[];   // ["19:00-22:00"] (作業時間)
    maxWorkingHours: number;        // 最大8時間/日
  };
  
  // 作業パターン
  workingPattern: {
    productiveHours: string[];      // ["09:00-11:00", "15:00-17:00"]
    focusCapacity: 'low' | 'medium' | 'high';
    multitaskingAbility: number;   // 0.0-1.0
  };
  
  // 個人制約
  personalConstraints: {
    schoolSchedule?: string[];      // 学生専用
    workingHours?: string[];        // 社会人専用
    familyTime?: string[];          // 家族持ち専用
    personalCommitments?: string[]; // その他約束
  };
  
  // 設定
  preferences: {
    earlyStart: boolean;            // 早朝作業OK
    lateWork: boolean;              // 夜間作業OK
    weekendWork: boolean;           // 週末作業OK
    breakFrequency: 'low' | 'medium' | 'high';
  };
  
  createdAt: string;
  updatedAt: string;
}

// プリセット例
export const USER_TYPE_PRESETS: Record<UserResourceProfile['userType'], Partial<UserResourceProfile>> = {
  student: {
    commitmentRatio: 0.3,
    dailyCapacity: {
      lightTaskSlots: 3,
      heavyTaskSlots: 1,
      totalWeightLimit: 8,
      continuousWorkHours: 3
    },
    timeConstraints: {
      unavailableHours: ["09:00-16:00"], // 授業時間
      preferredWorkHours: ["19:00-22:00"],
      maxWorkingHours: 4
    }
  },
  
  employee: {
    commitmentRatio: 0.6,
    dailyCapacity: {
      lightTaskSlots: 4,
      heavyTaskSlots: 2,
      totalWeightLimit: 12,
      continuousWorkHours: 4
    },
    timeConstraints: {
      unavailableHours: ["09:00-18:00"], // 勤務時間
      preferredWorkHours: ["19:00-21:00"],
      maxWorkingHours: 3
    }
  },
  
  freelancer: {
    commitmentRatio: 0.8,
    dailyCapacity: {
      lightTaskSlots: 6,
      heavyTaskSlots: 3,
      totalWeightLimit: 18,
      continuousWorkHours: 6
    },
    timeConstraints: {
      unavailableHours: [],
      preferredWorkHours: ["09:00-18:00"],
      maxWorkingHours: 8
    }
  }
};
```

### **Phase B1: リソース制約エンジン詳細**

```typescript
// /src/lib/scheduling/resource-constraint-engine.ts
import { UserResourceProfile } from '@/types/resource-profile';
import { PersonalSchedule } from '@/types/personal-schedule';
import { CalendarEvent } from '@/types';

interface TimeSlot {
  startTime: string;
  endTime: string;
  availableWeight: number;
  slotType: 'light' | 'heavy' | 'mixed';
  energyLevel: 'high' | 'medium' | 'low';
}

export class ResourceConstraintEngine {
  constructor(
    private userProfile: UserResourceProfile,
    private personalSchedules: PersonalSchedule[],
    private calendarEvents: CalendarEvent[]
  ) {}

  /**
   * 指定日の利用可能時間枠を計算
   */
  calculateAvailableSlots(date: string): TimeSlot[] {
    const unavailableSlots = this.getUnavailableSlots(date);
    const workingHours = this.getWorkingHours();
    const productiveHours = this.userProfile.workingPattern.productiveHours;
    
    const availableSlots: TimeSlot[] = [];
    
    // 1時間単位で利用可能性をチェック
    for (let hour = 0; hour < 24; hour++) {
      const timeSlot = this.formatHour(hour);
      
      if (this.isSlotAvailable(timeSlot, unavailableSlots, workingHours)) {
        const energyLevel = this.calculateEnergyLevel(timeSlot, productiveHours);
        const availableWeight = this.calculateAvailableWeight(energyLevel);
        
        availableSlots.push({
          startTime: timeSlot,
          endTime: this.formatHour(hour + 1),
          availableWeight,
          slotType: this.determineSlotType(availableWeight),
          energyLevel
        });
      }
    }
    
    return this.mergeConsecutiveSlots(availableSlots);
  }

  /**
   * タスクが指定時間枠に配置可能かチェック
   */
  canScheduleTask(
    task: TaskWithWeight,
    timeSlot: TimeSlot,
    date: string
  ): boolean {
    // ウエイト制約チェック
    if (task.estimatedWeight > timeSlot.availableWeight) {
      return false;
    }
    
    // エネルギー要求チェック
    if (task.energyRequirement === 'high' && timeSlot.energyLevel === 'low') {
      return false;
    }
    
    // 集中力要求チェック
    if (task.focusRequirement === 'high' && this.userProfile.workingPattern.focusCapacity === 'low') {
      return false;
    }
    
    // 最適時間帯チェック
    if (task.optimalTimeOfDay !== 'flexible') {
      if (!this.isOptimalTimeOfDay(timeSlot.startTime, task.optimalTimeOfDay)) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * 日次容量制限チェック
   */
  checkDailyCapacity(date: string, scheduledTasks: TaskWithWeight[]): {
    canAddLight: boolean;
    canAddHeavy: boolean;
    remainingWeight: number;
    utilizationRate: number;
  } {
    const dailyCapacity = this.userProfile.dailyCapacity;
    
    const lightTasksCount = scheduledTasks.filter(t => t.estimatedWeight <= 3).length;
    const heavyTasksCount = scheduledTasks.filter(t => t.estimatedWeight > 6).length;
    const totalWeight = scheduledTasks.reduce((sum, t) => sum + t.estimatedWeight, 0);
    
    return {
      canAddLight: lightTasksCount < dailyCapacity.lightTaskSlots,
      canAddHeavy: heavyTasksCount < dailyCapacity.heavyTaskSlots,
      remainingWeight: dailyCapacity.totalWeightLimit - totalWeight,
      utilizationRate: totalWeight / dailyCapacity.totalWeightLimit
    };
  }

  private getUnavailableSlots(date: string): string[] {
    const unavailable: string[] = [];
    
    // 設定による利用不可時間
    unavailable.push(...this.userProfile.timeConstraints.unavailableHours);
    
    // 個人予定
    const dayPersonalSchedules = this.personalSchedules.filter(ps => ps.date === date);
    dayPersonalSchedules.forEach(ps => {
      if (ps.endTime) {
        unavailable.push(`${ps.time}-${ps.endTime}`);
      } else {
        // 終了時間未指定の場合は1時間と仮定
        const endTime = this.addHours(ps.time, 1);
        unavailable.push(`${ps.time}-${endTime}`);
      }
    });
    
    // カレンダーイベント
    const dayEvents = this.calendarEvents.filter(event => 
      new Date(event.startTime).toDateString() === new Date(date).toDateString()
    );
    dayEvents.forEach(event => {
      const startTime = new Date(event.startTime);
      const endTime = new Date(event.endTime || startTime.getTime() + 60 * 60 * 1000);
      unavailable.push(`${this.formatTime(startTime)}-${this.formatTime(endTime)}`);
    });
    
    return unavailable;
  }

  private getWorkingHours(): string[] {
    return this.userProfile.timeConstraints.preferredWorkHours;
  }

  private calculateEnergyLevel(timeSlot: string, productiveHours: string[]): 'high' | 'medium' | 'low' {
    const hour = parseInt(timeSlot.split(':')[0]);
    
    // 生産性高い時間帯
    if (productiveHours.some(ph => this.isTimeInRange(timeSlot, ph))) {
      return 'high';
    }
    
    // 一般的なエネルギーパターン
    if (hour >= 9 && hour <= 11) return 'high';    // 午前中
    if (hour >= 14 && hour <= 16) return 'medium'; // 午後
    if (hour >= 19 && hour <= 21) return 'medium'; // 夜
    
    return 'low';
  }

  private calculateAvailableWeight(energyLevel: 'high' | 'medium' | 'low'): number {
    const baseWeight = this.userProfile.dailyCapacity.totalWeightLimit / 8; // 8時間で配分
    
    switch (energyLevel) {
      case 'high': return baseWeight * 1.5;
      case 'medium': return baseWeight;
      case 'low': return baseWeight * 0.5;
      default: return baseWeight;
    }
  }

  // その他ヘルパーメソッド...
}
```

---

## 📊 成功指標

### **機能要件**
- ✅ ユーザー別リソースプロファイル管理
- ✅ タスクウエイト自動見積もり
- ✅ 個人予定との完全統合
- ✅ 先読み配置による破綻回避
- ✅ 制約条件下での最適配置

### **技術要件**  
- ✅ 型チェックエラー0件
- ✅ パフォーマンス劣化なし
- ✅ アルゴリズム精度85%以上
- ✅ レスポンス時間2秒以内

### **UX要件**
- ✅ 設定5分以内で完了
- ✅ 予測精度体感向上
- ✅ 破綻防止効果実感
- ✅ 全ユーザータイプ対応

---

## 🎯 期待される成果

### **ユーザー価値**
- **真の実用性**: 学生から経営者まで実際に使える
- **生活適応性**: 個人の制約・パターンに完全適応
- **先読み安心**: 将来の破綻を事前回避
- **ストレス軽減**: リソース超過による破綻防止

### **技術的成果**
- **次世代アルゴリズム**: ウエイトベース配置の確立
- **予測システム**: 将来容量予測エンジン
- **制約処理**: 複雑制約下での最適化
- **統合システム**: 全データソース統合

### **ビジネス価値**
- **差別化**: 他にない実用的自動スケジューリング
- **拡張性**: あらゆるユーザータイプに対応
- **信頼性**: 破綻しない安心システム
- **継続利用**: 実際に役立つため長期利用

---

## ⚡ 実装優先順位

### **Week 1: Phase A (データモデル設計)**
1. UserResourceProfile 型定義
2. TaskWeightProfile 型定義  
3. FuturePrediction 型定義
4. プリセット・バリデーション

### **Week 2: Phase B (コアアルゴリズム)**
1. ResourceConstraintEngine 実装
2. WeightBasedScheduler 実装
3. FuturePredictionEngine 実装
4. 統合テスト

### **完了判定基準**
- [ ] 学生プロファイルで実用的配置動作
- [ ] 社会人プロファイルで制約回避動作
- [ ] 先読み配置で破綻回避動作
- [ ] 個人予定統合で衝突回避動作
- [ ] 全ユーザータイプで精度85%以上

---

**管理責任者**: PM Level  
**実装ブランチ**: `feature/resource-based-scheduling`  
**関連技術**: アルゴリズム設計, 予測システム, 制約処理  
**革新性**: 業界初のウエイト・リソースベース自動スケジューリング