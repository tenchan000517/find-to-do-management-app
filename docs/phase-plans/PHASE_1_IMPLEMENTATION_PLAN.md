# Phase 1: èªè¨¼ã‚·ã‚¹ãƒ†ãƒ åŸºç›¤ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†å¼·åŒ– å®Ÿè£…è¨ˆç”»æ›¸

**ãƒ•ã‚§ãƒ¼ã‚ºæœŸé–“**: 3æ—¥é–“  
**å®Ÿè£…æ—¥**: 2025å¹´6æœˆ28æ—¥ ã€œ 2025å¹´6æœˆ30æ—¥  
**æ‹…å½“ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**: èªè¨¼ã‚·ã‚¹ãƒ†ãƒ æ‹…å½“  
**å‰ææ¡ä»¶**: æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®èªè¨¼åŸºç›¤ã‚’ç†è§£ã—ã¦ã„ã‚‹

---

## ğŸ¯ **Phase 1 å®Ÿè£…ç›®æ¨™**

### **1.1 ä¸»è¦æ©Ÿèƒ½å®Ÿè£…**
- **å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹ç®¡ç†æ©Ÿèƒ½**: é€±æ¬¡ã‚³ãƒŸãƒƒãƒˆæ™‚é–“ãƒ™ãƒ¼ã‚¹ã®è² è·è¨ˆç®—
- **MBTIçµ±åˆãƒãƒ¼ãƒ æœ€é©åŒ–**: æ—¢å­˜mbti.jsonã‚’æ´»ç”¨ã—ãŸæœ€é©ãƒãƒ¼ãƒ ç·¨æˆ
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µ**: å­¦ç”Ÿæƒ…å ±ãƒ»MBTIæƒ…å ±ã®çµ±åˆç®¡ç†

### **1.2 æŠ€è¡“è¦ä»¶**
- æ—¢å­˜èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨äº’æ›æ€§ç¶­æŒ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µã®ã¿ï¼ˆç ´å£Šçš„å¤‰æ›´ãªã—ï¼‰
- æ—¢å­˜AIã‚¨ãƒ³ã‚¸ãƒ³ã®æ´»ç”¨ãƒ»æ‹¡å¼µ

---

## ğŸ“‹ **Phase 1 å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**

### **1.1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µ (0.5æ—¥)**
- [ ] usersãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µå®Ÿè£…
- [ ] student_resourcesãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ
- [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ç§»è¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆä½œæˆ
- [ ] ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºèª

### **1.2 å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  (1æ—¥)**
- [ ] StudentResourceManager ã‚¯ãƒ©ã‚¹å®Ÿè£…
- [ ] è² è·è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
- [ ] æœ€é©ã‚¢ã‚µã‚¤ãƒ³æ©Ÿèƒ½å®Ÿè£…
- [ ] API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½œæˆ

### **1.3 MBTIçµ±åˆã‚·ã‚¹ãƒ†ãƒ  (1æ—¥)**
- [ ] MBTITeamOptimizer ã‚¯ãƒ©ã‚¹å®Ÿè£…
- [ ] æ—¢å­˜mbti.jsonæ´»ç”¨ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
- [ ] ãƒãƒ¼ãƒ ç·¨æˆAPIå®Ÿè£…
- [ ] ç›¸æ€§è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…

### **1.4 ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰çµ±åˆ (0.5æ—¥)**
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ç”»é¢æ‹¡å¼µ
- [ ] MBTIæƒ…å ±è¡¨ç¤ºæ©Ÿèƒ½
- [ ] ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†UIå®Ÿè£…
- [ ] æ—¢å­˜ç”»é¢ã¨ã®çµ±åˆ

---

## ğŸ”§ **è©³ç´°å®Ÿè£…ã‚¬ã‚¤ãƒ‰**

### **1.1 ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µ**

#### **1.1.1 usersãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µ**
```sql
-- Phase 1: usersãƒ†ãƒ¼ãƒ–ãƒ«æ‹¡å¼µ
ALTER TABLE users ADD COLUMN weekly_commit_hours INTEGER DEFAULT 20;
ALTER TABLE users ADD COLUMN current_load_percentage FLOAT DEFAULT 0.0;
ALTER TABLE users ADD COLUMN mbti_type VARCHAR(4) DEFAULT NULL;
ALTER TABLE users ADD COLUMN student_resource_data JSONB DEFAULT '{}';

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
CREATE INDEX idx_users_weekly_commit_hours ON users(weekly_commit_hours);
CREATE INDEX idx_users_mbti_type ON users(mbti_type);
CREATE INDEX idx_users_current_load ON users(current_load_percentage);
```

#### **1.1.2 student_resourcesãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ**
```sql
-- å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹è©³ç´°ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE student_resources (
  id VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR(255) NOT NULL,
  
  -- æ™‚é–“ç®¡ç†
  weekly_commit_hours INTEGER DEFAULT 20,
  current_load_percentage FLOAT DEFAULT 0.0,
  semester_availability JSONB DEFAULT '{}',
  emergency_available_hours JSONB DEFAULT '{}',
  
  -- ã‚¹ã‚­ãƒ«ãƒ»é©æ€§
  technical_skills JSONB DEFAULT '[]',
  soft_skills JSONB DEFAULT '[]',
  learning_preferences JSONB DEFAULT '{}',
  project_experience JSONB DEFAULT '[]',
  
  -- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹
  task_completion_rate FLOAT DEFAULT 1.0,
  quality_score FLOAT DEFAULT 1.0,
  collaboration_score FLOAT DEFAULT 1.0,
  
  -- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
CREATE INDEX idx_student_resources_user_id ON student_resources(user_id);
CREATE INDEX idx_student_resources_load ON student_resources(current_load_percentage);
CREATE INDEX idx_student_resources_skills ON student_resources USING GIN (technical_skills);
```

#### **1.1.3 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚½ãƒ¼ã‚¹é…åˆ†ãƒ†ãƒ¼ãƒ–ãƒ«**
```sql
-- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚½ãƒ¼ã‚¹é…åˆ†ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE project_resource_allocation (
  id VARCHAR(255) PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id VARCHAR(255) NOT NULL,
  student_resource_id VARCHAR(255) NOT NULL,
  
  -- é…åˆ†æƒ…å ±
  allocated_hours INTEGER NOT NULL,
  role_in_project VARCHAR(100) NOT NULL,
  responsibility_level VARCHAR(50) DEFAULT 'MEMBER',
  
  -- è©•ä¾¡
  effectiveness_score FLOAT DEFAULT 1.0,
  contribution_score FLOAT DEFAULT 1.0,
  satisfaction_score FLOAT DEFAULT 1.0,
  
  -- æœŸé–“
  start_date TIMESTAMP DEFAULT NOW(),
  end_date TIMESTAMP DEFAULT NULL,
  
  -- ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (student_resource_id) REFERENCES student_resources(id) ON DELETE CASCADE
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ
CREATE INDEX idx_project_allocation_project ON project_resource_allocation(project_id);
CREATE INDEX idx_project_allocation_student ON project_resource_allocation(student_resource_id);
CREATE INDEX idx_project_allocation_active ON project_resource_allocation(end_date) WHERE end_date IS NULL;
```

### **1.2 å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**

#### **1.2.1 StudentResourceManager ã‚¯ãƒ©ã‚¹**
```typescript
// src/services/StudentResourceManager.ts
import { AI_SERVICE } from './ai-service';
import { TASK_SERVICE } from './task-service';
import { PROJECT_SERVICE } from './project-service';

export interface StudentResource {
  id: string;
  userId: string;
  weeklyCommitHours: number;
  currentLoadPercentage: number;
  semesterAvailability: Record<string, number>;
  technicalSkills: string[];
  softSkills: string[];
  taskCompletionRate: number;
  qualityScore: number;
  collaborationScore: number;
}

export interface ResourceAllocationRequest {
  projectId: string;
  requiredHours: number;
  requiredSkills: string[];
  preferredRole: string;
  urgency: 'LOW' | 'MEDIUM' | 'HIGH';
  deadline: Date;
}

export interface OptimalAllocation {
  recommendedUsers: Array<{
    userId: string;
    userName: string;
    allocationScore: number;
    expectedHours: number;
    reasonForRecommendation: string;
    riskFactors: string[];
  }>;
  allocationStrategy: string;
  expectedOutcome: string;
  alternativeOptions: string[];
}

export class StudentResourceManager {
  constructor(
    private aiService: typeof AI_SERVICE,
    private taskService: typeof TASK_SERVICE,
    private projectService: typeof PROJECT_SERVICE
  ) {}

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¾åœ¨ã®è² è·ç‡ã‚’è¨ˆç®—
   */
  async calculateUserLoad(userId: string): Promise<number> {
    const user = await this.getUser(userId);
    const studentResource = await this.getStudentResource(userId);
    const activeTasks = await this.getUserActiveTasks(userId);
    const activeProjects = await this.getUserActiveProjects(userId);

    // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿æ´»ç”¨: estimatedHours Ã— difficultyScore
    const taskWeightedHours = activeTasks.reduce((sum, task) => {
      const difficultyMultiplier = (task.difficultyScore || 5) / 5;
      const resourceWeight = task.resourceWeight || 1.0;
      return sum + (task.estimatedHours * difficultyMultiplier * resourceWeight);
    }, 0);

    // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé…åˆ†æ™‚é–“
    const projectAllocatedHours = activeProjects.reduce((sum, allocation) => 
      sum + allocation.allocatedHours, 0
    );

    const totalWeightedHours = taskWeightedHours + projectAllocatedHours;
    const weeklyCapacity = studentResource?.weeklyCommitHours || user.weeklyCommitHours || 20;

    return Math.min((totalWeightedHours / weeklyCapacity) * 100, 100);
  }

  /**
   * æœ€é©ãªãƒªã‚½ãƒ¼ã‚¹é…åˆ†ã‚’è¨ˆç®—
   */
  async optimizeResourceAllocation(
    request: ResourceAllocationRequest
  ): Promise<OptimalAllocation> {
    const availableStudents = await this.getAvailableStudents(request);
    const skillMatrix = await this.buildSkillMatrix(availableStudents);
    
    // å„å­¦ç”Ÿã®é©åˆåº¦ã‚’è©•ä¾¡
    const evaluations = await Promise.all(
      availableStudents.map(student => 
        this.evaluateStudentFitness(student, request)
      )
    );

    // AI ã«ã‚ˆã‚‹æœ€é©åŒ–åˆ¤æ–­
    const aiRecommendation = await this.aiService.evaluateWithGemini(`
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚½ãƒ¼ã‚¹é…åˆ†æœ€é©åŒ–:
    
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¦ä»¶:
    - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆID: ${request.projectId}
    - å¿…è¦å·¥æ•°: ${request.requiredHours}æ™‚é–“
    - å¿…è¦ã‚¹ã‚­ãƒ«: ${request.requiredSkills.join(', ')}
    - å¸Œæœ›å½¹å‰²: ${request.preferredRole}
    - ç·Šæ€¥åº¦: ${request.urgency}
    - ç· åˆ‡: ${request.deadline.toISOString()}
    
    åˆ©ç”¨å¯èƒ½å­¦ç”Ÿè©•ä¾¡:
    ${evaluations.map(eval => `
    - ${eval.student.name}:
      - ç¾åœ¨è² è·: ${eval.currentLoad}%
      - ã‚¹ã‚­ãƒ«é©åˆåº¦: ${eval.skillMatch}/10
      - å“è³ªã‚¹ã‚³ã‚¢: ${eval.qualityScore}/10
      - å”èª¿æ€§ã‚¹ã‚³ã‚¢: ${eval.collaborationScore}/10
      - å®Œäº†ç‡: ${eval.completionRate}%
    `).join('\n')}
    
    ä»¥ä¸‹ã®åŸºæº–ã§æœ€é©ãªé…åˆ†ã‚’ææ¡ˆ:
    1. è² è·ãƒãƒ©ãƒ³ã‚¹ (80%ä»¥ä¸‹æ¨å¥¨)
    2. ã‚¹ã‚­ãƒ«é©åˆåº¦ (7/10ä»¥ä¸Šæ¨å¥¨)
    3. å“è³ªãƒ»å”èª¿æ€§ (å„7/10ä»¥ä¸Šæ¨å¥¨)
    4. éå»ã®æˆæœ (å®Œäº†ç‡80%ä»¥ä¸Šæ¨å¥¨)
    5. å­¦ç¿’æ©Ÿä¼šæä¾›
    6. ãƒãƒ¼ãƒ æ§‹æˆã®ãƒãƒ©ãƒ³ã‚¹
    
    å›ç­”å½¢å¼:
    {
      "recommendedUsers": [
        {
          "userId": "user_id",
          "userName": "ãƒ¦ãƒ¼ã‚¶ãƒ¼å",
          "allocationScore": 9.2,
          "expectedHours": 10,
          "reasonForRecommendation": "é«˜ã„ã‚¹ã‚­ãƒ«é©åˆåº¦ã¨é©åˆ‡ãªè² è·ãƒãƒ©ãƒ³ã‚¹",
          "riskFactors": ["ç· åˆ‡ãŒã‚¿ã‚¤ãƒˆ", "ä»–ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¨ã®é‡è¤‡"]
        }
      ],
      "allocationStrategy": "ãƒ¡ã‚¤ãƒ³æ‹…å½“è€…1å + ã‚µãƒãƒ¼ãƒˆ1åã®ä½“åˆ¶",
      "expectedOutcome": "å“è³ªã¨ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ä¸¡ç«‹ãŒæœŸå¾…ã•ã‚Œã‚‹",
      "alternativeOptions": ["å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹æ´»ç”¨", "ãƒ•ã‚§ãƒ¼ã‚ºåˆ†å‰²å®Ÿè£…"]
    }
    `);

    return this.parseOptimalAllocation(aiRecommendation);
  }

  /**
   * å­¦ç”Ÿã®é©åˆåº¦è©•ä¾¡
   */
  private async evaluateStudentFitness(
    student: StudentResource,
    request: ResourceAllocationRequest
  ): Promise<StudentFitnessEvaluation> {
    const currentLoad = await this.calculateUserLoad(student.userId);
    const skillMatch = this.calculateSkillMatch(student.technicalSkills, request.requiredSkills);
    
    return {
      student,
      currentLoad,
      skillMatch,
      qualityScore: student.qualityScore * 10,
      collaborationScore: student.collaborationScore * 10,
      completionRate: student.taskCompletionRate * 100,
      availableHours: this.calculateAvailableHours(student, request.deadline),
      riskFactors: this.identifyRiskFactors(student, request)
    };
  }

  /**
   * ã‚¹ã‚­ãƒ«é©åˆåº¦è¨ˆç®—
   */
  private calculateSkillMatch(userSkills: string[], requiredSkills: string[]): number {
    if (requiredSkills.length === 0) return 10;
    
    const matches = requiredSkills.filter(skill => 
      userSkills.some(userSkill => 
        userSkill.toLowerCase().includes(skill.toLowerCase()) ||
        skill.toLowerCase().includes(userSkill.toLowerCase())
      )
    );
    
    return (matches.length / requiredSkills.length) * 10;
  }

  /**
   * åˆ©ç”¨å¯èƒ½æ™‚é–“è¨ˆç®—
   */
  private calculateAvailableHours(
    student: StudentResource,
    deadline: Date
  ): number {
    const weeksUntilDeadline = Math.ceil(
      (deadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24 * 7)
    );
    
    const weeklyAvailable = student.weeklyCommitHours * 
      (1 - (student.currentLoadPercentage / 100));
    
    return Math.max(weeklyAvailable * weeksUntilDeadline, 0);
  }

  /**
   * ãƒªã‚¹ã‚¯è¦å› ç‰¹å®š
   */
  private identifyRiskFactors(
    student: StudentResource,
    request: ResourceAllocationRequest
  ): string[] {
    const risks: string[] = [];
    
    if (student.currentLoadPercentage > 80) {
      risks.push('é«˜è² è·çŠ¶æ…‹');
    }
    
    if (student.taskCompletionRate < 0.8) {
      risks.push('å®Œäº†ç‡ãŒä½ã„');
    }
    
    if (student.qualityScore < 0.7) {
      risks.push('å“è³ªã‚¹ã‚³ã‚¢ãŒä½ã„');
    }
    
    if (request.urgency === 'HIGH' && student.currentLoadPercentage > 60) {
      risks.push('ç·Šæ€¥æ¡ˆä»¶ã¨ã®è² è·ç«¶åˆ');
    }
    
    return risks;
  }

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  private async getUser(userId: string) {
    // æ—¢å­˜ã®user service ã‚’æ´»ç”¨
    return await this.userService.getUser(userId);
  }

  private async getStudentResource(userId: string): Promise<StudentResource | null> {
    const query = `
      SELECT * FROM student_resources 
      WHERE user_id = $1
    `;
    const result = await this.db.query(query, [userId]);
    return result.rows[0] || null;
  }

  private async getUserActiveTasks(userId: string) {
    return await this.taskService.getActiveTasks(userId);
  }

  private async getUserActiveProjects(userId: string) {
    const query = `
      SELECT * FROM project_resource_allocation 
      WHERE student_resource_id = (
        SELECT id FROM student_resources WHERE user_id = $1
      ) AND end_date IS NULL
    `;
    const result = await this.db.query(query, [userId]);
    return result.rows;
  }

  private async getAvailableStudents(request: ResourceAllocationRequest) {
    const query = `
      SELECT sr.*, u.name, u.email 
      FROM student_resources sr
      JOIN users u ON sr.user_id = u.id
      WHERE sr.current_load_percentage < 90
      ORDER BY sr.current_load_percentage ASC
    `;
    const result = await this.db.query(query);
    return result.rows;
  }

  private parseOptimalAllocation(aiResponse: string): OptimalAllocation {
    try {
      return JSON.parse(aiResponse);
    } catch (error) {
      console.error('AI response parsing error:', error);
      return {
        recommendedUsers: [],
        allocationStrategy: 'AIå¿œç­”ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ',
        expectedOutcome: 'æ‰‹å‹•ã§é…åˆ†ã‚’æ¤œè¨ã—ã¦ãã ã•ã„',
        alternativeOptions: ['æ‰‹å‹•é…åˆ†', 'å¤–éƒ¨ãƒªã‚½ãƒ¼ã‚¹æ¤œè¨']
      };
    }
  }
}

// å‹å®šç¾©
interface StudentFitnessEvaluation {
  student: StudentResource;
  currentLoad: number;
  skillMatch: number;
  qualityScore: number;
  collaborationScore: number;
  completionRate: number;
  availableHours: number;
  riskFactors: string[];
}
```

### **1.3 MBTIçµ±åˆã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**

#### **1.3.1 MBTITeamOptimizer ã‚¯ãƒ©ã‚¹**
```typescript
// src/services/MBTITeamOptimizer.ts
import { AI_SERVICE } from './ai-service';
import mbtiData from '../../public/data/mbti.json';

export interface MBTIProfile {
  type: string;
  personalityTraits: {
    independence: number;
    strategic_thinking: number;
    leadership_tendency: number;
    detail_orientation: number;
    innovation_preference: number;
  };
  taskPreferences: {
    complex_problem_solving: number;
    routine_tasks: number;
    creative_tasks: number;
    analytical_tasks: number;
    leadership_tasks: number;
  };
  teamCompatibility: Record<string, number>;
  optimalRoles: string[];
  stressFactors: string[];
  motivationFactors: string[];
}

export interface TeamOptimizationRequest {
  projectId: string;
  projectType: string;
  requiredRoles: string[];
  teamSize: number;
  projectDuration: number;
  complexityLevel: number;
  availableMembers: string[];
}

export interface OptimalTeam {
  members: Array<{
    userId: string;
    userName: string;
    mbtiType: string;
    assignedRole: string;
    compatibilityScore: number;
    contributionExpected: string;
    developmentOpportunity: string;
  }>;
  teamCompatibilityScore: number;
  predictedDynamics: string;
  potentialChallenges: string[];
  managementTips: string[];
  alternativeCompositions: string[];
}

export class MBTITeamOptimizer {
  private mbtiProfiles: Record<string, MBTIProfile>;

  constructor(private aiService: typeof AI_SERVICE) {
    this.mbtiProfiles = mbtiData.mbti_types;
  }

  /**
   * æœ€é©ãƒãƒ¼ãƒ ç·¨æˆã‚’ç”Ÿæˆ
   */
  async optimizeTeamComposition(
    request: TeamOptimizationRequest
  ): Promise<OptimalTeam> {
    const availableMembers = await this.getAvailableMembersWithMBTI(request.availableMembers);
    const roleRequirements = await this.analyzeRoleRequirements(request.requiredRoles, request.projectType);
    
    // AI ã«ã‚ˆã‚‹æœ€é©åŒ–åˆ¤æ–­
    const teamOptimization = await this.aiService.evaluateWithGemini(`
    MBTI ãƒãƒ¼ãƒ ç·¨æˆæœ€é©åŒ–:
    
    ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±:
    - ã‚¿ã‚¤ãƒ—: ${request.projectType}
    - å¿…è¦å½¹å‰²: ${request.requiredRoles.join(', ')}
    - ãƒãƒ¼ãƒ ã‚µã‚¤ã‚º: ${request.teamSize}å
    - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæœŸé–“: ${request.projectDuration}é€±é–“
    - è¤‡é›‘åº¦: ${request.complexityLevel}/10
    
    åˆ©ç”¨å¯èƒ½ãƒ¡ãƒ³ãƒãƒ¼:
    ${availableMembers.map(member => `
    - ${member.name} (${member.mbtiType}):
      ${this.formatMBTIProfile(member.mbtiType)}
    `).join('\n')}
    
    å½¹å‰²è¦ä»¶åˆ†æ:
    ${roleRequirements.map(req => `
    - ${req.role}: ${req.requirements.join(', ')}
    `).join('\n')}
    
    ä»¥ä¸‹ã®åŸºæº–ã§æœ€é©ãªãƒãƒ¼ãƒ ç·¨æˆã‚’ææ¡ˆ:
    
    1. å½¹å‰²é©æ€§ãƒãƒƒãƒãƒ³ã‚°
       - å„MBTIã‚¿ã‚¤ãƒ—ã®å¼·ã¿ã‚’æ´»ã‹ã—ãŸå½¹å‰²é…åˆ†
       - ã‚¿ã‚¹ã‚¯é©æ€§ã‚¹ã‚³ã‚¢ã‚’è€ƒæ…®
    
    2. ãƒãƒ¼ãƒ å†…ãƒãƒ©ãƒ³ã‚¹
       - æ€§æ ¼ã®å¤šæ§˜æ€§ç¢ºä¿
       - ç›¸äº’è£œå®Œçš„ãªçµ„ã¿åˆã‚ã›
       - ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—ãƒ»ã‚µãƒãƒ¼ãƒˆå½¹ã®ãƒãƒ©ãƒ³ã‚¹
    
    3. ç›¸æ€§ãƒ»å”èª¿æ€§
       - MBTIç›¸æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹æ´»ç”¨
       - ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã®é©åˆ
       - ä¾¡å€¤è¦³ãƒ»å‹•æ©Ÿã®æ•´åˆæ€§
    
    4. æˆé•·ãƒ»é–‹ç™ºæ©Ÿä¼š
       - å„ãƒ¡ãƒ³ãƒãƒ¼ã®å­¦ç¿’æ©Ÿä¼šæä¾›
       - è‹¦æ‰‹åˆ†é‡ã¸ã®æŒ‘æˆ¦ã‚µãƒãƒ¼ãƒˆ
       - ã‚­ãƒ£ãƒªã‚¢ç™ºå±•ã¸ã®è²¢çŒ®
    
    5. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæˆåŠŸè¦å› 
       - è¤‡é›‘åº¦ã«å¯¾ã™ã‚‹é©å¿œåŠ›
       - æœŸé–“å†…å®Œäº†ã¸ã®é©æ€§
       - å“è³ªç¢ºä¿ã¸ã®è²¢çŒ®
    
    å›ç­”å½¢å¼:
    {
      "members": [
        {
          "userId": "user_id",
          "userName": "ãƒ¦ãƒ¼ã‚¶ãƒ¼å",
          "mbtiType": "INTJ",
          "assignedRole": "ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒªãƒ¼ãƒ‰",
          "compatibilityScore": 8.5,
          "contributionExpected": "æˆ¦ç•¥çš„æŠ€è¡“åˆ¤æ–­ã¨å“è³ªç®¡ç†",
          "developmentOpportunity": "ãƒãƒ¼ãƒ ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³å‘ä¸Š"
        }
      ],
      "teamCompatibilityScore": 8.2,
      "predictedDynamics": "åˆ†æå¿—å‘ã¨å®Ÿè¡ŒåŠ›ã®ãƒãƒ©ãƒ³ã‚¹å–ã‚ŒãŸãƒãƒ¼ãƒ ",
      "potentialChallenges": ["åˆæœŸæ®µéšã®ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³èª¿æ•´"],
      "managementTips": ["å®šæœŸçš„ãª1on1ã§å€‹åˆ¥ãƒ•ã‚©ãƒ­ãƒ¼å®Ÿæ–½"],
      "alternativeCompositions": ["ã‚ˆã‚Šã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–é‡è¦–ã®æ§‹æˆã‚‚æ¤œè¨å¯èƒ½"]
    }
    `);

    return this.parseTeamOptimization(teamOptimization);
  }

  /**
   * MBTIç›¸æ€§åˆ†æ
   */
  async analyzeTeamCompatibility(mbtiTypes: string[]): Promise<{
    overallScore: number;
    pairwiseScores: Record<string, number>;
    strengths: string[];
    challenges: string[];
    recommendations: string[];
  }> {
    const pairwiseScores: Record<string, number> = {};
    let totalScore = 0;
    let pairCount = 0;

    // å…¨ãƒšã‚¢çµ„ã¿åˆã‚ã›ã®ç›¸æ€§ã‚’è¨ˆç®—
    for (let i = 0; i < mbtiTypes.length; i++) {
      for (let j = i + 1; j < mbtiTypes.length; j++) {
        const type1 = mbtiTypes[i];
        const type2 = mbtiTypes[j];
        const compatibility = this.mbtiProfiles[type1]?.teamCompatibility[type2] || 5;
        
        pairwiseScores[`${type1}-${type2}`] = compatibility;
        totalScore += compatibility;
        pairCount++;
      }
    }

    const overallScore = pairCount > 0 ? totalScore / pairCount : 5;

    // AI ã«ã‚ˆã‚‹è©³ç´°åˆ†æ
    const analysis = await this.aiService.evaluateWithGemini(`
    MBTI ãƒãƒ¼ãƒ ç›¸æ€§åˆ†æ:
    
    ãƒãƒ¼ãƒ æ§‹æˆ: ${mbtiTypes.join(', ')}
    
    ãƒšã‚¢ç›¸æ€§ã‚¹ã‚³ã‚¢:
    ${Object.entries(pairwiseScores).map(([pair, score]) => 
      `${pair}: ${score}/10`
    ).join('\n')}
    
    å…¨ä½“ç›¸æ€§ã‚¹ã‚³ã‚¢: ${overallScore.toFixed(1)}/10
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§åˆ†æ:
    1. ãƒãƒ¼ãƒ ã®å¼·ã¿ï¼ˆç›¸æ€§ã®è‰¯ã„çµ„ã¿åˆã‚ã›ã‹ã‚‰ç”Ÿã¾ã‚Œã‚‹åŠ¹æœï¼‰
    2. æ½œåœ¨çš„èª²é¡Œï¼ˆç›¸æ€§ã®æ‚ªã„çµ„ã¿åˆã‚ã›ã¸ã®å¯¾ç­–ï¼‰
    3. ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆæ¨å¥¨äº‹é …
    
    å›ç­”å½¢å¼:
    {
      "strengths": ["å¼·ã¿1", "å¼·ã¿2"],
      "challenges": ["èª²é¡Œ1", "èª²é¡Œ2"],
      "recommendations": ["æ¨å¥¨äº‹é …1", "æ¨å¥¨äº‹é …2"]
    }
    `);

    const parsedAnalysis = this.parseCompatibilityAnalysis(analysis);

    return {
      overallScore,
      pairwiseScores,
      ...parsedAnalysis
    };
  }

  /**
   * å€‹äººMBTIåˆ†æ
   */
  async analyzeIndividualMBTI(userId: string): Promise<{
    mbtiType: string;
    profile: MBTIProfile;
    strengths: string[];
    developmentAreas: string[];
    optimalRoles: string[];
    teamContributions: string[];
    managementTips: string[];
  }> {
    const user = await this.getUser(userId);
    const mbtiType = user.mbtiType;
    
    if (!mbtiType || !this.mbtiProfiles[mbtiType]) {
      throw new Error(`MBTI type not found for user ${userId}`);
    }

    const profile = this.mbtiProfiles[mbtiType];
    
    const analysis = await this.aiService.evaluateWithGemini(`
    å€‹äººMBTIåˆ†æ: ${mbtiType}
    
    åŸºæœ¬ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«:
    ${this.formatMBTIProfile(mbtiType)}
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§åˆ†æ:
    1. ä¸»è¦ãªå¼·ã¿ï¼ˆæœ€ã‚‚æ´»ã‹ã›ã‚‹èƒ½åŠ›ãƒ»ç‰¹æ€§ï¼‰
    2. æˆé•·æ©Ÿä¼šï¼ˆä¼¸ã°ã™ã¹ãåˆ†é‡ï¼‰
    3. æœ€é©ãªå½¹å‰²ãƒ»ãƒã‚¸ã‚·ãƒ§ãƒ³
    4. ãƒãƒ¼ãƒ ã¸ã®è²¢çŒ®æ–¹æ³•
    5. åŠ¹æœçš„ãªãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆæ–¹æ³•
    
    å›ç­”å½¢å¼:
    {
      "strengths": ["å¼·ã¿1", "å¼·ã¿2"],
      "developmentAreas": ["æˆé•·åˆ†é‡1", "æˆé•·åˆ†é‡2"],
      "optimalRoles": ["æœ€é©å½¹å‰²1", "æœ€é©å½¹å‰²2"],
      "teamContributions": ["ãƒãƒ¼ãƒ è²¢çŒ®1", "ãƒãƒ¼ãƒ è²¢çŒ®2"],
      "managementTips": ["ãƒãƒã‚¸ãƒ¡ãƒ³ãƒˆtip1", "tip2"]
    }
    `);

    const parsedAnalysis = this.parseIndividualAnalysis(analysis);

    return {
      mbtiType,
      profile,
      ...parsedAnalysis
    };
  }

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  private async getAvailableMembersWithMBTI(userIds: string[]) {
    const query = `
      SELECT id, name, email, mbti_type 
      FROM users 
      WHERE id = ANY($1) AND mbti_type IS NOT NULL
    `;
    const result = await this.db.query(query, [userIds]);
    return result.rows;
  }

  private async analyzeRoleRequirements(roles: string[], projectType: string) {
    return roles.map(role => ({
      role,
      requirements: this.extractRoleRequirements(role, projectType)
    }));
  }

  private extractRoleRequirements(role: string, projectType: string): string[] {
    const roleRequirements: Record<string, string[]> = {
      'ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼': ['leadership_tasks', 'strategic_thinking', 'communication'],
      'ãƒ†ã‚¯ãƒ‹ã‚«ãƒ«ãƒªãƒ¼ãƒ‰': ['complex_problem_solving', 'analytical_tasks', 'technical_expertise'],
      'ãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼': ['creative_tasks', 'innovation_preference', 'user_empathy'],
      'ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢': ['analytical_tasks', 'detail_orientation', 'technical_skills'],
      'QA': ['detail_orientation', 'analytical_tasks', 'quality_focus'],
      'ãƒãƒ¼ã‚±ã‚¿ãƒ¼': ['creative_tasks', 'communication', 'strategic_thinking']
    };

    return roleRequirements[role] || ['general_skills'];
  }

  private formatMBTIProfile(mbtiType: string): string {
    const profile = this.mbtiProfiles[mbtiType];
    if (!profile) return 'ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ä¸æ˜';

    return `
      ç‹¬ç«‹æ€§: ${profile.personalityTraits.independence}/10
      æˆ¦ç•¥æ€è€ƒ: ${profile.personalityTraits.strategic_thinking}/10
      ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—: ${profile.personalityTraits.leadership_tendency}/10
      è©³ç´°å¿—å‘: ${profile.personalityTraits.detail_orientation}/10
      é©æ–°æ€§: ${profile.personalityTraits.innovation_preference}/10
      
      ã‚¿ã‚¹ã‚¯é©æ€§:
      - è¤‡é›‘å•é¡Œè§£æ±º: ${profile.taskPreferences.complex_problem_solving}/10
      - å‰µé€ çš„ä½œæ¥­: ${profile.taskPreferences.creative_tasks}/10
      - åˆ†æä½œæ¥­: ${profile.taskPreferences.analytical_tasks}/10
      - ãƒªãƒ¼ãƒ€ãƒ¼ã‚·ãƒƒãƒ—: ${profile.taskPreferences.leadership_tasks}/10
      
      æœ€é©å½¹å‰²: ${profile.optimalRoles.join(', ')}
      å‹•æ©Ÿè¦å› : ${profile.motivationFactors.join(', ')}
    `;
  }

  private parseTeamOptimization(aiResponse: string): OptimalTeam {
    try {
      return JSON.parse(aiResponse);
    } catch (error) {
      console.error('Team optimization parsing error:', error);
      return {
        members: [],
        teamCompatibilityScore: 5,
        predictedDynamics: 'AIå¿œç­”ã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ',
        potentialChallenges: ['æ‰‹å‹•ã§ãƒãƒ¼ãƒ ç·¨æˆã‚’æ¤œè¨ã—ã¦ãã ã•ã„'],
        managementTips: ['å€‹åˆ¥ã® MBTI åˆ†æã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„'],
        alternativeCompositions: ['ç•°ãªã‚‹çµ„ã¿åˆã‚ã›ã‚’æ¤œè¨ã—ã¦ãã ã•ã„']
      };
    }
  }

  private parseCompatibilityAnalysis(aiResponse: string) {
    try {
      return JSON.parse(aiResponse);
    } catch (error) {
      return {
        strengths: ['AIå¿œç­”ã®è§£æã«å¤±æ•—'],
        challenges: ['æ‰‹å‹•ã§ç›¸æ€§ã‚’è©•ä¾¡ã—ã¦ãã ã•ã„'],
        recommendations: ['å€‹åˆ¥åˆ†æã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„']
      };
    }
  }

  private parseIndividualAnalysis(aiResponse: string) {
    try {
      return JSON.parse(aiResponse);
    } catch (error) {
      return {
        strengths: ['AIå¿œç­”ã®è§£æã«å¤±æ•—'],
        developmentAreas: ['æ‰‹å‹•ã§åˆ†æã—ã¦ãã ã•ã„'],
        optimalRoles: ['MBTIè³‡æ–™ã‚’å‚è€ƒã«ã—ã¦ãã ã•ã„'],
        teamContributions: ['å€‹åˆ¥ç›¸è«‡ã‚’å®Ÿæ–½ã—ã¦ãã ã•ã„'],
        managementTips: ['å¾“æ¥ã®æ–¹æ³•ã‚’ç¶™ç¶šã—ã¦ãã ã•ã„']
      };
    }
  }
}
```

### **1.4 API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…**

#### **1.4.1 å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹ç®¡ç†API**
```typescript
// src/pages/api/student-resources/index.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { StudentResourceManager } from '../../../services/StudentResourceManager';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const resourceManager = new StudentResourceManager();

  switch (req.method) {
    case 'GET':
      return handleGetStudentResources(req, res, resourceManager);
    case 'POST':
      return handleCreateStudentResource(req, res, resourceManager);
    case 'PUT':
      return handleUpdateStudentResource(req, res, resourceManager);
    default:
      return res.status(405).json({ error: 'Method not allowed' });
  }
}

async function handleGetStudentResources(
  req: NextApiRequest,
  res: NextApiResponse,
  resourceManager: StudentResourceManager
) {
  try {
    const { userId } = req.query;
    
    if (userId) {
      const load = await resourceManager.calculateUserLoad(userId as string);
      const resource = await resourceManager.getStudentResource(userId as string);
      
      return res.status(200).json({
        studentResource: resource,
        currentLoad: load
      });
    } else {
      const allResources = await resourceManager.getAllStudentResources();
      return res.status(200).json({ studentResources: allResources });
    }
  } catch (error) {
    console.error('Error fetching student resources:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

// src/pages/api/student-resources/optimize.ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const resourceManager = new StudentResourceManager();
    const optimizationRequest = req.body;
    
    const result = await resourceManager.optimizeResourceAllocation(optimizationRequest);
    
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error optimizing resource allocation:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}
```

#### **1.4.2 MBTI ãƒãƒ¼ãƒ æœ€é©åŒ–API**
```typescript
// src/pages/api/mbti/team-optimization.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { MBTITeamOptimizer } from '../../../services/MBTITeamOptimizer';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const optimizer = new MBTITeamOptimizer();
    const optimizationRequest = req.body;
    
    const result = await optimizer.optimizeTeamComposition(optimizationRequest);
    
    return res.status(200).json(result);
  } catch (error) {
    console.error('Error optimizing team composition:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

// src/pages/api/mbti/compatibility.ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const optimizer = new MBTITeamOptimizer();
    const { mbtiTypes } = req.body;
    
    const compatibility = await optimizer.analyzeTeamCompatibility(mbtiTypes);
    
    return res.status(200).json(compatibility);
  } catch (error) {
    console.error('Error analyzing team compatibility:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}

// src/pages/api/mbti/individual/[userId].ts
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const optimizer = new MBTITeamOptimizer();
    const { userId } = req.query;
    
    const analysis = await optimizer.analyzeIndividualMBTI(userId as string);
    
    return res.status(200).json(analysis);
  } catch (error) {
    console.error('Error analyzing individual MBTI:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
}
```

---

## ğŸ§ª **Phase 1 ãƒ†ã‚¹ãƒˆè¨ˆç”»**

### **1.1 å˜ä½“ãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/StudentResourceManager.test.ts
import { StudentResourceManager } from '../src/services/StudentResourceManager';

describe('StudentResourceManager', () => {
  let resourceManager: StudentResourceManager;

  beforeEach(() => {
    resourceManager = new StudentResourceManager();
  });

  test('calculateUserLoad should return correct load percentage', async () => {
    const userId = 'test-user-1';
    const load = await resourceManager.calculateUserLoad(userId);
    
    expect(load).toBeGreaterThanOrEqual(0);
    expect(load).toBeLessThanOrEqual(100);
  });

  test('optimizeResourceAllocation should return valid recommendations', async () => {
    const request = {
      projectId: 'test-project',
      requiredHours: 20,
      requiredSkills: ['React', 'TypeScript'],
      preferredRole: 'Frontend Developer',
      urgency: 'MEDIUM',
      deadline: new Date('2025-07-15')
    };

    const result = await resourceManager.optimizeResourceAllocation(request);
    
    expect(result.recommendedUsers).toBeInstanceOf(Array);
    expect(result.allocationStrategy).toBeTruthy();
  });
});

// __tests__/MBTITeamOptimizer.test.ts
import { MBTITeamOptimizer } from '../src/services/MBTITeamOptimizer';

describe('MBTITeamOptimizer', () => {
  let optimizer: MBTITeamOptimizer;

  beforeEach(() => {
    optimizer = new MBTITeamOptimizer();
  });

  test('optimizeTeamComposition should return valid team', async () => {
    const request = {
      projectId: 'test-project',
      projectType: 'Web Development',
      requiredRoles: ['Project Manager', 'Developer'],
      teamSize: 3,
      projectDuration: 8,
      complexityLevel: 7,
      availableMembers: ['user1', 'user2', 'user3', 'user4']
    };

    const result = await optimizer.optimizeTeamComposition(request);
    
    expect(result.members).toBeInstanceOf(Array);
    expect(result.teamCompatibilityScore).toBeGreaterThan(0);
  });

  test('analyzeTeamCompatibility should calculate correct scores', async () => {
    const mbtiTypes = ['INTJ', 'ENFP', 'ISTJ'];
    
    const compatibility = await optimizer.analyzeTeamCompatibility(mbtiTypes);
    
    expect(compatibility.overallScore).toBeGreaterThan(0);
    expect(compatibility.pairwiseScores).toBeTruthy();
  });
});
```

### **1.2 çµ±åˆãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/integration/Phase1Integration.test.ts
import { StudentResourceManager } from '../../src/services/StudentResourceManager';
import { MBTITeamOptimizer } from '../../src/services/MBTITeamOptimizer';

describe('Phase 1 Integration Tests', () => {
  test('Resource allocation and MBTI optimization should work together', async () => {
    const resourceManager = new StudentResourceManager();
    const mbtiOptimizer = new MBTITeamOptimizer();

    // 1. ãƒªã‚½ãƒ¼ã‚¹æœ€é©åŒ–
    const resourceRequest = {
      projectId: 'integration-test',
      requiredHours: 40,
      requiredSkills: ['JavaScript', 'React'],
      preferredRole: 'Full Stack Developer',
      urgency: 'MEDIUM',
      deadline: new Date('2025-08-01')
    };

    const resourceResult = await resourceManager.optimizeResourceAllocation(resourceRequest);
    
    // 2. MBTI ãƒãƒ¼ãƒ æœ€é©åŒ–
    const teamRequest = {
      projectId: 'integration-test',
      projectType: 'Web Application',
      requiredRoles: ['Developer', 'Designer'],
      teamSize: 2,
      projectDuration: 6,
      complexityLevel: 6,
      availableMembers: resourceResult.recommendedUsers.map(u => u.userId)
    };

    const teamResult = await mbtiOptimizer.optimizeTeamComposition(teamRequest);
    
    expect(teamResult.members.length).toBeGreaterThan(0);
    expect(teamResult.teamCompatibilityScore).toBeGreaterThan(5);
  });
});
```

---

## ğŸ“Š **Phase 1 æˆåŠŸæŒ‡æ¨™**

### **1.1 å®šé‡æŒ‡æ¨™**
- [ ] **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µ**: ã‚¨ãƒ©ãƒ¼ãªã—ã§å®Œäº†
- [ ] **API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“**: < 500ms
- [ ] **ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸**: 80%ä»¥ä¸Š
- [ ] **TypeScript ã‚¨ãƒ©ãƒ¼**: 0ä»¶
- [ ] **ESLint ã‚¨ãƒ©ãƒ¼**: 0ä»¶

### **1.2 æ©Ÿèƒ½æŒ‡æ¨™**
- [ ] **è² è·è¨ˆç®—ç²¾åº¦**: æ—¢å­˜ã‚¿ã‚¹ã‚¯ãƒ‡ãƒ¼ã‚¿ã¨ã®æ•´åˆæ€§ 95%
- [ ] **MBTI ãƒãƒ¼ãƒ æœ€é©åŒ–**: ç›¸æ€§ã‚¹ã‚³ã‚¢ 7.0ä»¥ä¸Š
- [ ] **ãƒªã‚½ãƒ¼ã‚¹æ¨å¥¨ç²¾åº¦**: é©åˆ‡ãªæ¨å¥¨ 80%ä»¥ä¸Š

### **1.3 é‹ç”¨æŒ‡æ¨™**
- [ ] **æ—¢å­˜æ©Ÿèƒ½**: 100%å‹•ä½œç¶­æŒ
- [ ] **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§**: ç ´ç¶»ãªã—
- [ ] **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: æ—¢å­˜ãƒ¬ãƒ™ãƒ«ç¶­æŒ

---

## âš ï¸ **Phase 1 æ³¨æ„äº‹é …ãƒ»åˆ¶ç´„**

### **1.1 æŠ€è¡“åˆ¶ç´„**
- æ—¢å­˜èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã®äº’æ›æ€§å¿…é ˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç ´å£Šçš„å¤‰æ›´ç¦æ­¢
- æ—¢å­˜APIã¨ã®å¾Œæ–¹äº’æ›æ€§ç¶­æŒ

### **1.2 ãƒ‡ãƒ¼ã‚¿åˆ¶ç´„**
- æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å®Œå…¨ä¿æŒ
- MBTIã‚¿ã‚¤ãƒ—ã®æ®µéšçš„è¨­å®šï¼ˆå¼·åˆ¶ãªã—ï¼‰
- å­¦ç”Ÿãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä»»æ„å…¥åŠ›

### **1.3 é‹ç”¨åˆ¶ç´„**
- æ®µéšçš„å±•é–‹ï¼ˆå¼·åˆ¶ç§»è¡Œãªã—ï¼‰
- æ—¢å­˜ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ç¶­æŒ
- ãƒ¦ãƒ¼ã‚¶ãƒ¼æ··ä¹±ã®æœ€å°åŒ–

---

## ğŸš€ **Phase 1 å®Œäº†åŸºæº–**

### **1.1 æ©Ÿèƒ½å®Œäº†åŸºæº–**
1. **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ‹¡å¼µå®Œäº†**
   - [ ] ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆæˆåŠŸ
   - [ ] ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®šå®Œäº†
   - [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ç¢ºä¿

2. **StudentResourceManager å®Ÿè£…å®Œäº†**
   - [ ] è² è·è¨ˆç®—æ©Ÿèƒ½å‹•ä½œ
   - [ ] æœ€é©åŒ–æ¨å¥¨æ©Ÿèƒ½å‹•ä½œ
   - [ ] API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå‹•ä½œ

3. **MBTITeamOptimizer å®Ÿè£…å®Œäº†**
   - [ ] ãƒãƒ¼ãƒ æœ€é©åŒ–æ©Ÿèƒ½å‹•ä½œ
   - [ ] ç›¸æ€§åˆ†ææ©Ÿèƒ½å‹•ä½œ
   - [ ] å€‹äººåˆ†ææ©Ÿèƒ½å‹•ä½œ

### **1.2 å“è³ªå®Œäº†åŸºæº–**
- [ ] å…¨ãƒ†ã‚¹ãƒˆé€šé
- [ ] ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™å®Œäº†
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯å®Œäº†

### **1.3 é‹ç”¨å®Œäº†åŸºæº–**
- [ ] æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸ
- [ ] ç›£è¦–ãƒ»ãƒ­ã‚°è¨­å®šå®Œäº†
- [ ] ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ç¢ºèªå®Œäº†

---

**æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: Phase 1 å®Ÿè£…é–‹å§‹æº–å‚™å®Œäº†ã€‚æ‹…å½“ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¯ã“ã®è¨ˆç”»æ›¸ã«å¾“ã£ã¦å®Ÿè£…ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚