# ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰ Phase A: åŸºç›¤æ§‹ç¯‰ å®Ÿè£…è¨ˆç”»æ›¸

**ãƒ•ã‚§ãƒ¼ã‚ºæœŸé–“**: 3æ—¥é–“  
**å®Ÿè£…æ—¥**: 2025å¹´6æœˆ28æ—¥ ã€œ 2025å¹´6æœˆ30æ—¥  
**æ‹…å½“ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**: ãƒ¢ãƒã‚¤ãƒ«UI/UXæ‹…å½“  
**å‰ææ¡ä»¶**: æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹é€ ã‚’ç†è§£ã—ã€ãƒ¢ãƒã‚¤ãƒ«é–‹ç™ºçµŒé¨“ã‚’æœ‰ã™ã‚‹

---

## ğŸ¯ **Phase A å®Ÿè£…ç›®æ¨™**

### **A.1 ä¸»è¦æ©Ÿèƒ½å®Ÿè£…**
- **ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰åŸºç›¤**: ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ»ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆãƒ»åŸºæœ¬ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
- **ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚·ã‚¹ãƒ†ãƒ **: ã‚¹ãƒ¯ã‚¤ãƒ—ãƒ»ã‚¿ãƒƒãƒ—ãƒ»é•·æŠ¼ã—åŸºæœ¬åˆ¶å¾¡
- **ãƒ‡ãƒ¼ã‚¿é€£æºåŸºç›¤**: æ—¢å­˜APIãƒ»DBå®Œå…¨çµ±åˆãƒ»ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ

### **A.2 æŠ€è¡“è¦ä»¶**
- æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨äº’æ›æ€§ç¶­æŒ
- ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ãƒ•ã‚©ãƒ«ãƒ€æ§‹é€ ã®æ–°è¦è¿½åŠ ã®ã¿
- PWAåŸºç›¤ãƒ»ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã®å®Ÿè£…
- æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ»APIã®å®Œå…¨æ´»ç”¨

---

## ğŸ“‹ **Phase A å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**

### **A.1 ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰åŸºç›¤æ§‹ç¯‰ (1æ—¥)**
- [ ] `/pages/mobile/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆãƒ»åŸºæœ¬ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°å®Ÿè£…
- [ ] `/components/mobile/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆãƒ»åŸºæœ¬ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½å®Ÿè£…ï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—â†”ãƒ¢ãƒã‚¤ãƒ«ï¼‰
- [ ] ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆãƒ»ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè£…

### **A.2 ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ  (1æ—¥)**
- [ ] Hammer.jsçµ±åˆãƒ»åŸºæœ¬ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼èªè­˜
- [ ] ã‚¹ãƒ¯ã‚¤ãƒ—ãƒ»ã‚¿ãƒƒãƒ—ãƒ»é•·æŠ¼ã—ãƒ»ãƒ”ãƒ³ãƒåˆ¶å¾¡å®Ÿè£…
- [ ] è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ»è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å®Ÿè£…
- [ ] ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼è¨­å®šãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºæ©Ÿèƒ½

### **A.3 ãƒ‡ãƒ¼ã‚¿çµ±åˆãƒ»åŒæœŸã‚·ã‚¹ãƒ†ãƒ  (0.5æ—¥)**
- [ ] æ—¢å­˜APIå®Œå…¨æ´»ç”¨ãƒ»ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä½œæˆ
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸï¼ˆWebSocketãƒ»SSEï¼‰å®Ÿè£…
- [ ] æ¥½è¦³çš„UIæ›´æ–°ãƒ»ç«¶åˆè§£æ±ºæ©Ÿèƒ½
- [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã®å®Œå…¨äº’æ›æ€§ç¢ºèª

### **A.4 PWAãƒ»ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åŸºç›¤ (0.5æ—¥)**
- [ ] PWAè¨­å®šï¼ˆmanifest.jsonãƒ»Service Workerï¼‰
- [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œï¼ˆIndexedDBãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ï¼‰
- [ ] ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¯èƒ½ãªPWAåŒ–
- [ ] ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥åŸºç›¤ï¼ˆå°†æ¥å¯¾å¿œæº–å‚™ï¼‰

---

## ğŸ”§ **è©³ç´°å®Ÿè£…ã‚¬ã‚¤ãƒ‰**

### **A.1 ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰åŸºç›¤æ§‹ç¯‰**

#### **A.1.1 ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ä½œæˆ**
```bash
# æ–°è¦ä½œæˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆæ—¢å­˜ã«è¿½åŠ ã®ã¿ï¼‰
src/
â”œâ”€â”€ components/mobile/           # ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”œâ”€â”€ ContextualDashboard.tsx
â”‚   â”‚   â”œâ”€â”€ TimeBasedView.tsx
â”‚   â”‚   â””â”€â”€ MobileStatsCard.tsx
â”‚   â”œâ”€â”€ gestures/
â”‚   â”‚   â”œâ”€â”€ GestureHandler.tsx
â”‚   â”‚   â”œâ”€â”€ SwipeController.tsx
â”‚   â”‚   â””â”€â”€ TouchFeedback.tsx
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ MobileLayout.tsx
â”‚   â”‚   â”œâ”€â”€ MobileNavigation.tsx
â”‚   â”‚   â””â”€â”€ ModeSwitcher.tsx
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ SwipeableCard.tsx
â”‚       â”œâ”€â”€ MobileButton.tsx
â”‚       â””â”€â”€ TouchTarget.tsx
â”œâ”€â”€ pages/mobile/               # ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ dashboard.tsx
â”‚   â”œâ”€â”€ tasks.tsx
â”‚   â”œâ”€â”€ quick-add.tsx
â”‚   â””â”€â”€ settings.tsx
â”œâ”€â”€ lib/mobile/                 # ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ãƒ­ã‚¸ãƒƒã‚¯
â”‚   â”œâ”€â”€ gestureHandling.ts
â”‚   â”œâ”€â”€ mobileSync.ts
â”‚   â”œâ”€â”€ contextAnalysis.ts
â”‚   â””â”€â”€ offlineManager.ts
â””â”€â”€ styles/mobile/              # ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ«
    â”œâ”€â”€ gestures.css
    â”œâ”€â”€ mobile-layout.css
    â””â”€â”€ animations.css
```

#### **A.1.2 åŸºæœ¬ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°å®Ÿè£…**
```typescript
// src/pages/mobile/dashboard.tsx
import { useState, useEffect } from 'react';
import { GetServerSideProps } from 'next';
import { getServerSession } from 'next-auth';
import { authOptions } from '../api/auth/[...nextauth]';
import MobileLayout from '../../components/mobile/layout/MobileLayout';
import ContextualDashboard from '../../components/mobile/dashboard/ContextualDashboard';
import { useContextAnalysis } from '../../hooks/mobile/useContextAnalysis';
import { useMobileSync } from '../../hooks/mobile/useMobileSync';

interface MobileDashboardProps {
  user: any;
  initialData: {
    tasks: any[];
    projects: any[];
    appointments: any[];
  };
}

export default function MobileDashboard({ user, initialData }: MobileDashboardProps) {
  const { context, updateContext } = useContextAnalysis();
  const { isOnline, syncStatus } = useMobileSync();
  
  return (
    <MobileLayout user={user} title="ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰">
      <ContextualDashboard
        context={context}
        initialData={initialData}
        isOnline={isOnline}
        syncStatus={syncStatus}
      />
    </MobileLayout>
  );
}

export const getServerSideProps: GetServerSideProps = async (context) => {
  const session = await getServerSession(context.req, context.res, authOptions);
  
  if (!session) {
    return {
      redirect: {
        destination: '/auth/signin',
        permanent: false,
      },
    };
  }

  // æ—¢å­˜APIã‹ã‚‰åˆæœŸãƒ‡ãƒ¼ã‚¿å–å¾—
  const [tasks, projects, appointments] = await Promise.all([
    fetch(`${process.env.NEXTAUTH_URL}/api/tasks?userId=${session.user.id}`),
    fetch(`${process.env.NEXTAUTH_URL}/api/projects?userId=${session.user.id}`),
    fetch(`${process.env.NEXTAUTH_URL}/api/appointments?userId=${session.user.id}`)
  ]);

  return {
    props: {
      user: session.user,
      initialData: {
        tasks: await tasks.json(),
        projects: await projects.json(),
        appointments: await appointments.json()
      }
    },
  };
};
```

#### **A.1.3 ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½**
```typescript
// src/components/mobile/layout/ModeSwitcher.tsx
import { useState } from 'react';
import { useRouter } from 'next/router';
import { Switch } from '@headlessui/react';
import { DevicePhoneMobileIcon, ComputerDesktopIcon } from '@heroicons/react/24/outline';

export default function ModeSwitcher() {
  const router = useRouter();
  const [isMobileMode, setIsMobileMode] = useState(true);

  const switchToDesktop = () => {
    // ç¾åœ¨ã®ãƒšãƒ¼ã‚¸ã«å¯¾å¿œã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãƒšãƒ¼ã‚¸ã«é·ç§»
    const desktopPath = convertMobilePathToDesktop(router.pathname);
    router.push(desktopPath);
  };

  const convertMobilePathToDesktop = (mobilePath: string): string => {
    const pathMapping: Record<string, string> = {
      '/mobile/dashboard': '/dashboard',
      '/mobile/tasks': '/tasks',
      '/mobile/projects': '/projects',
      '/mobile/calendar': '/calendar',
      '/mobile/knowledge': '/knowledge',
      '/mobile/connections': '/connections',
      '/mobile/appointments': '/appointments'
    };
    
    return pathMapping[mobilePath] || '/dashboard';
  };

  return (
    <div className="flex items-center space-x-3 p-3 bg-gray-50 rounded-lg">
      <DevicePhoneMobileIcon className="h-5 w-5 text-blue-600" />
      <span className="text-sm font-medium text-gray-700">ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰</span>
      
      <button
        onClick={switchToDesktop}
        className="flex items-center space-x-2 px-3 py-1 text-sm text-gray-600 hover:text-blue-600 transition-colors"
      >
        <ComputerDesktopIcon className="h-4 w-4" />
        <span>ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã¸</span>
      </button>
    </div>
  );
}
```

### **A.2 ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼åˆ¶å¾¡ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**

#### **A.2.1 Hammer.jsçµ±åˆ**
```typescript
// src/lib/mobile/gestureHandling.ts
import Hammer from 'hammerjs';

export interface GestureEvent {
  type: 'swipe' | 'tap' | 'press' | 'pinch';
  direction?: 'left' | 'right' | 'up' | 'down';
  target: HTMLElement;
  data: any;
}

export interface GestureAction {
  execute: (target: HTMLElement, data?: any) => Promise<void>;
  feedback: (target: HTMLElement) => void;
  validate?: (target: HTMLElement) => boolean;
}

export class MobileGestureHandler {
  private hammer: HammerManager;
  private actions: Map<string, GestureAction> = new Map();
  private isEnabled: boolean = true;

  constructor(element: HTMLElement) {
    this.hammer = new Hammer(element);
    this.setupGestures();
    this.setupDefaultActions();
  }

  private setupGestures() {
    // ã‚¹ãƒ¯ã‚¤ãƒ—ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼è¨­å®š
    this.hammer.get('swipe').set({
      direction: Hammer.DIRECTION_ALL,
      threshold: 10,
      velocity: 0.3
    });

    // ã‚¿ãƒƒãƒ—ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼è¨­å®š
    this.hammer.get('tap').set({
      taps: 1,
      threshold: 10
    });

    // é•·æŠ¼ã—ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼è¨­å®š
    this.hammer.get('press').set({
      time: 500,
      threshold: 10
    });

    // ãƒ”ãƒ³ãƒã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼è¨­å®š
    this.hammer.get('pinch').set({
      enable: true,
      threshold: 0.1
    });

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
    this.hammer.on('swiperight swipeleft swipeup swipedown', this.handleSwipe.bind(this));
    this.hammer.on('tap', this.handleTap.bind(this));
    this.hammer.on('press', this.handlePress.bind(this));
    this.hammer.on('pinch', this.handlePinch.bind(this));
  }

  private setupDefaultActions() {
    // å³ã‚¹ãƒ¯ã‚¤ãƒ—: å®Œäº†ãƒ»æ‰¿èª
    this.registerAction('swipe-right', {
      execute: async (target, data) => {
        const taskId = target.dataset.taskId;
        const projectId = target.dataset.projectId;
        
        if (taskId) {
          await this.completeTask(taskId);
        } else if (projectId) {
          await this.updateProjectStatus(projectId, 'completed');
        }
      },
      feedback: (target) => {
        this.showSuccessFeedback(target, 'âœ… å®Œäº†');
      },
      validate: (target) => {
        return !!(target.dataset.taskId || target.dataset.projectId);
      }
    });

    // å·¦ã‚¹ãƒ¯ã‚¤ãƒ—: å»¶æœŸãƒ»å´ä¸‹
    this.registerAction('swipe-left', {
      execute: async (target, data) => {
        const taskId = target.dataset.taskId;
        if (taskId) {
          await this.postponeTask(taskId);
        }
      },
      feedback: (target) => {
        this.showWarningFeedback(target, 'â° å»¶æœŸ');
      }
    });

    // ä¸Šã‚¹ãƒ¯ã‚¤ãƒ—: è©³ç´°ãƒ»ç·¨é›†
    this.registerAction('swipe-up', {
      execute: async (target, data) => {
        const itemId = target.dataset.taskId || target.dataset.projectId;
        if (itemId) {
          await this.openDetailView(itemId, target.dataset.type);
        }
      },
      feedback: (target) => {
        this.showInfoFeedback(target, 'ğŸ“ è©³ç´°');
      }
    });

    // ä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—: å‰Šé™¤ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    this.registerAction('swipe-down', {
      execute: async (target, data) => {
        const confirmDelete = await this.showConfirmDialog('å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ');
        if (confirmDelete) {
          const itemId = target.dataset.taskId || target.dataset.projectId;
          await this.deleteItem(itemId, target.dataset.type);
        }
      },
      feedback: (target) => {
        this.showDangerFeedback(target, 'ğŸ—‘ï¸ å‰Šé™¤');
      }
    });

    // é•·æŠ¼ã—: éŸ³å£°å…¥åŠ›ãƒ»è©³ç´°ãƒ¡ãƒ‹ãƒ¥ãƒ¼
    this.registerAction('press', {
      execute: async (target, data) => {
        if (target.dataset.allowVoice === 'true') {
          await this.startVoiceInput(target);
        } else {
          await this.showContextMenu(target);
        }
      },
      feedback: (target) => {
        this.showInfoFeedback(target, 'ğŸ¤ éŸ³å£°å…¥åŠ›');
      }
    });
  }

  public registerAction(gestureKey: string, action: GestureAction) {
    this.actions.set(gestureKey, action);
  }

  private async handleSwipe(event: HammerInput) {
    if (!this.isEnabled) return;

    const direction = this.getSwipeDirection(event.direction);
    const gestureKey = `swipe-${direction}`;
    const action = this.actions.get(gestureKey);

    if (action && (!action.validate || action.validate(event.target as HTMLElement))) {
      try {
        // è¦–è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
        action.feedback(event.target as HTMLElement);
        
        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        await action.execute(event.target as HTMLElement, event);
        
        // æˆåŠŸãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
        this.triggerHapticFeedback('success');
        
      } catch (error) {
        console.error('Gesture action error:', error);
        this.showErrorFeedback(event.target as HTMLElement, 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        this.triggerHapticFeedback('error');
      }
    }
  }

  private async handleTap(event: HammerInput) {
    // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—æ¤œå‡º
    if (event.tapCount === 2) {
      const action = this.actions.get('double-tap');
      if (action) {
        action.feedback(event.target as HTMLElement);
        await action.execute(event.target as HTMLElement, event);
      }
    }
  }

  private async handlePress(event: HammerInput) {
    const action = this.actions.get('press');
    if (action) {
      action.feedback(event.target as HTMLElement);
      await action.execute(event.target as HTMLElement, event);
    }
  }

  private async handlePinch(event: HammerInput) {
    const scale = event.scale;
    if (scale > 1.2) {
      // ãƒ”ãƒ³ãƒã‚¢ã‚¦ãƒˆ: è©³ç´°è¡¨ç¤º
      const action = this.actions.get('pinch-out');
      if (action) {
        await action.execute(event.target as HTMLElement, { scale });
      }
    } else if (scale < 0.8) {
      // ãƒ”ãƒ³ãƒã‚¤ãƒ³: è¦ç´„è¡¨ç¤º
      const action = this.actions.get('pinch-in');
      if (action) {
        await action.execute(event.target as HTMLElement, { scale });
      }
    }
  }

  private getSwipeDirection(hammerDirection: number): string {
    switch (hammerDirection) {
      case Hammer.DIRECTION_LEFT: return 'left';
      case Hammer.DIRECTION_RIGHT: return 'right';
      case Hammer.DIRECTION_UP: return 'up';
      case Hammer.DIRECTION_DOWN: return 'down';
      default: return 'unknown';
    }
  }

  // ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é–¢æ•°
  private showSuccessFeedback(target: HTMLElement, message: string) {
    this.createFeedbackElement(target, message, 'success');
  }

  private showWarningFeedback(target: HTMLElement, message: string) {
    this.createFeedbackElement(target, message, 'warning');
  }

  private showInfoFeedback(target: HTMLElement, message: string) {
    this.createFeedbackElement(target, message, 'info');
  }

  private showDangerFeedback(target: HTMLElement, message: string) {
    this.createFeedbackElement(target, message, 'danger');
  }

  private showErrorFeedback(target: HTMLElement, message: string) {
    this.createFeedbackElement(target, message, 'error');
  }

  private createFeedbackElement(target: HTMLElement, message: string, type: string) {
    const feedback = document.createElement('div');
    feedback.className = `gesture-feedback gesture-feedback-${type}`;
    feedback.textContent = message;
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¹ã‚¿ã‚¤ãƒ«
    feedback.style.position = 'absolute';
    feedback.style.zIndex = '9999';
    feedback.style.pointerEvents = 'none';
    feedback.style.fontSize = '14px';
    feedback.style.fontWeight = 'bold';
    feedback.style.padding = '4px 8px';
    feedback.style.borderRadius = '4px';
    feedback.style.whiteSpace = 'nowrap';
    
    // ã‚¿ã‚¤ãƒ—åˆ¥ã‚¹ã‚¿ã‚¤ãƒ«
    const styles = {
      success: { background: '#10b981', color: '#ffffff' },
      warning: { background: '#f59e0b', color: '#ffffff' },
      info: { background: '#3b82f6', color: '#ffffff' },
      danger: { background: '#ef4444', color: '#ffffff' },
      error: { background: '#dc2626', color: '#ffffff' }
    };
    
    const style = styles[type as keyof typeof styles] || styles.info;
    Object.assign(feedback.style, style);
    
    // ä½ç½®èª¿æ•´
    const rect = target.getBoundingClientRect();
    feedback.style.left = `${rect.left + rect.width / 2}px`;
    feedback.style.top = `${rect.top - 30}px`;
    feedback.style.transform = 'translateX(-50%)';
    
    document.body.appendChild(feedback);
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    feedback.animate([
      { opacity: 0, transform: 'translateX(-50%) translateY(10px)' },
      { opacity: 1, transform: 'translateX(-50%) translateY(0px)' },
      { opacity: 0, transform: 'translateX(-50%) translateY(-10px)' }
    ], {
      duration: 1500,
      easing: 'ease-out'
    }).addEventListener('finish', () => {
      document.body.removeChild(feedback);
    });
  }

  private triggerHapticFeedback(type: 'success' | 'warning' | 'error') {
    if ('vibrate' in navigator) {
      const patterns = {
        success: [50],
        warning: [100, 50, 100],
        error: [200, 100, 200]
      };
      navigator.vibrate(patterns[type]);
    }
  }

  // APIé€£æºãƒ¡ã‚½ãƒƒãƒ‰
  private async completeTask(taskId: string) {
    const response = await fetch(`/api/tasks/${taskId}/complete`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    if (!response.ok) {
      throw new Error('ã‚¿ã‚¹ã‚¯å®Œäº†ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°é€šçŸ¥
    this.notifyDataUpdate('task-completed', { taskId });
  }

  private async postponeTask(taskId: string) {
    const response = await fetch(`/api/tasks/${taskId}/postpone`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    if (!response.ok) {
      throw new Error('ã‚¿ã‚¹ã‚¯å»¶æœŸã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    this.notifyDataUpdate('task-postponed', { taskId });
  }

  private async deleteItem(itemId: string, type: string) {
    const response = await fetch(`/api/${type}s/${itemId}`, {
      method: 'DELETE'
    });
    
    if (!response.ok) {
      throw new Error('å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ');
    }
    
    this.notifyDataUpdate(`${type}-deleted`, { itemId });
  }

  private async openDetailView(itemId: string, type: string) {
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã¾ãŸã¯æ–°ã—ã„ãƒšãƒ¼ã‚¸ã§è©³ç´°è¡¨ç¤º
    window.location.href = `/mobile/${type}s/${itemId}`;
  }

  private async startVoiceInput(target: HTMLElement) {
    // éŸ³å£°å…¥åŠ›æ©Ÿèƒ½ï¼ˆPhase Bã§å®Ÿè£…ï¼‰
    console.log('Voice input will be implemented in Phase B');
  }

  private async showContextMenu(target: HTMLElement) {
    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºï¼ˆPhase Bã§å®Ÿè£…ï¼‰
    console.log('Context menu will be implemented in Phase B');
  }

  private async showConfirmDialog(message: string): Promise<boolean> {
    return new Promise((resolve) => {
      const confirmed = window.confirm(message);
      resolve(confirmed);
    });
  }

  private notifyDataUpdate(event: string, data: any) {
    // ãƒ‡ãƒ¼ã‚¿æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼ˆä»–ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«é€šçŸ¥ï¼‰
    window.dispatchEvent(new CustomEvent('mobileDataUpdate', {
      detail: { event, data }
    }));
  }

  public enable() {
    this.isEnabled = true;
  }

  public disable() {
    this.isEnabled = false;
  }

  public destroy() {
    this.hammer.destroy();
  }
}

// React Hook
export function useGestureHandler(elementRef: React.RefObject<HTMLElement>) {
  const [gestureHandler, setGestureHandler] = useState<MobileGestureHandler | null>(null);

  useEffect(() => {
    if (elementRef.current) {
      const handler = new MobileGestureHandler(elementRef.current);
      setGestureHandler(handler);

      return () => {
        handler.destroy();
      };
    }
  }, [elementRef]);

  return gestureHandler;
}
```

### **A.3 ãƒ‡ãƒ¼ã‚¿çµ±åˆãƒ»åŒæœŸã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**

#### **A.3.1 ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ**
```typescript
// src/lib/mobile/mobileSync.ts
import { useEffect, useState, useCallback } from 'react';

export interface SyncStatus {
  isOnline: boolean;
  lastSync: Date | null;
  pendingActions: number;
  syncInProgress: boolean;
}

export interface OfflineAction {
  id: string;
  type: string;
  data: any;
  timestamp: Date;
  retryCount: number;
}

export class MobileSyncManager {
  private ws: WebSocket | null = null;
  private eventSource: EventSource | null = null;
  private offline: boolean = false;
  private actionQueue: OfflineAction[] = [];
  private subscribers: Map<string, Function[]> = new Map();

  constructor() {
    this.setupNetworkDetection();
    this.setupWebSocket();
    this.setupEventSource();
    this.loadOfflineQueue();
  }

  private setupNetworkDetection() {
    window.addEventListener('online', () => {
      this.offline = false;
      this.processOfflineQueue();
      this.notifySubscribers('network', { online: true });
    });

    window.addEventListener('offline', () => {
      this.offline = true;
      this.notifySubscribers('network', { online: false });
    });

    // åˆæœŸçŠ¶æ…‹
    this.offline = !navigator.onLine;
  }

  private setupWebSocket() {
    if (typeof window === 'undefined') return;

    const wsUrl = process.env.NODE_ENV === 'production' 
      ? 'wss://your-domain.com/ws' 
      : 'ws://localhost:3000/ws';

    try {
      this.ws = new WebSocket(wsUrl);
      
      this.ws.onopen = () => {
        console.log('WebSocket connected');
        this.notifySubscribers('connection', { connected: true });
      };

      this.ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleRealtimeUpdate(data);
      };

      this.ws.onclose = () => {
        console.log('WebSocket disconnected');
        this.notifySubscribers('connection', { connected: false });
        
        // å†æ¥ç¶šè©¦è¡Œ
        setTimeout(() => this.setupWebSocket(), 5000);
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };
    } catch (error) {
      console.error('WebSocket setup error:', error);
    }
  }

  private setupEventSource() {
    if (typeof window === 'undefined') return;

    try {
      this.eventSource = new EventSource('/api/events');
      
      this.eventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        this.handleRealtimeUpdate(data);
      };

      this.eventSource.onerror = (error) => {
        console.error('EventSource error:', error);
      };
    } catch (error) {
      console.error('EventSource setup error:', error);
    }
  }

  private handleRealtimeUpdate(data: any) {
    // ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦é©åˆ‡ãªæ›´æ–°ã‚’å®Ÿè¡Œ
    switch (data.type) {
      case 'task-updated':
        this.notifySubscribers('task', data.payload);
        break;
      case 'project-updated':
        this.notifySubscribers('project', data.payload);
        break;
      case 'appointment-updated':
        this.notifySubscribers('appointment', data.payload);
        break;
      default:
        this.notifySubscribers('general', data);
    }
  }

  public async syncAction(action: Omit<OfflineAction, 'id' | 'timestamp' | 'retryCount'>) {
    const fullAction: OfflineAction = {
      id: this.generateActionId(),
      timestamp: new Date(),
      retryCount: 0,
      ...action
    };

    if (this.offline) {
      // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
      this.queueAction(fullAction);
      this.saveOfflineQueue();
      return { success: true, queued: true };
    } else {
      // ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ã¯å³åº§å®Ÿè¡Œ
      try {
        const result = await this.executeAction(fullAction);
        this.broadcastUpdate(fullAction.type, result);
        return { success: true, result };
      } catch (error) {
        // å¤±æ•—æ™‚ã¯ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã—ã¦å¾Œã§å†è©¦è¡Œ
        this.queueAction(fullAction);
        this.saveOfflineQueue();
        throw error;
      }
    }
  }

  private queueAction(action: OfflineAction) {
    this.actionQueue.push(action);
    this.notifySubscribers('queue', { 
      pending: this.actionQueue.length,
      action: action.type 
    });
  }

  private async processOfflineQueue() {
    if (this.actionQueue.length === 0) return;

    this.notifySubscribers('sync', { inProgress: true });

    const processPromises = this.actionQueue.map(async (action) => {
      try {
        const result = await this.executeAction(action);
        this.broadcastUpdate(action.type, result);
        return { success: true, action };
      } catch (error) {
        action.retryCount++;
        if (action.retryCount >= 3) {
          console.error('Action failed after 3 retries:', action, error);
          return { success: false, action, error };
        }
        return { success: false, action, retry: true };
      }
    });

    const results = await Promise.allSettled(processPromises);
    
    // æˆåŠŸã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ã€å¤±æ•—ã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯å†è©¦è¡Œã‚­ãƒ¥ãƒ¼ã«æ®‹ã™
    this.actionQueue = this.actionQueue.filter((action) => {
      const result = results.find(r => 
        r.status === 'fulfilled' && 
        (r.value as any).action?.id === action.id
      );
      return result ? !(result.value as any).success : true;
    });

    this.saveOfflineQueue();
    this.notifySubscribers('sync', { 
      inProgress: false,
      completed: results.filter(r => r.status === 'fulfilled').length
    });
  }

  private async executeAction(action: OfflineAction): Promise<any> {
    const { type, data } = action;
    
    let endpoint = '';
    let method = 'POST';
    
    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦APIå‘¼ã³å‡ºã—
    switch (type) {
      case 'task-complete':
        endpoint = `/api/tasks/${data.taskId}/complete`;
        break;
      case 'task-create':
        endpoint = '/api/tasks';
        break;
      case 'task-update':
        endpoint = `/api/tasks/${data.taskId}`;
        method = 'PUT';
        break;
      case 'project-update':
        endpoint = `/api/projects/${data.projectId}`;
        method = 'PUT';
        break;
      default:
        throw new Error(`Unknown action type: ${type}`);
    }

    const response = await fetch(endpoint, {
      method,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(data)
    });

    if (!response.ok) {
      throw new Error(`API call failed: ${response.status}`);
    }

    return await response.json();
  }

  private broadcastUpdate(type: string, data: any) {
    // WebSocketã§ä»–ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ›´æ–°ã‚’é€šçŸ¥
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({
        type: 'broadcast',
        actionType: type,
        data
      }));
    }
  }

  private loadOfflineQueue() {
    try {
      const stored = localStorage.getItem('mobileOfflineQueue');
      if (stored) {
        this.actionQueue = JSON.parse(stored).map((action: any) => ({
          ...action,
          timestamp: new Date(action.timestamp)
        }));
      }
    } catch (error) {
      console.error('Failed to load offline queue:', error);
      this.actionQueue = [];
    }
  }

  private saveOfflineQueue() {
    try {
      localStorage.setItem('mobileOfflineQueue', JSON.stringify(this.actionQueue));
    } catch (error) {
      console.error('Failed to save offline queue:', error);
    }
  }

  private generateActionId(): string {
    return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  public subscribe(event: string, callback: Function) {
    if (!this.subscribers.has(event)) {
      this.subscribers.set(event, []);
    }
    this.subscribers.get(event)!.push(callback);

    // è³¼èª­è§£é™¤é–¢æ•°ã‚’è¿”ã™
    return () => {
      const callbacks = this.subscribers.get(event);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    };
  }

  private notifySubscribers(event: string, data: any) {
    const callbacks = this.subscribers.get(event);
    if (callbacks) {
      callbacks.forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error('Subscriber callback error:', error);
        }
      });
    }
  }

  public getStatus(): SyncStatus {
    return {
      isOnline: !this.offline,
      lastSync: this.actionQueue.length === 0 ? new Date() : null,
      pendingActions: this.actionQueue.length,
      syncInProgress: false // TODO: å®Ÿéš›ã®åŒæœŸçŠ¶æ…‹ã‚’è¿½è·¡
    };
  }

  public destroy() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
    this.subscribers.clear();
  }
}

// React Hook
export function useMobileSync() {
  const [syncManager] = useState(() => new MobileSyncManager());
  const [status, setStatus] = useState<SyncStatus>(syncManager.getStatus());

  useEffect(() => {
    const unsubscribeNetwork = syncManager.subscribe('network', (data: any) => {
      setStatus(prev => ({ ...prev, isOnline: data.online }));
    });

    const unsubscribeQueue = syncManager.subscribe('queue', (data: any) => {
      setStatus(prev => ({ ...prev, pendingActions: data.pending }));
    });

    const unsubscribeSync = syncManager.subscribe('sync', (data: any) => {
      setStatus(prev => ({ ...prev, syncInProgress: data.inProgress }));
    });

    return () => {
      unsubscribeNetwork();
      unsubscribeQueue();
      unsubscribeSync();
      syncManager.destroy();
    };
  }, [syncManager]);

  const syncAction = useCallback(async (action: Omit<OfflineAction, 'id' | 'timestamp' | 'retryCount'>) => {
    return await syncManager.syncAction(action);
  }, [syncManager]);

  return {
    isOnline: status.isOnline,
    lastSync: status.lastSync,
    pendingActions: status.pendingActions,
    syncInProgress: status.syncInProgress,
    syncAction
  };
}
```

### **A.4 PWAãƒ»ã‚ªãƒ•ãƒ©ã‚¤ãƒ³åŸºç›¤å®Ÿè£…**

#### **A.4.1 PWAè¨­å®š**
```json
// public/manifest.json
{
  "name": "FIND to DO Mobile",
  "short_name": "FTD Mobile",
  "description": "é©æ–°çš„ã‚¿ã‚¹ã‚¯ç®¡ç† - ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰",
  "start_url": "/mobile/dashboard",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2563eb",
  "orientation": "portrait",
  "scope": "/mobile/",
  "categories": ["productivity", "business"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "æ–°ã—ã„ã‚¿ã‚¹ã‚¯",
      "short_name": "ã‚¿ã‚¹ã‚¯è¿½åŠ ",
      "description": "æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’ç´ æ—©ãè¿½åŠ ",
      "url": "/mobile/quick-add?type=task",
      "icons": [{ "src": "/icons/shortcut-task.png", "sizes": "96x96" }]
    },
    {
      "name": "ä»Šæ—¥ã®äºˆå®š",
      "short_name": "ä»Šæ—¥",
      "description": "ä»Šæ—¥ã®äºˆå®šã‚’ç¢ºèª",
      "url": "/mobile/dashboard?view=today",
      "icons": [{ "src": "/icons/shortcut-today.png", "sizes": "96x96" }]
    }
  ]
}
```

#### **A.4.2 Service Workerå®Ÿè£…**
```typescript
// public/sw.js
const CACHE_NAME = 'ftd-mobile-v1';
const urlsToCache = [
  '/mobile/dashboard',
  '/mobile/tasks',
  '/mobile/quick-add',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/icons/icon-192x192.png',
  '/manifest.json'
];

// ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ™‚
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
      .then(() => self.skipWaiting())
  );
});

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ™ãƒ¼ãƒˆæ™‚
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => self.clients.claim())
  );
});

// ãƒ•ã‚§ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // API ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å‡¦ç†
  if (request.url.includes('/api/')) {
    event.respondWith(
      fetch(request)
        .then((response) => {
          // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
          if (response.status === 200) {
            const responseClone = response.clone();
            caches.open('api-cache').then((cache) => {
              cache.put(request, responseClone);
            });
          }
          return response;
        })
        .catch(() => {
          // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰è¿”ã™
          return caches.match(request);
        })
    );
    return;
  }

  // é™çš„ãƒªã‚½ãƒ¼ã‚¹ã®å‡¦ç†
  event.respondWith(
    caches.match(request)
      .then((response) => {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚Œã°è¿”ã™
        if (response) {
          return response;
        }
        
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰å–å¾—ã—ã¦ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        return fetch(request).then((response) => {
          if (!response || response.status !== 200 || response.type !== 'basic') {
            return response;
          }

          const responseToCache = response.clone();
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(request, responseToCache);
          });

          return response;
        });
      })
  );
});

// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰åŒæœŸ
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync());
  }
});

// ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'FIND to DOã‹ã‚‰æ–°ã—ã„é€šçŸ¥ãŒã‚ã‚Šã¾ã™',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [200, 100, 200],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    }
  };

  event.waitUntil(
    self.registration.showNotification('FIND to DO', options)
  );
});

// é€šçŸ¥ã‚¯ãƒªãƒƒã‚¯
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  event.waitUntil(
    clients.openWindow('/mobile/dashboard')
  );
});

async function doBackgroundSync() {
  try {
    const offlineQueue = await getOfflineQueue();
    for (const action of offlineQueue) {
      await retryAction(action);
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

async function getOfflineQueue() {
  // IndexedDBã‹ã‚‰ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ“ä½œã‚­ãƒ¥ãƒ¼ã‚’å–å¾—
  return [];
}

async function retryAction(action) {
  // å¤±æ•—ã—ãŸæ“ä½œã‚’å†è©¦è¡Œ
  return fetch(action.url, action.options);
}
```

---

## ğŸ§ª **Phase A ãƒ†ã‚¹ãƒˆè¨ˆç”»**

### **A.1 å˜ä½“ãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/mobile/GestureHandler.test.ts
import { MobileGestureHandler } from '../../src/lib/mobile/gestureHandling';

describe('MobileGestureHandler', () => {
  let mockElement: HTMLElement;
  let gestureHandler: MobileGestureHandler;

  beforeEach(() => {
    mockElement = document.createElement('div');
    gestureHandler = new MobileGestureHandler(mockElement);
  });

  afterEach(() => {
    gestureHandler.destroy();
  });

  test('should register default gestures', () => {
    expect(gestureHandler).toBeDefined();
  });

  test('should handle swipe right gesture', async () => {
    const mockTask = document.createElement('div');
    mockTask.dataset.taskId = 'test-task-1';
    
    // Mock API response
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      })
    ) as jest.Mock;

    await gestureHandler.handleSwipe({
      direction: 2, // Hammer.DIRECTION_RIGHT
      target: mockTask
    } as any);

    expect(fetch).toHaveBeenCalledWith('/api/tasks/test-task-1/complete', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
  });
});

// __tests__/mobile/MobileSync.test.ts
import { MobileSyncManager } from '../../src/lib/mobile/mobileSync';

describe('MobileSyncManager', () => {
  let syncManager: MobileSyncManager;

  beforeEach(() => {
    syncManager = new MobileSyncManager();
  });

  afterEach(() => {
    syncManager.destroy();
  });

  test('should queue actions when offline', async () => {
    // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: false
    });

    const action = {
      type: 'task-complete',
      data: { taskId: 'test-task' }
    };

    const result = await syncManager.syncAction(action);
    
    expect(result.queued).toBe(true);
    expect(syncManager.getStatus().pendingActions).toBe(1);
  });

  test('should execute actions when online', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      })
    ) as jest.Mock;

    const action = {
      type: 'task-complete',
      data: { taskId: 'test-task' }
    };

    const result = await syncManager.syncAction(action);
    
    expect(result.success).toBe(true);
    expect(fetch).toHaveBeenCalled();
  });
});
```

### **A.2 çµ±åˆãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/integration/MobilePhaseA.test.ts
import { render, screen } from '@testing-library/react';
import { useRouter } from 'next/router';
import MobileDashboard from '../../src/pages/mobile/dashboard';

// Mock Next.js router
jest.mock('next/router', () => ({
  useRouter: jest.fn()
}));

describe('Mobile Phase A Integration', () => {
  const mockUser = {
    id: 'test-user',
    name: 'Test User',
    email: 'test@example.com'
  };

  const mockInitialData = {
    tasks: [],
    projects: [],
    appointments: []
  };

  beforeEach(() => {
    (useRouter as jest.Mock).mockReturnValue({
      pathname: '/mobile/dashboard',
      push: jest.fn()
    });
  });

  test('should render mobile dashboard', () => {
    render(
      <MobileDashboard 
        user={mockUser} 
        initialData={mockInitialData} 
      />
    );

    expect(screen.getByText('ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰')).toBeInTheDocument();
  });

  test('should handle mode switching', () => {
    const mockPush = jest.fn();
    (useRouter as jest.Mock).mockReturnValue({
      pathname: '/mobile/dashboard',
      push: mockPush
    });

    render(
      <MobileDashboard 
        user={mockUser} 
        initialData={mockInitialData} 
      />
    );

    const desktopButton = screen.getByText('ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç‰ˆã¸');
    desktopButton.click();

    expect(mockPush).toHaveBeenCalledWith('/dashboard');
  });
});
```

---

## ğŸ“Š **Phase A æˆåŠŸæŒ‡æ¨™**

### **A.1 å®šé‡æŒ‡æ¨™**
- [ ] **ãƒ¢ãƒã‚¤ãƒ«ãƒšãƒ¼ã‚¸ä½œæˆ**: 4ã¤ã®åŸºæœ¬ãƒšãƒ¼ã‚¸ä½œæˆå®Œäº†
- [ ] **ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼èªè­˜**: 8ã¤ã®åŸºæœ¬ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼èªè­˜æˆåŠŸç‡ 95%
- [ ] **PWAã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«**: æ­£å¸¸ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¯èƒ½
- [ ] **ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å‹•ä½œ**: åŸºæœ¬æ©Ÿèƒ½ãŒã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§å‹•ä½œ
- [ ] **API ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“**: < 800msï¼ˆãƒ¢ãƒã‚¤ãƒ«ç’°å¢ƒè€ƒæ…®ï¼‰

### **A.2 æ©Ÿèƒ½æŒ‡æ¨™**
- [ ] **ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ**: ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—â†”ãƒ¢ãƒã‚¤ãƒ«åˆ‡ã‚Šæ›¿ãˆæ­£å¸¸å‹•ä½œ
- [ ] **ãƒ‡ãƒ¼ã‚¿åŒæœŸ**: æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¨ã®å®Œå…¨åŒæœŸ
- [ ] **ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼å‹•ä½œ**: ã‚¹ãƒ¯ã‚¤ãƒ—ã§ã‚¿ã‚¹ã‚¯å®Œäº†ãƒ»å»¶æœŸãŒå‹•ä½œ
- [ ] **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°**: WebSocket/SSEã§ã®å³åº§åæ˜ 

### **A.3 é‹ç”¨æŒ‡æ¨™**
- [ ] **æ—¢å­˜æ©Ÿèƒ½**: 100%å‹•ä½œç¶­æŒï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ï¼‰
- [ ] **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§**: ãƒ¢ãƒã‚¤ãƒ«â†”ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—é–“ã§ãƒ‡ãƒ¼ã‚¿æ•´åˆ
- [ ] **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: æ—¢å­˜èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨çµ±åˆ

---

## âš ï¸ **Phase A æ³¨æ„äº‹é …ãƒ»åˆ¶ç´„**

### **A.1 æŠ€è¡“åˆ¶ç´„**
- æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¨ã®å®Œå…¨äº’æ›æ€§å¿…é ˆ
- ãƒ¢ãƒã‚¤ãƒ«å°‚ç”¨ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ã¿è¿½åŠ ï¼ˆæ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´æœ€å°é™ï¼‰
- æ—¢å­˜APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æ´»ç”¨å„ªå…ˆ

### **A.2 UI/UXåˆ¶ç´„**
- ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼æ“ä½œã®å­¦ç¿’ã‚³ã‚¹ãƒˆæœ€å°åŒ–
- æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ··ä¹±é˜²æ­¢
- ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£åŸºæº–éµå®ˆ

### **A.3 é‹ç”¨åˆ¶ç´„**
- æ®µéšçš„å±•é–‹ï¼ˆå¼·åˆ¶ç§»è¡Œãªã—ï¼‰
- ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ãƒ¢ãƒ¼ãƒ‰ã¨ã®ä¸¦è¡Œé‹ç”¨
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œã«ã‚ˆã‚‹ä¸€æ™‚çš„ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆã®è¨±å®¹

---

## ğŸš€ **Phase A å®Œäº†åŸºæº–**

### **A.1 æ©Ÿèƒ½å®Œäº†åŸºæº–**
1. **ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰åŸºç›¤å®Œäº†**
   - [ ] `/mobile/` ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°å‹•ä½œ
   - [ ] ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½å‹•ä½œ
   - [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿è¡¨ç¤ºå‹•ä½œ

2. **ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚·ã‚¹ãƒ†ãƒ å®Œäº†**
   - [ ] 8ã¤ã®åŸºæœ¬ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼èªè­˜
   - [ ] ã‚¿ã‚¹ã‚¯æ“ä½œï¼ˆå®Œäº†ãƒ»å»¶æœŸãƒ»å‰Šé™¤ï¼‰å‹•ä½œ
   - [ ] è¦–è¦šãƒ»è§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å‹•ä½œ

3. **åŒæœŸã‚·ã‚¹ãƒ†ãƒ å®Œäº†**
   - [ ] ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
   - [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚°å‹•ä½œ
   - [ ] ç«¶åˆè§£æ±ºæ©Ÿèƒ½å‹•ä½œ

### **A.2 å“è³ªå®Œäº†åŸºæº–**
- [ ] å…¨ãƒ†ã‚¹ãƒˆé€šéï¼ˆå˜ä½“ãƒ»çµ±åˆï¼‰
- [ ] ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ç¢ºèª
- [ ] PWAã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ»å‹•ä½œç¢ºèª
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯å®Œäº†

### **A.3 é‹ç”¨å®Œäº†åŸºæº–**
- [ ] æœ¬ç•ªç’°å¢ƒãƒ‡ãƒ—ãƒ­ã‚¤æˆåŠŸ
- [ ] PWAã‚¢ãƒ—ãƒªã‚¹ãƒˆã‚¢ç”³è«‹æº–å‚™å®Œäº†
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰ä½œæˆå®Œäº†
- [ ] ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ç¢ºèªå®Œäº†

---

**æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: Phase A å®Ÿè£…é–‹å§‹ã€‚ã“ã®åŸºç›¤ã‚’ç¢ºå®Ÿã«æ§‹ç¯‰ã™ã‚‹ã“ã¨ã§ã€Phase Bãƒ»Cã§ã®é©æ–°çš„æ©Ÿèƒ½å®Ÿè£…ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚