# ãƒ¢ãƒã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰ Phase B: é«˜åº¦æ©Ÿèƒ½ å®Ÿè£…è¨ˆç”»æ›¸

**ãƒ•ã‚§ãƒ¼ã‚ºæœŸé–“**: 2æ—¥é–“  
**å®Ÿè£…æ—¥**: 2025å¹´7æœˆ1æ—¥ ã€œ 2025å¹´7æœˆ2æ—¥  
**æ‹…å½“ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**: AIãƒ»éŸ³å£°å‡¦ç†æ‹…å½“  
**å‰ææ¡ä»¶**: Phase Aå®Œäº†ã€éŸ³å£°å‡¦ç†ãƒ»AIçµ±åˆã®çµŒé¨“ã‚’æœ‰ã™ã‚‹

---

## ğŸ¯ **Phase B å®Ÿè£…ç›®æ¨™**

### **B.1 ä¸»è¦æ©Ÿèƒ½å®Ÿè£…**
- **éŸ³å£°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**: éŸ³å£°å…¥åŠ›ãƒ»å‡ºåŠ›ãƒ»è‡ªç„¶è¨€èªå‡¦ç†çµ±åˆ
- **AIäºˆæ¸¬UI**: ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•äºˆæ¸¬ãƒ»è‡ªå‹•ç”»é¢å¤‰æ›´ãƒ»ã‚¼ãƒ­ã‚¯ãƒªãƒƒã‚¯æ“ä½œ
- **LINE Botå¼·åŒ–**: æ„Ÿæƒ…èªè­˜ãƒ»ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ©Ÿèƒ½ãƒ»é«˜åº¦è‡ªç„¶è¨€èªç†è§£
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: è¦–è¦šãƒ»è´è¦šãƒ»é‹å‹•éšœå®³å¯¾å¿œãƒ»å¤šè¨€èªã‚µãƒãƒ¼ãƒˆ

### **B.2 æŠ€è¡“è¦ä»¶**
- Google Gemini APIæ´»ç”¨ãƒ»æ—¢å­˜AIæ©Ÿèƒ½æ‹¡å¼µ
- Web Speech APIãƒ»éŸ³å£°åˆæˆæŠ€è¡“çµ±åˆ
- æ©Ÿæ¢°å­¦ç¿’ã«ã‚ˆã‚‹è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ„Ÿæƒ…ãƒ»çŠ¶æ³èªè­˜

---

## ğŸ“‹ **Phase B å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ**

### **B.1 éŸ³å£°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£… (0.7æ—¥)**
- [ ] Web Speech APIçµ±åˆãƒ»éŸ³å£°èªè­˜ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…
- [ ] è‡ªç„¶è¨€èªå‡¦ç†ãƒ»æ„å›³æŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…
- [ ] éŸ³å£°åˆæˆãƒ»å¤šè¨€èªå¯¾å¿œå®Ÿè£…
- [ ] ãƒã‚¤ã‚ºã‚­ãƒ£ãƒ³ã‚»ãƒªãƒ³ã‚°ãƒ»éŸ³å£°å“è³ªå‘ä¸Š

### **B.2 AIäºˆæ¸¬ãƒ»è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ  (0.8æ—¥)**
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•å­¦ç¿’ã‚¨ãƒ³ã‚¸ãƒ³å®Ÿè£…
- [ ] ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ¤å®šãƒ»ç”»é¢è‡ªå‹•å¤‰æ›´å®Ÿè£…
- [ ] ãƒ—ãƒªãƒ‡ã‚£ã‚¯ãƒ†ã‚£ãƒ–UIãƒ»å…ˆå›ã‚Šæ©Ÿèƒ½å®Ÿè£…
- [ ] ã‚¼ãƒ­ã‚¯ãƒªãƒƒã‚¯è‡ªå‹•åŒ–ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£…

### **B.3 LINE Botè¶…çŸ¥èƒ½åŒ– (0.3æ—¥)**
- [ ] æ—¢å­˜LINE Botæ©Ÿèƒ½æ‹¡å¼µãƒ»æ„Ÿæƒ…èªè­˜è¿½åŠ 
- [ ] ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°å®Ÿè£…
- [ ] é«˜åº¦è‡ªç„¶è¨€èªç†è§£ãƒ»æ–‡è„ˆæŠŠæ¡å¼·åŒ–
- [ ] ã‚°ãƒ«ãƒ¼ãƒ—ãƒãƒ£ãƒƒãƒˆå¯¾å¿œãƒ»ãƒãƒ«ãƒãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†

### **B.4 ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ãƒ»å¤šè¨€èªå¯¾å¿œ (0.2æ—¥)**
- [ ] ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ãƒªãƒ¼ãƒ€ãƒ¼å¯¾å¿œãƒ»ARIAå±æ€§å®Ÿè£…
- [ ] éŸ³å£°ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ãƒ»ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œå¯¾å¿œ
- [ ] å¤§æ–‡å­—è¡¨ç¤ºãƒ»é«˜ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰å®Ÿè£…
- [ ] æ—¥æœ¬èªãƒ»è‹±èªå®Œå…¨å¯¾å¿œãƒ»éŸ³å£°å¤šè¨€èªåŒ–

---

## ğŸ”§ **è©³ç´°å®Ÿè£…ã‚¬ã‚¤ãƒ‰**

### **B.1 éŸ³å£°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Ÿè£…**

#### **B.1.1 éŸ³å£°èªè­˜ãƒ»å‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ³**
```typescript
// src/lib/mobile/voiceProcessing.ts
import { useEffect, useState, useRef } from 'react';

export interface VoiceCommand {
  intent: string;
  entities: Record<string, any>;
  confidence: number;
  rawText: string;
  context?: string;
}

export interface VoiceResponse {
  text: string;
  emotion: 'friendly' | 'encouraging' | 'informative' | 'celebratory';
  action?: {
    type: string;
    data: any;
  };
}

export class VoiceProcessor {
  private recognition: SpeechRecognition | null = null;
  private synthesis: SpeechSynthesis;
  private isListening: boolean = false;
  private geminiAPI: any; // Gemini API instance
  private userContext: any = {};
  private conversationHistory: any[] = [];

  constructor() {
    this.initializeSpeechRecognition();
    this.synthesis = window.speechSynthesis;
    this.geminiAPI = window.AI_SERVICE; // æ—¢å­˜ã®AIã‚µãƒ¼ãƒ“ã‚¹æ´»ç”¨
  }

  private initializeSpeechRecognition() {
    if ('webkitSpeechRecognition' in window) {
      this.recognition = new (window as any).webkitSpeechRecognition();
    } else if ('SpeechRecognition' in window) {
      this.recognition = new SpeechRecognition();
    }

    if (this.recognition) {
      this.recognition.continuous = false;
      this.recognition.interimResults = true;
      this.recognition.lang = 'ja-JP';
      this.recognition.maxAlternatives = 3;

      this.recognition.onstart = () => {
        this.isListening = true;
        this.onListeningStateChange?.(true);
      };

      this.recognition.onend = () => {
        this.isListening = false;
        this.onListeningStateChange?.(false);
      };

      this.recognition.onresult = (event) => {
        const results = Array.from(event.results);
        const finalResult = results[results.length - 1];
        
        if (finalResult.isFinal) {
          const transcript = finalResult[0].transcript;
          this.processVoiceInput(transcript);
        } else {
          // ä¸­é–“çµæœã®å‡¦ç†
          const interimTranscript = finalResult[0].transcript;
          this.onInterimResult?.(interimTranscript);
        }
      };

      this.recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        this.onError?.(event.error);
        this.isListening = false;
        this.onListeningStateChange?.(false);
      };
    }
  }

  public async startListening(): Promise<void> {
    if (!this.recognition) {
      throw new Error('Speech recognition not supported');
    }

    if (this.isListening) {
      this.stopListening();
      return;
    }

    try {
      // ãƒã‚¤ã‚¯ãƒ­ãƒ•ã‚©ãƒ³è¨±å¯ç¢ºèª
      await navigator.mediaDevices.getUserMedia({ audio: true });
      this.recognition.start();
    } catch (error) {
      console.error('Microphone access denied:', error);
      throw error;
    }
  }

  public stopListening(): void {
    if (this.recognition && this.isListening) {
      this.recognition.stop();
    }
  }

  private async processVoiceInput(transcript: string): Promise<void> {
    try {
      // éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆã‚’è‡ªç„¶è¨€èªå‡¦ç†
      const command = await this.parseVoiceCommand(transcript);
      
      // ä¼šè©±å±¥æ­´ã«è¿½åŠ 
      this.conversationHistory.push({
        type: 'user',
        text: transcript,
        timestamp: new Date(),
        command
      });

      // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
      if (command.intent !== 'unknown') {
        const response = await this.executeVoiceCommand(command);
        
        // éŸ³å£°ã§å¿œç­”
        await this.speakResponse(response);
        
        // ä¼šè©±å±¥æ­´ã«å¿œç­”è¿½åŠ 
        this.conversationHistory.push({
          type: 'assistant',
          text: response.text,
          timestamp: new Date(),
          emotion: response.emotion
        });

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
        if (response.action) {
          await this.executeAction(response.action);
        }
      } else {
        // ç†è§£ã§ããªã„å ´åˆã®å¿œç­”
        await this.speakResponse({
          text: 'ã™ã¿ã¾ã›ã‚“ã€ã‚ˆãèã“ãˆã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠé¡˜ã„ã—ã¾ã™ã€‚',
          emotion: 'friendly'
        });
      }

    } catch (error) {
      console.error('Voice processing error:', error);
      await this.speakResponse({
        text: 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        emotion: 'friendly'
      });
    }
  }

  private async parseVoiceCommand(transcript: string): Promise<VoiceCommand> {
    // ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’å–å¾—
    const currentContext = await this.getCurrentContext();
    
    // Gemini APIã§æ„å›³è§£æ
    const analysisPrompt = `
    éŸ³å£°ã‚³ãƒãƒ³ãƒ‰è§£æ:
    
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™ºè¨€: "${transcript}"
    
    ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:
    - ç”»é¢: ${currentContext.currentPage}
    - æ™‚åˆ»: ${new Date().toLocaleString('ja-JP')}
    - æœ€è¿‘ã®æ“ä½œ: ${currentContext.recentActions?.slice(-3).join(', ') || 'ãªã—'}
    - ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚¹ã‚¯æ•°: ${currentContext.activeTasks || 0}
    - ä»Šæ—¥ã®äºˆå®šæ•°: ${currentContext.todayAppointments || 0}
    
    éå»ã®ä¼šè©±å±¥æ­´:
    ${this.conversationHistory.slice(-5).map(h => `${h.type}: ${h.text}`).join('\n')}
    
    ä»¥ä¸‹ã®æ„å›³ã‹ã‚‰æœ€ã‚‚é©åˆ‡ãªã‚‚ã®ã‚’åˆ¤å®šã—ã€ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’æŠ½å‡ºã—ã¦ãã ã•ã„:
    
    1. TASK_CREATE - æ–°ã—ã„ã‚¿ã‚¹ã‚¯ä½œæˆ
       ä¾‹: "æ˜æ—¥ã¾ã§ã«ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ", "ä¼šè­°è³‡æ–™æº–å‚™ã®ã‚¿ã‚¹ã‚¯è¿½åŠ "
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: title, deadline, priority, assignee
    
    2. TASK_UPDATE - ã‚¿ã‚¹ã‚¯çŠ¶æ…‹æ›´æ–°
       ä¾‹: "ã“ã®ã‚¿ã‚¹ã‚¯å®Œäº†", "é€²è¡Œä¸­ã«å¤‰æ›´", "å„ªå…ˆåº¦ã‚’é«˜ã«"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: taskId, status, property, value
    
    3. SCHEDULE_CREATE - äºˆå®šä½œæˆ
       ä¾‹: "æ˜æ—¥10æ™‚ã«ä¼šè­°", "æ¥é€±ç«æ›œæ—¥ã«ãƒŸãƒ¼ãƒ†ã‚£ãƒ³ã‚°"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: title, datetime, duration, attendees
    
    4. INFORMATION_REQUEST - æƒ…å ±ç¢ºèª
       ä¾‹: "ä»Šæ—¥ã®äºˆå®šã¯ï¼Ÿ", "é€²æ—çŠ¶æ³æ•™ãˆã¦", "æ˜æ—¥ã®ç· åˆ‡ã¯ï¼Ÿ"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: type, timeframe, filter
    
    5. NAVIGATION - ç”»é¢é·ç§»
       ä¾‹: "ã‚¿ã‚¹ã‚¯ä¸€è¦§è¦‹ã›ã¦", "ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç”»é¢ã«ç§»å‹•"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: destination, filter
    
    6. REMINDER_SET - ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼è¨­å®š
       ä¾‹: "30åˆ†å¾Œã«ã‚¢ãƒ©ãƒ¼ãƒ ", "æ˜æ—¥ã®æœã«é€šçŸ¥"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: datetime, message
    
    7. SEARCH - æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿
       ä¾‹: "é‡è¦ãªã‚¿ã‚¹ã‚¯ã ã‘è¡¨ç¤º", "ç”°ä¸­ã•ã‚“ã®ä½œæ¥­æ¤œç´¢"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: query, filter, scope
    
    8. HELP - ãƒ˜ãƒ«ãƒ—ãƒ»èª¬æ˜è¦æ±‚
       ä¾‹: "ä½¿ã„æ–¹æ•™ãˆã¦", "ã“ã®æ©Ÿèƒ½ã¯ä½•ï¼Ÿ"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: topic, context
    
    9. CASUAL_CONVERSATION - é›‘è«‡ãƒ»æ„Ÿæƒ…è¡¨ç¾
       ä¾‹: "ç–²ã‚ŒãŸ", "é ‘å¼µã£ã¦ã‚‹", "ã‚ã‚ŠãŒã¨ã†"
       ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£: emotion, context
    
    10. UNKNOWN - ç†è§£ã§ããªã„ãƒ»ä¸æ˜ç¢º
    
    JSONå½¢å¼ã§å›ç­”:
    {
      "intent": "TASK_CREATE",
      "entities": {
        "title": "ãƒ¬ãƒãƒ¼ãƒˆä½œæˆ",
        "deadline": "2025-07-02",
        "priority": "medium"
      },
      "confidence": 0.95,
      "rawText": "${transcript}",
      "context": "task_management"
    }
    `;

    try {
      const result = await this.geminiAPI.evaluateWithGemini(analysisPrompt);
      return JSON.parse(result);
    } catch (error) {
      console.error('Voice command parsing error:', error);
      return {
        intent: 'unknown',
        entities: {},
        confidence: 0,
        rawText: transcript
      };
    }
  }

  private async executeVoiceCommand(command: VoiceCommand): Promise<VoiceResponse> {
    switch (command.intent) {
      case 'TASK_CREATE':
        return await this.handleTaskCreation(command);
      
      case 'TASK_UPDATE':
        return await this.handleTaskUpdate(command);
      
      case 'SCHEDULE_CREATE':
        return await this.handleScheduleCreation(command);
      
      case 'INFORMATION_REQUEST':
        return await this.handleInformationRequest(command);
      
      case 'NAVIGATION':
        return await this.handleNavigation(command);
      
      case 'REMINDER_SET':
        return await this.handleReminderSet(command);
      
      case 'SEARCH':
        return await this.handleSearch(command);
      
      case 'HELP':
        return await this.handleHelp(command);
      
      case 'CASUAL_CONVERSATION':
        return await this.handleCasualConversation(command);
      
      default:
        return {
          text: 'ã™ã¿ã¾ã›ã‚“ã€ã‚ˆãç†è§£ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†å°‘ã—å…·ä½“çš„ã«ãŠè©±ã—ãã ã•ã„ã€‚',
          emotion: 'friendly'
        };
    }
  }

  private async handleTaskCreation(command: VoiceCommand): Promise<VoiceResponse> {
    const { entities } = command;
    
    try {
      // ã‚¿ã‚¹ã‚¯ä½œæˆAPIå‘¼ã³å‡ºã—
      const response = await fetch('/api/tasks', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title: entities.title,
          deadline: entities.deadline,
          priority: entities.priority || 'medium',
          assignedTo: entities.assignee,
          createdBy: 'voice-command'
        })
      });

      if (response.ok) {
        const task = await response.json();
        return {
          text: `ã€Œ${entities.title}ã€ã®ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆã—ã¾ã—ãŸã€‚${entities.deadline ? `æœŸé™ã¯${new Date(entities.deadline).toLocaleDateString('ja-JP')}ã§ã™ã€‚` : ''}é ‘å¼µã£ã¦ãã ã•ã„ï¼`,
          emotion: 'encouraging',
          action: {
            type: 'REFRESH_TASKS',
            data: { newTaskId: task.id }
          }
        };
      } else {
        throw new Error('ã‚¿ã‚¹ã‚¯ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (error) {
      return {
        text: 'ã‚¿ã‚¹ã‚¯ã®ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        emotion: 'friendly'
      };
    }
  }

  private async handleTaskUpdate(command: VoiceCommand): Promise<VoiceResponse> {
    const { entities } = command;
    
    try {
      // ç¾åœ¨é¸æŠä¸­ã®ã‚¿ã‚¹ã‚¯IDã‚’å–å¾—
      const taskId = entities.taskId || await this.getCurrentTaskId();
      
      if (!taskId) {
        return {
          text: 'æ›´æ–°ã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
          emotion: 'friendly'
        };
      }

      const updateData: any = {};
      
      if (entities.status) {
        updateData.status = entities.status;
      }
      
      if (entities.property && entities.value) {
        updateData[entities.property] = entities.value;
      }

      const response = await fetch(`/api/tasks/${taskId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updateData)
      });

      if (response.ok) {
        const responseMessages = {
          completed: 'ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã—ã¾ã—ãŸï¼ãŠç–²ã‚Œã•ã¾ã§ã—ãŸï¼',
          in_progress: 'ã‚¿ã‚¹ã‚¯ã‚’é€²è¡Œä¸­ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚é ‘å¼µã£ã¦ãã ã•ã„ï¼',
          pending: 'ã‚¿ã‚¹ã‚¯ã‚’ä¿ç•™ä¸­ã«å¤‰æ›´ã—ã¾ã—ãŸã€‚',
          deleted: 'ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚'
        };

        return {
          text: responseMessages[entities.status as keyof typeof responseMessages] || 'ã‚¿ã‚¹ã‚¯ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚',
          emotion: entities.status === 'completed' ? 'celebratory' : 'encouraging',
          action: {
            type: 'REFRESH_TASKS',
            data: { updatedTaskId: taskId }
          }
        };
      } else {
        throw new Error('ã‚¿ã‚¹ã‚¯æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ');
      }
    } catch (error) {
      return {
        text: 'ã‚¿ã‚¹ã‚¯ã®æ›´æ–°ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        emotion: 'friendly'
      };
    }
  }

  private async handleInformationRequest(command: VoiceCommand): Promise<VoiceResponse> {
    const { entities } = command;
    
    try {
      let response: Response;
      let data: any;
      
      switch (entities.type) {
        case 'today_schedule':
          response = await fetch(`/api/appointments?date=${new Date().toISOString().split('T')[0]}`);
          data = await response.json();
          
          if (data.length === 0) {
            return {
              text: 'ä»Šæ—¥ã®äºˆå®šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãŠç–²ã‚Œã•ã¾ã§ã™ï¼',
              emotion: 'friendly'
            };
          }
          
          const scheduleText = data.map((apt: any) => 
            `${new Date(apt.date).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' })}ã‹ã‚‰${apt.title}`
          ).join(', ');
          
          return {
            text: `ä»Šæ—¥ã®äºˆå®šã¯ã€${scheduleText}ã§ã™ã€‚`,
            emotion: 'informative'
          };
        
        case 'task_progress':
          response = await fetch('/api/tasks?status=in_progress');
          data = await response.json();
          
          return {
            text: `ç¾åœ¨é€²è¡Œä¸­ã®ã‚¿ã‚¹ã‚¯ã¯${data.length}ä»¶ã§ã™ã€‚${data.length > 0 ? 'é ‘å¼µã£ã¦ãã ã•ã„ï¼' : 'æ–°ã—ã„ã‚¿ã‚¹ã‚¯ã‚’å§‹ã‚ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ'}`,
            emotion: 'encouraging'
          };
        
        case 'deadlines':
          const tomorrow = new Date();
          tomorrow.setDate(tomorrow.getDate() + 1);
          
          response = await fetch(`/api/tasks?deadline_before=${tomorrow.toISOString()}`);
          data = await response.json();
          
          if (data.length === 0) {
            return {
              text: 'æ˜æ—¥ã®ç· åˆ‡ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä½™è£•ãŒã‚ã‚Šã¾ã™ã­ï¼',
              emotion: 'friendly'
            };
          }
          
          return {
            text: `æ˜æ—¥ç· åˆ‡ã®ã‚¿ã‚¹ã‚¯ãŒ${data.length}ä»¶ã‚ã‚Šã¾ã™ã€‚é ‘å¼µã£ã¦å®Œäº†ã•ã›ã¾ã—ã‚‡ã†ï¼`,
            emotion: 'encouraging'
          };
        
        default:
          return {
            text: 'ã©ã®æƒ…å ±ã‚’ãŠçŸ¥ã‚Šã«ãªã‚ŠãŸã„ã§ã™ã‹ï¼Ÿã€Œä»Šæ—¥ã®äºˆå®šã€ã€Œé€²æ—çŠ¶æ³ã€ã€Œæ˜æ—¥ã®ç· åˆ‡ã€ãªã©ã¨è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚',
            emotion: 'friendly'
          };
      }
    } catch (error) {
      return {
        text: 'æƒ…å ±ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        emotion: 'friendly'
      };
    }
  }

  private async handleCasualConversation(command: VoiceCommand): Promise<VoiceResponse> {
    const { entities } = command;
    
    const responses = {
      tired: [
        'å°‘ã—ä¼‘æ†©ã•ã‚Œã¦ã¯ã„ã‹ãŒã§ã™ã‹ï¼Ÿç„¡ç†ã¯ç¦ç‰©ã§ã™ã‚ˆã€‚',
        'ãŠç–²ã‚Œã•ã¾ã§ã™ã€‚æ·±å‘¼å¸ã—ã¦ã€ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã—ã¾ã—ã‚‡ã†ï¼',
        'é ‘å¼µã‚Šã™ããšã€é©åº¦ã«ä¼‘ã‚“ã§ãã ã•ã„ã­ã€‚'
      ],
      encouraging: [
        'ãã®èª¿å­ã§ã™ï¼ã‚ãªãŸãªã‚‰å¿…ãšã§ãã¾ã™ï¼',
        'ç´ æ™´ã‚‰ã—ã„é ‘å¼µã‚Šã§ã™ã­ï¼ç¶™ç¶šã¯åŠ›ãªã‚Šã§ã™ã€‚',
        'é †èª¿ã«é€²ã‚“ã§ã„ã¾ã™ã­ã€‚ã“ã®èª¿å­ã§è¡Œãã¾ã—ã‚‡ã†ï¼'
      ],
      grateful: [
        'ã©ã†ã„ãŸã—ã¾ã—ã¦ï¼ã„ã¤ã§ã‚‚ãŠæ‰‹ä¼ã„ã—ã¾ã™ã€‚',
        'ãŠå½¹ã«ç«‹ã¦ã¦å¬‰ã—ã„ã§ã™ï¼',
        'ã“ã¡ã‚‰ã“ãã€ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼'
      ],
      default: [
        'ã©ã†ã•ã‚Œã¾ã—ãŸã‹ï¼Ÿä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ãŒã‚ã‚Œã°æ•™ãˆã¦ãã ã•ã„ã€‚',
        'ãŠç–²ã‚Œã•ã¾ã§ã™ï¼ä½•ã‹å¿…è¦ãªã“ã¨ãŒã‚ã‚Œã°é æ…®ãªãã©ã†ãã€‚',
        'ã„ã¤ã§ã‚‚ã‚µãƒãƒ¼ãƒˆã„ãŸã—ã¾ã™ï¼ä½•ã§ã‚‚ãŠèã‹ã›ãã ã•ã„ã€‚'
      ]
    };

    const emotionType = entities.emotion || 'default';
    const responseList = responses[emotionType as keyof typeof responses] || responses.default;
    const randomResponse = responseList[Math.floor(Math.random() * responseList.length)];

    return {
      text: randomResponse,
      emotion: emotionType === 'tired' ? 'friendly' : 
              emotionType === 'encouraging' ? 'celebratory' : 'friendly'
    };
  }

  public async speakResponse(response: VoiceResponse): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.synthesis) {
        resolve();
        return;
      }

      const utterance = new SpeechSynthesisUtterance(response.text);
      
      // æ„Ÿæƒ…ã«å¿œã˜ãŸéŸ³å£°è¨­å®š
      switch (response.emotion) {
        case 'celebratory':
          utterance.rate = 1.1;
          utterance.pitch = 1.2;
          break;
        case 'encouraging':
          utterance.rate = 1.0;
          utterance.pitch = 1.1;
          break;
        case 'friendly':
          utterance.rate = 0.9;
          utterance.pitch = 1.0;
          break;
        case 'informative':
          utterance.rate = 0.9;
          utterance.pitch = 0.9;
          break;
      }

      utterance.lang = 'ja-JP';
      utterance.volume = 0.8;

      utterance.onend = () => resolve();
      utterance.onerror = (error) => {
        console.error('Speech synthesis error:', error);
        resolve(); // ã‚¨ãƒ©ãƒ¼ã§ã‚‚ç¶šè¡Œ
      };

      this.synthesis.speak(utterance);
    });
  }

  private async executeAction(action: { type: string; data: any }): Promise<void> {
    switch (action.type) {
      case 'REFRESH_TASKS':
        window.dispatchEvent(new CustomEvent('refreshTasks', { detail: action.data }));
        break;
      case 'NAVIGATE':
        window.location.href = action.data.url;
        break;
      case 'SHOW_NOTIFICATION':
        this.showNotification(action.data.message);
        break;
    }
  }

  private async getCurrentContext(): Promise<any> {
    return {
      currentPage: window.location.pathname,
      recentActions: JSON.parse(localStorage.getItem('recentActions') || '[]'),
      activeTasks: await this.getActiveTasksCount(),
      todayAppointments: await this.getTodayAppointmentsCount()
    };
  }

  private async getCurrentTaskId(): Promise<string | null> {
    // ç¾åœ¨é¸æŠä¸­ã®ã‚¿ã‚¹ã‚¯IDã‚’å–å¾—ï¼ˆç”»é¢ã®çŠ¶æ…‹ã‹ã‚‰ï¼‰
    const selectedElement = document.querySelector('[data-task-id].selected');
    return selectedElement?.getAttribute('data-task-id') || null;
  }

  private async getActiveTasksCount(): Promise<number> {
    try {
      const response = await fetch('/api/tasks?status=in_progress');
      const tasks = await response.json();
      return tasks.length;
    } catch {
      return 0;
    }
  }

  private async getTodayAppointmentsCount(): Promise<number> {
    try {
      const today = new Date().toISOString().split('T')[0];
      const response = await fetch(`/api/appointments?date=${today}`);
      const appointments = await response.json();
      return appointments.length;
    } catch {
      return 0;
    }
  }

  private showNotification(message: string): void {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification('FIND to DO', {
        body: message,
        icon: '/icons/icon-192x192.png'
      });
    }
  }

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
  public onListeningStateChange?: (isListening: boolean) => void;
  public onInterimResult?: (transcript: string) => void;
  public onError?: (error: string) => void;

  public destroy(): void {
    if (this.recognition) {
      this.recognition.abort();
    }
    if (this.synthesis) {
      this.synthesis.cancel();
    }
  }
}

// React Hook
export function useVoiceProcessor() {
  const [processor] = useState(() => new VoiceProcessor());
  const [isListening, setIsListening] = useState(false);
  const [interimTranscript, setInterimTranscript] = useState('');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    processor.onListeningStateChange = setIsListening;
    processor.onInterimResult = setInterimTranscript;
    processor.onError = setError;

    return () => {
      processor.destroy();
    };
  }, [processor]);

  const startListening = useCallback(async () => {
    try {
      await processor.startListening();
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    }
  }, [processor]);

  const stopListening = useCallback(() => {
    processor.stopListening();
  }, [processor]);

  return {
    isListening,
    interimTranscript,
    error,
    startListening,
    stopListening
  };
}
```

### **B.2 AIäºˆæ¸¬ãƒ»è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…**

#### **B.2.1 è¡Œå‹•å­¦ç¿’ãƒ»äºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³**
```typescript
// src/lib/mobile/predictiveEngine.ts
export interface UserBehaviorPattern {
  userId: string;
  timePatterns: {
    activeHours: number[];
    peakProductivityTime: number;
    breakTimes: number[];
    weeklyPattern: Record<string, number>;
  };
  taskPatterns: {
    preferredTaskTypes: string[];
    averageCompletionTime: Record<string, number>;
    procrastinationTriggers: string[];
    motivationFactors: string[];
  };
  interactionPatterns: {
    preferredInputMethod: 'voice' | 'gesture' | 'touch';
    frequentActions: string[];
    navigationStyle: 'linear' | 'random' | 'efficient';
    helpSeekingBehavior: string[];
  };
  contextualPatterns: {
    locationBasedBehavior: Record<string, string[]>;
    timeBasedBehavior: Record<string, string[]>;
    moodBasedBehavior: Record<string, string[]>;
  };
}

export interface PredictionResult {
  nextAction: {
    type: string;
    confidence: number;
    reasoning: string;
    suggestedTiming: Date;
  };
  contextualSuggestions: Array<{
    suggestion: string;
    priority: number;
    category: string;
    reasoning: string;
  }>;
  riskAlerts: Array<{
    type: string;
    severity: 'low' | 'medium' | 'high';
    description: string;
    preventionActions: string[];
  }>;
  optimizationTips: Array<{
    tip: string;
    impact: number;
    difficulty: number;
    category: string;
  }>;
}

export class PredictiveEngine {
  private behaviorPattern: UserBehaviorPattern | null = null;
  private recentActions: any[] = [];
  private contextHistory: any[] = [];
  private geminiAPI: any;

  constructor() {
    this.geminiAPI = window.AI_SERVICE;
    this.loadUserBehaviorPattern();
    this.startBehaviorTracking();
  }

  private async loadUserBehaviorPattern(): Promise<void> {
    try {
      const response = await fetch('/api/user/behavior-pattern');
      if (response.ok) {
        this.behaviorPattern = await response.json();
      } else {
        // åˆå›ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½œæˆ
        this.behaviorPattern = await this.createDefaultBehaviorPattern();
      }
    } catch (error) {
      console.error('Failed to load behavior pattern:', error);
      this.behaviorPattern = await this.createDefaultBehaviorPattern();
    }
  }

  private async createDefaultBehaviorPattern(): Promise<UserBehaviorPattern> {
    const userId = this.getCurrentUserId();
    return {
      userId,
      timePatterns: {
        activeHours: [9, 10, 11, 14, 15, 16, 17],
        peakProductivityTime: 10,
        breakTimes: [12, 15],
        weeklyPattern: {
          monday: 0.8,
          tuesday: 0.9,
          wednesday: 1.0,
          thursday: 0.9,
          friday: 0.7,
          saturday: 0.3,
          sunday: 0.2
        }
      },
      taskPatterns: {
        preferredTaskTypes: ['development', 'planning'],
        averageCompletionTime: {
          'simple': 30,
          'medium': 120,
          'complex': 480
        },
        procrastinationTriggers: ['large_tasks', 'unclear_requirements'],
        motivationFactors: ['clear_goals', 'recognition', 'learning']
      },
      interactionPatterns: {
        preferredInputMethod: 'touch',
        frequentActions: ['check_tasks', 'update_status', 'view_schedule'],
        navigationStyle: 'efficient',
        helpSeekingBehavior: ['search_knowledge', 'ask_colleague']
      },
      contextualPatterns: {
        locationBasedBehavior: {
          'office': ['focus_work', 'meetings', 'collaboration'],
          'home': ['planning', 'learning', 'personal_tasks'],
          'commute': ['quick_checks', 'voice_commands', 'listening']
        },
        timeBasedBehavior: {
          'morning': ['planning', 'high_priority_tasks'],
          'afternoon': ['meetings', 'collaboration'],
          'evening': ['wrap_up', 'tomorrow_planning']
        },
        moodBasedBehavior: {
          'energetic': ['complex_tasks', 'creative_work'],
          'tired': ['simple_tasks', 'review'],
          'stressed': ['break_down_tasks', 'seek_help']
        }
      }
    };
  }

  private startBehaviorTracking(): void {
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½è·¡
    this.trackPageViews();
    this.trackTaskInteractions();
    this.trackTimePatterns();
    this.trackContextChanges();
  }

  private trackPageViews(): void {
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;

    history.pushState = function(...args) {
      originalPushState.apply(history, args);
      this.recordAction('page_navigation', { url: args[2] });
    }.bind(this);

    history.replaceState = function(...args) {
      originalReplaceState.apply(history, args);
      this.recordAction('page_navigation', { url: args[2] });
    }.bind(this);

    window.addEventListener('popstate', () => {
      this.recordAction('page_navigation', { url: window.location.pathname });
    });
  }

  private trackTaskInteractions(): void {
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      
      if (target.closest('[data-task-id]')) {
        const taskId = target.closest('[data-task-id]')?.getAttribute('data-task-id');
        const action = this.inferTaskAction(target);
        
        this.recordAction('task_interaction', {
          taskId,
          action,
          timestamp: new Date(),
          element: target.tagName.toLowerCase()
        });
      }
    });

    // ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚‚è¿½è·¡
    window.addEventListener('mobileDataUpdate', (event: any) => {
      this.recordAction('gesture_action', event.detail);
    });
  }

  private trackTimePatterns(): void {
    // 1åˆ†ã”ã¨ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’è¨˜éŒ²
    setInterval(() => {
      if (document.hasFocus()) {
        this.recordAction('active_time', {
          hour: new Date().getHours(),
          day: new Date().getDay(),
          url: window.location.pathname
        });
      }
    }, 60000);
  }

  private trackContextChanges(): void {
    // ãƒ‡ãƒã‚¤ã‚¹æ–¹å‘å¤‰æ›´
    window.addEventListener('orientationchange', () => {
      this.recordAction('context_change', {
        type: 'orientation',
        orientation: screen.orientation?.angle
      });
    });

    // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ…‹å¤‰æ›´
    window.addEventListener('online', () => {
      this.recordAction('context_change', { type: 'network', online: true });
    });

    window.addEventListener('offline', () => {
      this.recordAction('context_change', { type: 'network', online: false });
    });
  }

  private recordAction(type: string, data: any): void {
    const action = {
      type,
      data,
      timestamp: new Date(),
      context: this.getCurrentContext()
    };

    this.recentActions.push(action);
    
    // æœ€æ–°1000ä»¶ã®ã¿ä¿æŒ
    if (this.recentActions.length > 1000) {
      this.recentActions = this.recentActions.slice(-1000);
    }

    // å®šæœŸçš„ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ›´æ–°
    if (this.recentActions.length % 50 === 0) {
      this.updateBehaviorPattern();
    }
  }

  public async generatePredictions(): Promise<PredictionResult> {
    if (!this.behaviorPattern) {
      await this.loadUserBehaviorPattern();
    }

    const currentContext = this.getCurrentContext();
    const recentBehavior = this.recentActions.slice(-20);

    const predictionPrompt = `
    ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•äºˆæ¸¬åˆ†æ:
    
    ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ:
    - æ™‚åˆ»: ${new Date().toLocaleString('ja-JP')}
    - ç”»é¢: ${currentContext.currentPage}
    - ãƒãƒƒãƒ†ãƒªãƒ¼: ${(navigator as any).getBattery ? 'ãƒã‚§ãƒƒã‚¯ä¸­' : 'ä¸æ˜'}
    - ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: ${navigator.onLine ? 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³' : 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³'}
    
    ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³:
    - ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚é–“å¸¯: ${this.behaviorPattern?.timePatterns.activeHours.join(', ')}
    - ç”Ÿç”£æ€§ãƒ”ãƒ¼ã‚¯: ${this.behaviorPattern?.timePatterns.peakProductivityTime}æ™‚
    - å¥½ã¿ã‚¿ã‚¹ã‚¯: ${this.behaviorPattern?.taskPatterns.preferredTaskTypes.join(', ')}
    - æ“ä½œã‚¹ã‚¿ã‚¤ãƒ«: ${this.behaviorPattern?.interactionPatterns.preferredInputMethod}
    
    æœ€è¿‘ã®è¡Œå‹•:
    ${recentBehavior.map(action => 
      `${action.timestamp.toLocaleTimeString()}: ${action.type} - ${JSON.stringify(action.data)}`
    ).join('\n')}
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§äºˆæ¸¬ãƒ»ææ¡ˆã‚’ç”Ÿæˆ:
    
    1. æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³äºˆæ¸¬
       - æœ€ã‚‚å¯èƒ½æ€§ã®é«˜ã„æ¬¡ã®è¡Œå‹•
       - å®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®ææ¡ˆ
       - ç†ç”±ãƒ»æ ¹æ‹ 
    
    2. ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ¥ææ¡ˆ
       - ç¾åœ¨ã®çŠ¶æ³ã«æœ€é©ãªä½œæ¥­
       - åŠ¹ç‡åŒ–ã®ãŸã‚ã®ææ¡ˆ
       - å„ªå…ˆåº¦ã®é«˜ã„ã‚¿ã‚¹ã‚¯
    
    3. ãƒªã‚¹ã‚¯ã‚¢ãƒ©ãƒ¼ãƒˆ
       - æ³¨æ„ã™ã¹ãç‚¹ï¼ˆç–²åŠ´ã€é…å»¶ç­‰ï¼‰
       - äºˆé˜²ã™ã¹ãå•é¡Œ
       - å¯¾ç­–ã®ææ¡ˆ
    
    4. æœ€é©åŒ–ãƒ’ãƒ³ãƒˆ
       - ç”Ÿç”£æ€§å‘ä¸Šã®å…·ä½“çš„ææ¡ˆ
       - æ™‚é–“ç®¡ç†ã®æ”¹å–„ç‚¹
       - ãƒ„ãƒ¼ãƒ«æ´»ç”¨ã®ã‚³ãƒ„
    
    JSONå½¢å¼ã§å›ç­”:
    {
      "nextAction": {
        "type": "check_deadlines",
        "confidence": 0.8,
        "reasoning": "åˆå‰ä¸­ã®ç¿’æ…£ã¨ã—ã¦ç· åˆ‡ç¢ºèªã‚’è¡Œã†å‚¾å‘",
        "suggestedTiming": "2025-07-01T10:30:00Z"
      },
      "contextualSuggestions": [
        {
          "suggestion": "é‡è¦åº¦Aã®ã‚¿ã‚¹ã‚¯ã«é›†ä¸­ã—ã¾ã—ã‚‡ã†",
          "priority": 9,
          "category": "productivity",
          "reasoning": "ç¾åœ¨ãŒç”Ÿç”£æ€§ãƒ”ãƒ¼ã‚¯æ™‚é–“ã®ãŸã‚"
        }
      ],
      "riskAlerts": [
        {
          "type": "overload",
          "severity": "medium",
          "description": "ä»Šæ—¥ã®ã‚¿ã‚¹ã‚¯ãŒå¤šã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™",
          "preventionActions": ["å„ªå…ˆåº¦ã®è¦‹ç›´ã—", "ä¸€éƒ¨ã‚¿ã‚¹ã‚¯ã®å»¶æœŸæ¤œè¨"]
        }
      ],
      "optimizationTips": [
        {
          "tip": "éŸ³å£°ã‚³ãƒãƒ³ãƒ‰ã‚’æ´»ç”¨ã—ã¦å…¥åŠ›æ™‚é–“ã‚’çŸ­ç¸®",
          "impact": 8,
          "difficulty": 3,
          "category": "efficiency"
        }
      ]
    }
    `;

    try {
      const result = await this.geminiAPI.evaluateWithGemini(predictionPrompt);
      return JSON.parse(result);
    } catch (error) {
      console.error('Prediction generation error:', error);
      return this.getDefaultPrediction();
    }
  }

  public async executeAutomatedAction(prediction: PredictionResult): Promise<boolean> {
    const { nextAction } = prediction;
    
    // é«˜ä¿¡é ¼åº¦ï¼ˆ0.9ä»¥ä¸Šï¼‰ã®å ´åˆã®ã¿è‡ªå‹•å®Ÿè¡Œ
    if (nextAction.confidence < 0.9) {
      return false;
    }

    try {
      switch (nextAction.type) {
        case 'check_deadlines':
          await this.autoCheckDeadlines();
          break;
        case 'suggest_break':
          await this.autoSuggestBreak();
          break;
        case 'organize_tasks':
          await this.autoOrganizeTasks();
          break;
        case 'remind_meeting':
          await this.autoRemindMeeting();
          break;
        default:
          return false;
      }
      
      this.recordAction('automated_action', {
        type: nextAction.type,
        executed: true,
        confidence: nextAction.confidence
      });
      
      return true;
    } catch (error) {
      console.error('Automated action error:', error);
      return false;
    }
  }

  private async autoCheckDeadlines(): Promise<void> {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const response = await fetch(`/api/tasks?deadline_before=${tomorrow.toISOString()}`);
    const urgentTasks = await response.json();
    
    if (urgentTasks.length > 0) {
      this.showNotification(
        `æ˜æ—¥ã¾ã§ã®ç· åˆ‡ã‚¿ã‚¹ã‚¯ãŒ${urgentTasks.length}ä»¶ã‚ã‚Šã¾ã™`,
        'deadline_check'
      );
    }
  }

  private async autoSuggestBreak(): Promise<void> {
    const lastBreak = this.getLastBreakTime();
    const workDuration = Date.now() - lastBreak;
    
    if (workDuration > 90 * 60 * 1000) { // 90åˆ†ä»¥ä¸Š
      this.showNotification(
        '90åˆ†é–“é›†ä¸­ã•ã‚Œã¾ã—ãŸã€‚5åˆ†ç¨‹åº¦ã®ä¼‘æ†©ã‚’ãŠå‹§ã‚ã—ã¾ã™',
        'break_suggestion'
      );
    }
  }

  private async autoOrganizeTasks(): Promise<void> {
    const response = await fetch('/api/tasks?status=pending');
    const pendingTasks = await response.json();
    
    if (pendingTasks.length > 10) {
      this.showNotification(
        `æœªç€æ‰‹ã®ã‚¿ã‚¹ã‚¯ãŒ${pendingTasks.length}ä»¶ã‚ã‚Šã¾ã™ã€‚æ•´ç†ã—ã¦ã¿ã¾ã›ã‚“ã‹ï¼Ÿ`,
        'task_organization'
      );
    }
  }

  private getCurrentContext(): any {
    return {
      currentPage: window.location.pathname,
      timestamp: new Date(),
      hour: new Date().getHours(),
      dayOfWeek: new Date().getDay(),
      online: navigator.onLine
    };
  }

  private inferTaskAction(element: HTMLElement): string {
    const className = element.className.toLowerCase();
    const tagName = element.tagName.toLowerCase();
    
    if (className.includes('complete') || className.includes('done')) {
      return 'complete';
    } else if (className.includes('edit')) {
      return 'edit';
    } else if (className.includes('delete')) {
      return 'delete';
    } else if (tagName === 'button') {
      return 'action';
    } else {
      return 'view';
    }
  }

  private async updateBehaviorPattern(): Promise<void> {
    if (!this.behaviorPattern) return;

    // è¡Œå‹•ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã—ã¦ patern ã‚’æ›´æ–°
    const analysis = this.analyzeBehaviorData();
    
    // å­¦ç¿’ã—ãŸ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜
    try {
      await fetch('/api/user/behavior-pattern', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...this.behaviorPattern,
          ...analysis,
          lastUpdated: new Date()
        })
      });
    } catch (error) {
      console.error('Failed to update behavior pattern:', error);
    }
  }

  private analyzeBehaviorData(): Partial<UserBehaviorPattern> {
    const activeHours = this.extractActiveHours();
    const preferredActions = this.extractPreferredActions();
    
    return {
      timePatterns: {
        ...this.behaviorPattern!.timePatterns,
        activeHours
      },
      interactionPatterns: {
        ...this.behaviorPattern!.interactionPatterns,
        frequentActions: preferredActions
      }
    };
  }

  private extractActiveHours(): number[] {
    const hourCounts = new Array(24).fill(0);
    
    this.recentActions
      .filter(action => action.type === 'active_time')
      .forEach(action => {
        hourCounts[action.data.hour]++;
      });
    
    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åº¦ãŒå¹³å‡ä»¥ä¸Šã®æ™‚é–“å¸¯ã‚’æŠ½å‡º
    const average = hourCounts.reduce((sum, count) => sum + count, 0) / 24;
    return hourCounts
      .map((count, hour) => ({ hour, count }))
      .filter(({ count }) => count > average)
      .map(({ hour }) => hour);
  }

  private extractPreferredActions(): string[] {
    const actionCounts: Record<string, number> = {};
    
    this.recentActions.forEach(action => {
      actionCounts[action.type] = (actionCounts[action.type] || 0) + 1;
    });
    
    return Object.entries(actionCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([action]) => action);
  }

  private getDefaultPrediction(): PredictionResult {
    return {
      nextAction: {
        type: 'check_tasks',
        confidence: 0.5,
        reasoning: 'ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆææ¡ˆ',
        suggestedTiming: new Date()
      },
      contextualSuggestions: [],
      riskAlerts: [],
      optimizationTips: []
    };
  }

  private showNotification(message: string, type: string): void {
    if ('Notification' in window && Notification.permission === 'granted') {
      new Notification('FIND to DO - AIææ¡ˆ', {
        body: message,
        icon: '/icons/icon-192x192.png',
        tag: type
      });
    }
  }

  private getCurrentUserId(): string {
    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‹ã‚‰ ãƒ¦ãƒ¼ã‚¶ãƒ¼ID ã‚’å–å¾—
    return 'current-user'; // å®Ÿè£…æ™‚ã¯é©åˆ‡ãªæ–¹æ³•ã§å–å¾—
  }

  private getLastBreakTime(): number {
    const lastBreakAction = this.recentActions
      .filter(action => action.type === 'break' || action.type === 'inactive_time')
      .slice(-1)[0];
    
    return lastBreakAction ? lastBreakAction.timestamp.getTime() : Date.now() - 2 * 60 * 60 * 1000;
  }
}

// React Hook
export function usePredictiveEngine() {
  const [engine] = useState(() => new PredictiveEngine());
  const [predictions, setPredictions] = useState<PredictionResult | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);

  const generatePredictions = useCallback(async () => {
    setIsGenerating(true);
    try {
      const result = await engine.generatePredictions();
      setPredictions(result);
      
      // é«˜ä¿¡é ¼åº¦ã®äºˆæ¸¬ã¯è‡ªå‹•å®Ÿè¡Œã‚’è©¦è¡Œ
      if (result.nextAction.confidence > 0.9) {
        await engine.executeAutomatedAction(result);
      }
    } catch (error) {
      console.error('Failed to generate predictions:', error);
    } finally {
      setIsGenerating(false);
    }
  }, [engine]);

  useEffect(() => {
    // åˆå›äºˆæ¸¬ç”Ÿæˆ
    generatePredictions();
    
    // 5åˆ†ã”ã¨ã«äºˆæ¸¬ã‚’æ›´æ–°
    const interval = setInterval(generatePredictions, 5 * 60 * 1000);
    
    return () => clearInterval(interval);
  }, [generatePredictions]);

  return {
    predictions,
    isGenerating,
    generatePredictions
  };
}
```

---

## ğŸ§ª **Phase B ãƒ†ã‚¹ãƒˆè¨ˆç”»**

### **B.1 éŸ³å£°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/mobile/VoiceProcessor.test.ts
import { VoiceProcessor } from '../../src/lib/mobile/voiceProcessing';

describe('VoiceProcessor', () => {
  let voiceProcessor: VoiceProcessor;
  
  beforeEach(() => {
    // Mock Web Speech API
    global.SpeechRecognition = jest.fn().mockImplementation(() => ({
      start: jest.fn(),
      stop: jest.fn(),
      abort: jest.fn(),
      addEventListener: jest.fn(),
      continuous: false,
      interimResults: false,
      lang: 'ja-JP'
    }));
    
    global.speechSynthesis = {
      speak: jest.fn(),
      cancel: jest.fn(),
      getVoices: jest.fn(() => [])
    } as any;
    
    voiceProcessor = new VoiceProcessor();
  });

  test('should parse task creation command', async () => {
    const command = await voiceProcessor.parseVoiceCommand('æ˜æ—¥ã¾ã§ã«ãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆ');
    
    expect(command.intent).toBe('TASK_CREATE');
    expect(command.entities.title).toContain('ãƒ¬ãƒãƒ¼ãƒˆ');
    expect(command.confidence).toBeGreaterThan(0.7);
  });

  test('should handle task completion command', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ success: true })
      })
    ) as jest.Mock;

    const response = await voiceProcessor.handleTaskUpdate({
      intent: 'TASK_UPDATE',
      entities: { status: 'completed', taskId: 'test-task' },
      confidence: 0.9,
      rawText: 'ã“ã®ã‚¿ã‚¹ã‚¯å®Œäº†'
    });

    expect(response.emotion).toBe('celebratory');
    expect(response.text).toContain('å®Œäº†');
  });
});
```

### **B.2 äºˆæ¸¬ã‚¨ãƒ³ã‚¸ãƒ³ãƒ†ã‚¹ãƒˆ**
```typescript
// __tests__/mobile/PredictiveEngine.test.ts
import { PredictiveEngine } from '../../src/lib/mobile/predictiveEngine';

describe('PredictiveEngine', () => {
  let engine: PredictiveEngine;
  
  beforeEach(() => {
    engine = new PredictiveEngine();
  });

  test('should generate predictions', async () => {
    const predictions = await engine.generatePredictions();
    
    expect(predictions.nextAction).toBeDefined();
    expect(predictions.nextAction.confidence).toBeGreaterThanOrEqual(0);
    expect(predictions.nextAction.confidence).toBeLessThanOrEqual(1);
  });

  test('should track user behavior', () => {
    engine.recordAction('task_interaction', {
      taskId: 'test-task',
      action: 'complete'
    });
    
    expect(engine.recentActions).toHaveLength(1);
  });
});
```

---

## ğŸ“Š **Phase B æˆåŠŸæŒ‡æ¨™**

### **B.1 å®šé‡æŒ‡æ¨™**
- [ ] **éŸ³å£°èªè­˜ç²¾åº¦**: 90%ä»¥ä¸Šï¼ˆæ—¥æœ¬èªï¼‰
- [ ] **æ„å›³ç†è§£ç²¾åº¦**: 85%ä»¥ä¸Šï¼ˆåŸºæœ¬ã‚³ãƒãƒ³ãƒ‰ï¼‰
- [ ] **äºˆæ¸¬ç²¾åº¦**: 70%ä»¥ä¸Šï¼ˆæ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼‰
- [ ] **å¿œç­”æ™‚é–“**: éŸ³å£°å‡¦ç†3ç§’ä»¥å†…ã€AIäºˆæ¸¬5ç§’ä»¥å†…

### **B.2 æ©Ÿèƒ½æŒ‡æ¨™**
- [ ] **éŸ³å£°ã‚¿ã‚¹ã‚¯ä½œæˆ**: è‡ªç„¶è¨€èªã‹ã‚‰æ­£ç¢ºãªã‚¿ã‚¹ã‚¯ä½œæˆ
- [ ] **æ„Ÿæƒ…èªè­˜**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ„Ÿæƒ…çŠ¶æ…‹ã«å¿œã˜ãŸé©åˆ‡ãªå¿œç­”
- [ ] **è¡Œå‹•äºˆæ¸¬**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’70%ä»¥ä¸Šã®ç²¾åº¦ã§äºˆæ¸¬
- [ ] **è‡ªå‹•å®Ÿè¡Œ**: é«˜ä¿¡é ¼åº¦äºˆæ¸¬ã®è‡ªå‹•å®Ÿè¡Œæ©Ÿèƒ½

### **B.3 ãƒ¦ãƒ¼ã‚¶ãƒ“ãƒªãƒ†ã‚£æŒ‡æ¨™**
- [ ] **å­¦ç¿’ã‚³ã‚¹ãƒˆ**: éŸ³å£°ã‚³ãƒãƒ³ãƒ‰5åˆ†ä»¥å†…ã§ç¿’å¾—
- [ ] **ã‚¨ãƒ©ãƒ¼å›å¾©**: éŸ³å£°èªè­˜å¤±æ•—æ™‚ã®é©åˆ‡ãªãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—
- [ ] **è‡ªç„¶æ€§**: AIã¨ã®å¯¾è©±ãŒè‡ªç„¶ã§è¦ªã—ã¿ã‚„ã™ã„

---

## ğŸš€ **Phase B å®Œäº†åŸºæº–**

### **B.1 æ©Ÿèƒ½å®Œäº†åŸºæº–**
1. **éŸ³å£°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®Œäº†**
   - [ ] 8ã¤ã®åŸºæœ¬éŸ³å£°ã‚³ãƒãƒ³ãƒ‰èªè­˜
   - [ ] è‡ªç„¶è¨€èªã‹ã‚‰ã®ã‚¿ã‚¹ã‚¯ãƒ»äºˆå®šä½œæˆ
   - [ ] æ„Ÿæƒ…ã«å¿œã˜ãŸéŸ³å£°å¿œç­”

2. **AIäºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ å®Œäº†**
   - [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³å­¦ç¿’
   - [ ] æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³äºˆæ¸¬ãƒ»ææ¡ˆ
   - [ ] é«˜ä¿¡é ¼åº¦ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®è‡ªå‹•å®Ÿè¡Œ

3. **LINE Botå¼·åŒ–å®Œäº†**
   - [ ] æ„Ÿæƒ…èªè­˜æ©Ÿèƒ½
   - [ ] ãƒ—ãƒ­ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
   - [ ] é«˜åº¦ãªè‡ªç„¶è¨€èªç†è§£

### **B.2 å“è³ªå®Œäº†åŸºæº–**
- [ ] å…¨ãƒ†ã‚¹ãƒˆé€šé
- [ ] éŸ³å£°èªè­˜å„ãƒ–ãƒ©ã‚¦ã‚¶äº’æ›æ€§ç¢ºèª
- [ ] AIå¿œç­”ã®é©åˆ‡æ€§ç¢ºèª
- [ ] ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç¢ºèª

### **B.3 é‹ç”¨å®Œäº†åŸºæº–**
- [ ] éŸ³å£°ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–ãƒ»å‰Šé™¤æ©Ÿèƒ½
- [ ] AIå¿œç­”ã®ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†æ©Ÿèƒ½

---

**æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: Phase Aå®Œäº†å¾Œã€ã“ã®è¨ˆç”»ã«å¾“ã£ã¦Phase Bå®Ÿè£…ã‚’é–‹å§‹ã€‚éŸ³å£°ã¨AIã®åŠ›ã§ã€çœŸã«é©æ–°çš„ãªãƒ¢ãƒã‚¤ãƒ«ä½“é¨“ã‚’å®Ÿç¾ã—ã¾ã™ã€‚