# Phase 4: å–¶æ¥­ãƒ»ã‚¢ãƒã‚¤ãƒ³ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  å®Ÿè£…è¨ˆç”»æ›¸ (ä¿®æ­£ç‰ˆ)

**ãƒ•ã‚§ãƒ¼ã‚ºæœŸé–“**: 5æ—¥é–“  
**å®Ÿè£…æ—¥**: 2025å¹´7æœˆ9æ—¥ ã€œ 2025å¹´7æœˆ13æ—¥  
**æ‹…å½“ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢**: å–¶æ¥­ã‚·ã‚¹ãƒ†ãƒ æ‹…å½“  
**å‰ææ¡ä»¶**: Phase 1-3å®Œäº†ã€æ—¢å­˜å–¶æ¥­ãƒ»ã‚¢ãƒã‚¤ãƒ³ãƒˆç®¡ç†æ©Ÿèƒ½ã®ç†è§£

**ä¿®æ­£ç†ç”±**: è‡ªç„¶è¨€èªå‡¦ç†ã®èª¤èªè­˜ãƒªã‚¹ã‚¯ã‚’é¿ã‘ã€ã‚ˆã‚Šå®‰å…¨ã§ç¢ºå®Ÿãªå®Ÿè£…ã«å¤‰æ›´

---

## ğŸ¯ **Phase 4 å®Ÿè£…ç›®æ¨™ (ä¿®æ­£ç‰ˆ)**

### **4.1 ä¸»è¦æ©Ÿèƒ½å®Ÿè£…**
- **LINE/Discord ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIå¼·åŒ–**: æ—¢å­˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ãƒ™ãƒ¼ã‚¹ã®å®‰å…¨ãªæ“ä½œä½“é¨“
- **å–¶æ¥­ãƒ—ãƒ­ã‚»ã‚¹å®Œå…¨è‡ªå‹•åŒ–**: ã‚¢ãƒã‚¤ãƒ³ãƒˆâ†’å¥‘ç´„â†’ãƒãƒƒã‚¯ã‚ªãƒ•ã‚£ã‚¹é€£æºã®å…¨è‡ªå‹•åŒ–
- **AIå–¶æ¥­ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ**: é¡§å®¢åˆ†æãƒ»ææ¡ˆç”Ÿæˆãƒ»äº¤æ¸‰æ”¯æ´ã‚·ã‚¹ãƒ†ãƒ 
- **æˆç´„ç¢ºç‡ã‚¨ãƒ³ã‚¸ãƒ³**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æˆç´„ç¢ºç‡ç®—å‡ºãƒ»æœ€é©ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ææ¡ˆ

### **4.2 æŠ€è¡“è¦ä»¶**
- æ—¢å­˜å–¶æ¥­ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®é«˜åº¦åŒ–
- **å®‰å…¨ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ™ãƒ¼ã‚¹æ“ä½œ**: å‹å®‰å…¨æ€§ã‚’ä¿è¨¼
- LINE/Discord APIçµ±åˆå¼·åŒ–ï¼ˆæ—¢å­˜ãƒ‘ã‚¿ãƒ¼ãƒ³è¸è¥²ï¼‰
- AIæ”¯æ´å–¶æ¥­ãƒ—ãƒ­ã‚»ã‚¹ã®å®Œå…¨å®Ÿè£…

---

## ğŸ“‹ **Phase 4 å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ (ä¿®æ­£ç‰ˆ)**

### **4.1 LINE/Discord ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIå¼·åŒ– (1æ—¥)**
- [ ] æ—¢å­˜ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µ
- [ ] ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—å…¥åŠ›ãƒ•ãƒ­ãƒ¼
- [ ] å‹å®‰å…¨ãªæ“ä½œç¢ºèªã‚·ã‚¹ãƒ†ãƒ 
- [ ] ç”»åƒãƒ»æ·»ä»˜ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å¼·åŒ–

### **4.2 å–¶æ¥­ãƒ—ãƒ­ã‚»ã‚¹è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ  (2.5æ—¥)**
- [ ] ã‚¢ãƒã‚¤ãƒ³ãƒˆè‡ªå‹•ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
- [ ] å¥‘ç´„å‡¦ç†è‡ªå‹•åŒ–ã‚¨ãƒ³ã‚¸ãƒ³
- [ ] ãƒãƒƒã‚¯ã‚ªãƒ•ã‚£ã‚¹ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆ
- [ ] ãƒŠãƒ¬ãƒƒã‚¸è‡ªå‹•è“„ç©ã‚·ã‚¹ãƒ†ãƒ 
- [ ] å–¶æ¥­ã‚¹ãƒ†ãƒ¼ã‚¸è‡ªå‹•é€²è¡Œç®¡ç†

### **4.3 AIå–¶æ¥­ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ (1æ—¥)**
- [ ] é¡§å®¢åˆ†æãƒ»ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆ
- [ ] ææ¡ˆæ›¸è‡ªå‹•ç”Ÿæˆæ©Ÿèƒ½
- [ ] äº¤æ¸‰æˆ¦ç•¥ææ¡ˆã‚·ã‚¹ãƒ†ãƒ 
- [ ] æˆç´„æœ€é©åŒ–ã‚¨ãƒ³ã‚¸ãƒ³

### **4.4 æˆç´„ç¢ºç‡ã‚¨ãƒ³ã‚¸ãƒ³ (0.5æ—¥)**
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æˆç´„ç¢ºç‡ç®—å‡º
- [ ] æˆç´„è¦å› åˆ†æã‚·ã‚¹ãƒ†ãƒ 
- [ ] æœ€é©ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ã‚³ãƒ¡ãƒ³ãƒ‰
- [ ] å–¶æ¥­ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹äºˆæ¸¬

---

## ğŸ”§ **è©³ç´°å®Ÿè£…ã‚¬ã‚¤ãƒ‰ (ä¿®æ­£ç‰ˆ)**

### **4.1 LINE/Discord ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIå¼·åŒ–**

#### **4.1.1 å®‰å…¨ãªãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ™ãƒ¼ã‚¹æ“ä½œã‚·ã‚¹ãƒ†ãƒ **
```typescript
// src/services/SafeMenuProcessor.ts
import { AI_SERVICE } from './ai-service';

export interface MenuAction {
  id: string;
  label: string;
  type: 'TASK_CREATE' | 'APPOINTMENT_CREATE' | 'STATUS_UPDATE' | 'REPORT_REQUEST';
  parameters: {
    required: string[];
    optional: string[];
    validation: Record<string, (value: any) => boolean>;
  };
  confirmationRequired: boolean;
}

export interface MenuSession {
  userId: string;
  platform: 'LINE' | 'DISCORD';
  currentAction: MenuAction | null;
  collectedData: Record<string, any>;
  currentStep: number;
  totalSteps: number;
  startedAt: Date;
  lastActivity: Date;
}

export interface ProcessingResult {
  success: boolean;
  data: Record<string, any>;
  nextAction?: MenuAction;
  response: {
    text: string;
    quickReplies?: string[];
    flexMessage?: any; // LINE Flex Message
    embedMessage?: any; // Discord Embed
  };
}

export class SafeMenuProcessor {
  private activeSessions: Map<string, MenuSession> = new Map();
  
  constructor(
    private aiService: typeof AI_SERVICE,
    private taskService: any,
    private appointmentService: any,
    private projectService: any
  ) {}

  /**
   * ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹
   */
  async startMenuAction(
    userId: string, 
    platform: 'LINE' | 'DISCORD', 
    actionId: string
  ): Promise<ProcessingResult> {
    
    const menuAction = await this.getMenuAction(actionId);
    if (!menuAction) {
      return this.createErrorResponse('ä¸æ­£ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ã™');
    }

    const session: MenuSession = {
      userId,
      platform,
      currentAction: menuAction,
      collectedData: {},
      currentStep: 0,
      totalSteps: menuAction.parameters.required.length + menuAction.parameters.optional.length,
      startedAt: new Date(),
      lastActivity: new Date()
    };

    this.activeSessions.set(userId, session);

    return this.processCurrentStep(session);
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›å‡¦ç† (ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒ™ãƒ¼ã‚¹)
   */
  async processUserInput(
    userId: string,
    input: string,
    attachments?: any[]
  ): Promise<ProcessingResult> {
    
    const session = this.activeSessions.get(userId);
    if (!session || !session.currentAction) {
      return this.showMainMenu(userId);
    }

    session.lastActivity = new Date();

    const currentParameter = this.getCurrentParameter(session);
    if (!currentParameter) {
      return await this.executeAction(session);
    }

    // å‹å®‰å…¨ãªå…¥åŠ›æ¤œè¨¼
    const validationResult = await this.validateInput(currentParameter, input, attachments);
    if (!validationResult.isValid) {
      return {
        success: false,
        data: {},
        response: {
          text: `å…¥åŠ›ã‚¨ãƒ©ãƒ¼: ${validationResult.error}\n\n${currentParameter.prompt}`,
          quickReplies: currentParameter.suggestions
        }
      };
    }

    // ãƒ‡ãƒ¼ã‚¿ä¿å­˜
    session.collectedData[currentParameter.name] = validationResult.value;
    session.currentStep++;

    return this.processCurrentStep(session);
  }

  /**
   * ç¾åœ¨ã‚¹ãƒ†ãƒƒãƒ—ã®å‡¦ç†
   */
  private async processCurrentStep(session: MenuSession): Promise<ProcessingResult> {
    const currentParameter = this.getCurrentParameter(session);
    
    if (!currentParameter) {
      // å…¨ãƒ‡ãƒ¼ã‚¿åé›†å®Œäº† â†’ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
      return await this.executeAction(session);
    }

    // AI ã«ã‚ˆã‚‹å‹•çš„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
    const contextualPrompt = await this.generateContextualPrompt(session, currentParameter);

    return {
      success: true,
      data: session.collectedData,
      response: {
        text: contextualPrompt.text,
        quickReplies: contextualPrompt.quickReplies,
        flexMessage: this.createProgressFlexMessage(session)
      }
    };
  }

  /**
   * AI ã«ã‚ˆã‚‹æ–‡è„ˆçš„ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆç”Ÿæˆ
   */
  private async generateContextualPrompt(
    session: MenuSession, 
    parameter: ParameterDefinition
  ): Promise<{ text: string; quickReplies: string[] }> {
    
    const context = await this.aiService.evaluateWithGemini(`
    ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæœ€é©åŒ–:
    
    ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ${session.currentAction?.label}
    ç¾åœ¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: ${parameter.name}
    åé›†æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿: ${JSON.stringify(session.collectedData)}
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ : ${session.platform}
    
    ä»¥ä¸‹ã®è¦ä»¶ã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’ç”Ÿæˆ:
    
    1. è‡ªç„¶ã§è¦ªã—ã¿ã‚„ã™ã„æ—¥æœ¬èª
    2. ${parameter.name}ã®å…¥åŠ›æ–¹æ³•ã‚’æ˜ç¢ºã«èª¬æ˜
    3. æ—¢ã«å…¥åŠ›ã•ã‚ŒãŸæƒ…å ±ã‚’è€ƒæ…®ã—ãŸæ–‡è„ˆ
    4. ${session.platform}ã«é©ã—ãŸUIè¡¨ç¾
    5. å…¥åŠ›ä¾‹ãƒ»ãƒ’ãƒ³ãƒˆã®æä¾›
    
    ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è©³ç´°:
    - åå‰: ${parameter.name}
    - ã‚¿ã‚¤ãƒ—: ${parameter.type}
    - å¿…é ˆ: ${parameter.required}
    - èª¬æ˜: ${parameter.description}
    - åˆ¶ç´„: ${parameter.constraints || 'ãªã—'}
    
    å›ç­”å½¢å¼:
    {
      "text": "ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
      "quickReplies": ["é¸æŠè‚¢1", "é¸æŠè‚¢2", "é¸æŠè‚¢3"]
    }
    `);

    try {
      return JSON.parse(context);
    } catch (error) {
      return {
        text: `${parameter.description}\n\nå…¥åŠ›ã—ã¦ãã ã•ã„ï¼š`,
        quickReplies: parameter.suggestions || []
      };
    }
  }

  /**
   * å‹å®‰å…¨ãªå…¥åŠ›æ¤œè¨¼
   */
  private async validateInput(
    parameter: ParameterDefinition,
    input: string,
    attachments?: any[]
  ): Promise<{ isValid: boolean; value?: any; error?: string }> {
    
    try {
      let processedValue = input.trim();

      // ã‚¿ã‚¤ãƒ—åˆ¥ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
      switch (parameter.type) {
        case 'date':
          const dateValue = await this.parseDate(input);
          if (!dateValue) {
            return { isValid: false, error: 'æ—¥ä»˜å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚ä¾‹: 2025-07-15, æ˜æ—¥, æ¥é€±ã®é‡‘æ›œæ—¥' };
          }
          processedValue = dateValue;
          break;

        case 'email':
          if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input)) {
            return { isValid: false, error: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“' };
          }
          break;

        case 'phone':
          const phonePattern = /^[\d\-\+\(\)\s]+$/;
          if (!phonePattern.test(input)) {
            return { isValid: false, error: 'é›»è©±ç•ªå·ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“' };
          }
          break;

        case 'number':
          const numberValue = parseFloat(input);
          if (isNaN(numberValue)) {
            return { isValid: false, error: 'æ•°å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„' };
          }
          processedValue = numberValue;
          break;

        case 'select':
          if (!parameter.options?.includes(input)) {
            return { isValid: false, error: `æ¬¡ã®é¸æŠè‚¢ã‹ã‚‰é¸ã‚“ã§ãã ã•ã„: ${parameter.options?.join(', ')}` };
          }
          break;

        case 'attachment':
          if (!attachments || attachments.length === 0) {
            return { isValid: false, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ·»ä»˜ã—ã¦ãã ã•ã„' };
          }
          processedValue = attachments[0];
          break;
      }

      // ã‚«ã‚¹ã‚¿ãƒ ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
      if (parameter.customValidator) {
        const customResult = await parameter.customValidator(processedValue);
        if (!customResult.isValid) {
          return customResult;
        }
      }

      return { isValid: true, value: processedValue };

    } catch (error) {
      return { isValid: false, error: 'å…¥åŠ›å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ' };
    }
  }

  /**
   * ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
   */
  private async executeAction(session: MenuSession): Promise<ProcessingResult> {
    if (!session.currentAction) {
      return this.createErrorResponse('ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    try {
      let result;
      
      switch (session.currentAction.type) {
        case 'TASK_CREATE':
          result = await this.createTaskFromMenu(session.collectedData, session.userId);
          break;
        case 'APPOINTMENT_CREATE':
          result = await this.createAppointmentFromMenu(session.collectedData, session.userId);
          break;
        case 'STATUS_UPDATE':
          result = await this.updateStatusFromMenu(session.collectedData, session.userId);
          break;
        case 'REPORT_REQUEST':
          result = await this.generateReportFromMenu(session.collectedData, session.userId);
          break;
        default:
          throw new Error(`æœªå¯¾å¿œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—: ${session.currentAction.type}`);
      }

      // ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†
      this.activeSessions.delete(session.userId);

      return {
        success: true,
        data: result,
        response: {
          text: this.generateSuccessMessage(session.currentAction, result),
          flexMessage: this.createSuccessFlexMessage(session.currentAction, result)
        }
      };

    } catch (error) {
      console.error('Action execution error:', error);
      return this.createErrorResponse('å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
    }
  }

  /**
   * ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤º
   */
  private async showMainMenu(userId: string): Promise<ProcessingResult> {
    const userProfile = await this.getUserProfile(userId);
    
    return {
      success: true,
      data: {},
      response: {
        text: `ã“ã‚“ã«ã¡ã¯ã€${userProfile.name}ã•ã‚“ï¼\nä½•ã‚’ãŠæ‰‹ä¼ã„ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ`,
        quickReplies: [
          'ğŸ“ ã‚¿ã‚¹ã‚¯ä½œæˆ',
          'ğŸ“… ã‚¢ãƒã‚¤ãƒ³ãƒˆç™»éŒ²', 
          'ğŸ“Š é€²æ—å ±å‘Š',
          'ğŸ“ˆ ãƒ¬ãƒãƒ¼ãƒˆå–å¾—',
          'â“ ãƒ˜ãƒ«ãƒ—'
        ],
        flexMessage: this.createMainMenuFlexMessage(userProfile)
      }
    };
  }

  /**
   * æ—¥ä»˜è§£æ (è‡ªç„¶è¨€èªå¯¾å¿œ)
   */
  private async parseDate(input: string): Promise<Date | null> {
    // åŸºæœ¬çš„ãªæ—¥ä»˜å½¢å¼ãƒã‚§ãƒƒã‚¯
    const isoDatePattern = /^\d{4}-\d{2}-\d{2}$/;
    if (isoDatePattern.test(input)) {
      return new Date(input);
    }

    // AI ã«ã‚ˆã‚‹è‡ªç„¶è¨€èªæ—¥ä»˜è§£æ
    const dateAnalysis = await this.aiService.evaluateWithGemini(`
    æ—¥ä»˜è§£æ:
    å…¥åŠ›: "${input}"
    åŸºæº–æ—¥: ${new Date().toISOString()}
    
    ä»¥ä¸‹ã®è‡ªç„¶è¨€èªè¡¨ç¾ã‚’æ­£ç¢ºãªæ—¥ä»˜ã«å¤‰æ›:
    - ä»Šæ—¥ã€æ˜æ—¥ã€æ˜å¾Œæ—¥
    - æ¥é€±ã®â—‹æ›œæ—¥ã€å†æ¥é€±ã®â—‹æ›œæ—¥
    - â—‹æœˆâ—‹æ—¥ã€â—‹/â—‹
    - â—‹æ—¥å¾Œã€â—‹é€±é–“å¾Œ
    
    ISO 8601å½¢å¼ (YYYY-MM-DD) ã§è¿”ç­”ã€‚
    è§£æã§ããªã„å ´åˆã¯ null ã‚’è¿”ç­”ã€‚
    `);

    try {
      const parsedDate = dateAnalysis.trim();
      if (parsedDate === 'null') return null;
      
      const date = new Date(parsedDate);
      return isNaN(date.getTime()) ? null : date;
    } catch {
      return null;
    }
  }

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  private getCurrentParameter(session: MenuSession): ParameterDefinition | null {
    if (!session.currentAction) return null;
    
    const allParameters = [
      ...session.currentAction.parameters.required.map(name => ({ name, required: true })),
      ...session.currentAction.parameters.optional.map(name => ({ name, required: false }))
    ];
    
    return allParameters[session.currentStep] || null;
  }

  private async createTaskFromMenu(data: Record<string, any>, userId: string): Promise<any> {
    return await this.taskService.create({
      title: data.title,
      description: data.description || '',
      assignedTo: data.assignee || userId,
      dueDate: data.dueDate,
      priority: data.priority || 'B',
      createdBy: userId,
      source: 'MENU_CREATION'
    });
  }

  private async createAppointmentFromMenu(data: Record<string, any>, userId: string): Promise<any> {
    return await this.appointmentService.create({
      contactName: data.contactName,
      companyName: data.companyName,
      email: data.email,
      phone: data.phone,
      scheduledDate: data.scheduledDate,
      purpose: data.purpose,
      status: 'scheduled',
      assignedToId: userId,
      source: 'MENU_CREATION'
    });
  }

  private createMainMenuFlexMessage(userProfile: any): any {
    return {
      type: "flex",
      altText: "ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼",
      contents: {
        type: "bubble",
        header: {
          type: "box",
          layout: "vertical",
          contents: [
            {
              type: "text",
              text: `${userProfile.name}ã•ã‚“`,
              weight: "bold",
              size: "lg"
            }
          ]
        },
        body: {
          type: "box",
          layout: "vertical",
          contents: [
            {
              type: "text",
              text: "ä½•ã‚’ãŠæ‰‹ä¼ã„ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ",
              wrap: true
            }
          ]
        },
        footer: {
          type: "box",
          layout: "vertical",
          contents: [
            {
              type: "button",
              action: {
                type: "postback",
                label: "ğŸ“ ã‚¿ã‚¹ã‚¯ä½œæˆ",
                data: "action=start_task_creation"
              }
            },
            {
              type: "button", 
              action: {
                type: "postback",
                label: "ğŸ“… ã‚¢ãƒã‚¤ãƒ³ãƒˆç™»éŒ²",
                data: "action=start_appointment_creation"
              }
            },
            {
              type: "button",
              action: {
                type: "postback", 
                label: "ğŸ“Š é€²æ—å ±å‘Š",
                data: "action=start_status_update"
              }
            }
          ]
        }
      }
    };
  }

  private generateSuccessMessage(action: MenuAction, result: any): string {
    switch (action.type) {
      case 'TASK_CREATE':
        return `âœ… ã‚¿ã‚¹ã‚¯ã€Œ${result.title}ã€ã‚’ä½œæˆã—ã¾ã—ãŸï¼`;
      case 'APPOINTMENT_CREATE':
        return `ğŸ“… ã‚¢ãƒã‚¤ãƒ³ãƒˆã€Œ${result.companyName}ã€ã‚’ç™»éŒ²ã—ã¾ã—ãŸï¼`;
      case 'STATUS_UPDATE':
        return `ğŸ“Š ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ã—ã¾ã—ãŸï¼`;
      case 'REPORT_REQUEST':
        return `ğŸ“ˆ ãƒ¬ãƒãƒ¼ãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸï¼`;
      default:
        return 'âœ… å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸï¼';
    }
  }

  private createErrorResponse(message: string): ProcessingResult {
    return {
      success: false,
      data: {},
      response: {
        text: `âŒ ${message}`,
        quickReplies: ['ğŸ  ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹', 'â“ ãƒ˜ãƒ«ãƒ—']
      }
    };
  }
}

interface ParameterDefinition {
  name: string;
  type: 'text' | 'date' | 'email' | 'phone' | 'number' | 'select' | 'attachment';
  required: boolean;
  description: string;
  prompt: string;
  suggestions?: string[];
  options?: string[];
  constraints?: string;
  customValidator?: (value: any) => Promise<{ isValid: boolean; error?: string }>;
}
```

### **4.2 å–¶æ¥­ãƒ—ãƒ­ã‚»ã‚¹è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ **

#### **4.2.1 å–¶æ¥­ã‚¹ãƒ†ãƒ¼ã‚¸è‡ªå‹•é€²è¡Œç®¡ç†**
```typescript
// src/services/SalesStageAutomator.ts
import { AI_SERVICE } from './ai-service';
import { AnomalyDetectionEngine } from './AnomalyDetectionEngine'; // Phase 3 æˆæœæ´»ç”¨

export interface SalesStage {
  id: string;
  name: string;
  description: string;
  requiredActions: string[];
  completionCriteria: {
    mandatory: string[];
    optional: string[];
    aiValidation: boolean;
  };
  automatedTriggers: {
    onEntry: string[];
    onExit: string[];
    periodic: string[];
  };
  nextStages: string[];
  averageDuration: number; // æ—¥æ•°
  successProbability: number;
}

export interface SalesOpportunity {
  id: string;
  appointmentId: string;
  customerId: string;
  currentStage: string;
  stageHistory: Array<{
    stage: string;
    enteredAt: Date;
    exitedAt?: Date;
    duration?: number;
    completionScore: number;
  }>;
  dealValue: number;
  probability: number;
  predictedCloseDate: Date;
  riskFactors: string[];
  nextActions: Array<{
    action: string;
    priority: number;
    dueDate: Date;
    assignee: string;
  }>;
  automationStatus: {
    enabled: boolean;
    lastCheck: Date;
    pendingActions: string[];
  };
}

export class SalesStageAutomator {
  private anomalyEngine: AnomalyDetectionEngine; // Phase 3 æˆæœæ´»ç”¨

  constructor(
    private aiService: typeof AI_SERVICE,
    private appointmentService: any,
    private taskService: any,
    private connectionService: any,
    private knowledgeService: any
  ) {
    this.anomalyEngine = new AnomalyDetectionEngine({
      sensitivity: 0.8,
      windowSize: 14,
      threshold: 2.5
    });
  }

  /**
   * å–¶æ¥­ã‚¹ãƒ†ãƒ¼ã‚¸è‡ªå‹•ç›£è¦–ãƒ»é€²è¡Œ
   */
  async monitorAndProgressSalesStages(): Promise<{
    processedOpportunities: number;
    stageTransitions: number;
    automatedActions: number;
    risksDetected: number;
  }> {
    
    const activeOpportunities = await this.getActiveOpportunities();
    let processedCount = 0;
    let transitionCount = 0;
    let actionCount = 0;
    let riskCount = 0;

    for (const opportunity of activeOpportunities) {
      try {
        const result = await this.processOpportunity(opportunity);
        processedCount++;
        
        if (result.stageChanged) transitionCount++;
        actionCount += result.actionsExecuted;
        if (result.risksDetected.length > 0) riskCount++;
        
        await this.updateOpportunity(opportunity.id, result);
        
      } catch (error) {
        console.error(`Error processing opportunity ${opportunity.id}:`, error);
      }
    }

    return {
      processedOpportunities: processedCount,
      stageTransitions: transitionCount,
      automatedActions: actionCount,
      risksDetected: riskCount
    };
  }

  /**
   * å€‹åˆ¥å–¶æ¥­æ¡ˆä»¶ã®å‡¦ç†
   */
  private async processOpportunity(opportunity: SalesOpportunity): Promise<{
    stageChanged: boolean;
    newStage?: string;
    actionsExecuted: number;
    risksDetected: string[];
    recommendations: string[];
  }> {
    
    const currentStage = await this.getSalesStage(opportunity.currentStage);
    const stageCompletion = await this.evaluateStageCompletion(opportunity, currentStage);
    const riskAssessment = await this.assessOpportunityRisks(opportunity);
    
    let stageChanged = false;
    let newStage: string | undefined;
    let actionsExecuted = 0;

    // ã‚¹ãƒ†ãƒ¼ã‚¸é€²è¡Œåˆ¤å®š
    if (stageCompletion.canProgress) {
      const nextStage = await this.determineNextStage(opportunity, currentStage);
      if (nextStage) {
        await this.transitionToStage(opportunity, nextStage);
        stageChanged = true;
        newStage = nextStage.id;
      }
    }

    // è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
    const automatedActions = await this.executeAutomatedActions(opportunity, currentStage);
    actionsExecuted = automatedActions.length;

    // æ¨å¥¨äº‹é …ç”Ÿæˆ
    const recommendations = await this.generateRecommendations(opportunity, stageCompletion, riskAssessment);

    return {
      stageChanged,
      newStage,
      actionsExecuted,
      risksDetected: riskAssessment.risks,
      recommendations
    };
  }

  /**
   * ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†åº¦è©•ä¾¡
   */
  private async evaluateStageCompletion(
    opportunity: SalesOpportunity, 
    stage: SalesStage
  ): Promise<{
    completionScore: number;
    canProgress: boolean;
    missingRequirements: string[];
    completedActions: string[];
  }> {
    
    const appointment = await this.appointmentService.getAppointment(opportunity.appointmentId);
    const customer = await this.connectionService.getConnection(opportunity.customerId);
    const recentTasks = await this.getRelatedTasks(opportunity.appointmentId);
    const interactions = await this.getRecentInteractions(opportunity.customerId);

    const evaluation = await this.aiService.evaluateWithGemini(`
    å–¶æ¥­ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†åº¦è©•ä¾¡:
    
    ç¾åœ¨ã‚¹ãƒ†ãƒ¼ã‚¸: ${stage.name}
    æ¡ˆä»¶æƒ…å ±:
    - æ¡ˆä»¶ä¾¡å€¤: ${opportunity.dealValue}å††
    - ç¾åœ¨ç¢ºç‡: ${opportunity.probability}%
    - äºˆæƒ³ã‚¯ãƒ­ãƒ¼ã‚ºæ—¥: ${opportunity.predictedCloseDate}
    
    é¡§å®¢æƒ…å ±:
    - ä¼æ¥­: ${customer.companyName}
    - æ¥­ç•Œ: ${customer.industry}
    - è¦æ¨¡: ${customer.employeeCount}å
    
    ã‚¹ãƒ†ãƒ¼ã‚¸è¦ä»¶:
    å¿…é ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ${stage.requiredActions.join(', ')}
    å®Œäº†åŸºæº–: ${stage.completionCriteria.mandatory.join(', ')}
    
    æœ€è¿‘ã®æ´»å‹•:
    ${recentTasks.map(task => `- ${task.title}: ${task.status}`).join('\n')}
    
    é¡§å®¢ã¨ã®ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³:
    ${interactions.slice(-5).map(interaction => 
      `- ${interaction.date}: ${interaction.type} - ${interaction.summary}`
    ).join('\n')}
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§ã‚¹ãƒ†ãƒ¼ã‚¸å®Œäº†åº¦ã‚’è©•ä¾¡:
    
    1. å¿…é ˆè¦ä»¶é”æˆåº¦:
       - å„å¿…é ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Œäº†çŠ¶æ³
       - å®Œäº†åŸºæº–ã®å……è¶³åº¦
       - ä¸è¶³ã—ã¦ã„ã‚‹è¦ç´ ã®ç‰¹å®š
    
    2. æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œæº–å‚™åº¦:
       - å¿…è¦æƒ…å ±ã®åé›†çŠ¶æ³
       - é¡§å®¢ã®æ„æ€æ±ºå®šãƒ—ãƒ­ã‚»ã‚¹ç†è§£åº¦
       - ç«¶åˆçŠ¶æ³ã®æŠŠæ¡åº¦
    
    3. ãƒªã‚¹ã‚¯è¦å› :
       - æ¡ˆä»¶åœæ»ã®ãƒªã‚¹ã‚¯
       - ç«¶åˆã«ã‚ˆã‚‹å½±éŸ¿
       - é¡§å®¢å´ã®å¤‰åŒ–ãƒ»å•é¡Œ
    
    4. é€²è¡Œæ¨å¥¨åº¦:
       - ç¾æ™‚ç‚¹ã§ã®æ¬¡ã‚¹ãƒ†ãƒ¼ã‚¸ç§»è¡Œé©æ€§
       - è¿½åŠ ã§å¿…è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³
       - æœ€é©ãªã‚¿ã‚¤ãƒŸãƒ³ã‚°åˆ¤å®š
    
    å›ç­”å½¢å¼:
    {
      "completionScore": 85,
      "canProgress": true,
      "missingRequirements": ["ä¾¡æ ¼åˆæ„", "æŠ€è¡“æ¤œè¨¼å®Œäº†"],
      "completedActions": ["è¦ä»¶å®šç¾©", "ææ¡ˆæ›¸æå‡º", "ãƒ—ãƒ¬ã‚¼ãƒ³å®Ÿæ–½"],
      "riskFactors": ["ç«¶åˆä»–ç¤¾ã®ææ¡ˆå¾…ã¡"],
      "nextStepRecommendations": ["ä¾¡æ ¼äº¤æ¸‰ã®é–‹å§‹", "æŠ€è¡“æ‹…å½“è€…ã¨ã®å€‹åˆ¥ç›¸è«‡è¨­å®š"]
    }
    `);

    const result = JSON.parse(evaluation);
    
    return {
      completionScore: result.completionScore,
      canProgress: result.canProgress && result.completionScore >= 80,
      missingRequirements: result.missingRequirements,
      completedActions: result.completedActions
    };
  }

  /**
   * å–¶æ¥­ãƒªã‚¹ã‚¯è©•ä¾¡ (Phase 3 ç•°å¸¸æ¤œçŸ¥ã‚¨ãƒ³ã‚¸ãƒ³æ´»ç”¨)
   */
  private async assessOpportunityRisks(opportunity: SalesOpportunity): Promise<{
    riskScore: number;
    risks: string[];
    recommendations: string[];
  }> {
    
    // Phase 3 ã®ç•°å¸¸æ¤œçŸ¥ã‚¨ãƒ³ã‚¸ãƒ³ã‚’æ´»ç”¨ã—ãŸå–¶æ¥­ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
    const stageTransitionHistory = opportunity.stageHistory.map(stage => ({
      timestamp: stage.enteredAt.toISOString(),
      value: stage.completionScore,
      label: stage.stage
    }));

    const anomalies = this.anomalyEngine.detectTimeSeriesAnomalies(stageTransitionHistory);
    const suspiciousPatterns = anomalies.filter(a => a.isAnomaly && a.severity !== 'low');

    const riskAnalysis = await this.aiService.evaluateWithGemini(`
    å–¶æ¥­æ¡ˆä»¶ãƒªã‚¹ã‚¯åˆ†æ:
    
    æ¡ˆä»¶åŸºæœ¬æƒ…å ±:
    - æ¡ˆä»¶ä¾¡å€¤: ${opportunity.dealValue}å††
    - ç¾åœ¨ç¢ºç‡: ${opportunity.probability}%
    - ç¾åœ¨ã‚¹ãƒ†ãƒ¼ã‚¸: ${opportunity.currentStage}
    - é–‹å§‹ã‹ã‚‰ã®çµŒé: ${this.calculateDaysSinceStart(opportunity)}æ—¥
    
    ã‚¹ãƒ†ãƒ¼ã‚¸å±¥æ­´:
    ${opportunity.stageHistory.map(stage => 
      `- ${stage.stage}: ${stage.duration || 'é€²è¡Œä¸­'}æ—¥ (å®Œäº†åº¦: ${stage.completionScore}%)`
    ).join('\n')}
    
    ç•°å¸¸æ¤œçŸ¥çµæœ:
    ${suspiciousPatterns.length > 0 ? 
      suspiciousPatterns.map(p => `- ${p.timestamp}: ${p.context.trend} (é‡è¦åº¦: ${p.severity})`).join('\n') :
      'é€šå¸¸ãƒ‘ã‚¿ãƒ¼ãƒ³å†…'
    }
    
    æ—¢å­˜ãƒªã‚¹ã‚¯è¦å› :
    ${opportunity.riskFactors.join(', ')}
    
    ãƒªã‚¹ã‚¯è©•ä¾¡è¦³ç‚¹:
    
    1. å–¶æ¥­ã‚µã‚¤ã‚¯ãƒ«ç•°å¸¸:
       - æ¨™æº–ã‚µã‚¤ã‚¯ãƒ«ã‹ã‚‰ã®é€¸è„±
       - ã‚¹ãƒ†ãƒ¼ã‚¸æ»ç•™æœŸé–“ã®ç•°å¸¸
       - é€²æ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å¤‰åŒ–
    
    2. é¡§å®¢ã‚¨ãƒ³ã‚²ãƒ¼ã‚¸ãƒ¡ãƒ³ãƒˆ:
       - ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³é »åº¦ã®å¤‰åŒ–
       - æ„æ€æ±ºå®šãƒ—ãƒ­ã‚»ã‚¹ã®åœæ»
       - ã‚­ãƒ¼ãƒ‘ãƒ¼ã‚½ãƒ³ã¨ã®æ¥è§¦çŠ¶æ³
    
    3. ç«¶åˆãƒ»å¸‚å ´è¦å› :
       - ç«¶åˆä»–ç¤¾ã®å‹•å‘
       - å¸‚å ´ç’°å¢ƒã®å¤‰åŒ–
       - é¡§å®¢æ¥­ç•Œã®çŠ¶æ³
    
    4. å†…éƒ¨è¦å› :
       - ææ¡ˆå†…å®¹ã®é©åˆæ€§
       - ä¾¡æ ¼ç«¶äº‰åŠ›
       - å®Ÿè¡Œä½“åˆ¶ã®æ•´å‚™çŠ¶æ³
    
    ãƒªã‚¹ã‚¯ã‚¹ã‚³ã‚¢ç®—å‡º (0-100, é«˜ã„ã»ã©å±é™º):
    
    å›ç­”å½¢å¼:
    {
      "riskScore": 35,
      "risks": [
        "ç«¶åˆä»–ç¤¾ã®ä¾¡æ ¼æ”»å‹¢",
        "æ„æ€æ±ºå®šã®é…å»¶",
        "æŠ€è¡“è¦ä»¶ã®æœªåˆæ„"
      ],
      "recommendations": [
        "ç«¶åˆåˆ†æã®å¼·åŒ–ã¨å·®åˆ¥åŒ–ãƒã‚¤ãƒ³ãƒˆã®æ˜ç¢ºåŒ–",
        "æ„æ€æ±ºå®šè€…ã¨ã®ç›´æ¥é¢è«‡ã®è¨­å®š", 
        "æŠ€è¡“æ¤œè¨¼ãƒ—ãƒ­ã‚»ã‚¹ã®ææ¡ˆ"
      ]
    }
    `);

    return JSON.parse(riskAnalysis);
  }

  /**
   * å¥‘ç´„å‡¦ç†å®Œå…¨è‡ªå‹•åŒ–
   */
  async processContractCompletion(
    opportunityId: string,
    contractDetails: {
      contractValue: number;
      contractType: string;
      duration: number;
      startDate: Date;
      paymentTerms: string;
      deliverables: string[];
    }
  ): Promise<{
    success: boolean;
    contractId: string;
    generatedTasks: Array<{
      id: string;
      title: string;
      assignee: string;
      dueDate: Date;
      type: string;
    }>;
    knowledgeItems: Array<{
      id: string;
      title: string;
      category: string;
    }>;
    followUpSchedule: Array<{
      date: Date;
      purpose: string;
      participants: string[];
    }>;
    notifications: string[];
  }> {
    
    const opportunity = await this.getOpportunity(opportunityId);
    const customer = await this.connectionService.getConnection(opportunity.customerId);
    
    // AI ã«ã‚ˆã‚‹åŒ…æ‹¬çš„å¥‘ç´„å¾Œå‡¦ç†è¨ˆç”»
    const processingPlan = await this.aiService.evaluateWithGemini(`
    å¥‘ç´„å‡¦ç†å®Œå…¨è‡ªå‹•åŒ–è¨ˆç”»:
    
    å¥‘ç´„æƒ…å ±:
    - å¥‘ç´„é‡‘é¡: ${contractDetails.contractValue}å††
    - å¥‘ç´„ã‚¿ã‚¤ãƒ—: ${contractDetails.contractType}
    - æœŸé–“: ${contractDetails.duration}ãƒ¶æœˆ
    - é–‹å§‹æ—¥: ${contractDetails.startDate}
    - æ”¯æ‰•ã„æ¡ä»¶: ${contractDetails.paymentTerms}
    - æˆæœç‰©: ${contractDetails.deliverables.join(', ')}
    
    é¡§å®¢æƒ…å ±:
    - ä¼æ¥­: ${customer.companyName}
    - æ¥­ç•Œ: ${customer.industry}
    - å¥‘ç´„çµŒé¨“: ${customer.contractHistory?.length || 0}ä»¶
    
    å–¶æ¥­ãƒ—ãƒ­ã‚»ã‚¹å±¥æ­´:
    ${opportunity.stageHistory.map(stage => 
      `- ${stage.stage}: ${stage.duration || 'é€²è¡Œä¸­'}æ—¥`
    ).join('\n')}
    
    è‡ªå‹•åŒ–ã™ã¹ãå‡¦ç†:
    
    1. ãƒãƒƒã‚¯ã‚ªãƒ•ã‚£ã‚¹ã‚¿ã‚¹ã‚¯ç”Ÿæˆ:
       - å¥‘ç´„æ›¸ä½œæˆãƒ»æ³•å‹™ç¢ºèª
       - è«‹æ±‚æ›¸ç™ºè¡Œãƒ»å…¥é‡‘ç®¡ç†
       - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç«‹ã¡ä¸Šã’ãƒ»ãƒãƒ¼ãƒ ç·¨æˆ
       - ã‚­ãƒƒã‚¯ã‚ªãƒ•ãƒ»é–‹å§‹æº–å‚™
       - é€²æ—ç®¡ç†ãƒ»å®šæœŸå ±å‘Š
    
    2. ãƒŠãƒ¬ãƒƒã‚¸è“„ç©:
       - å–¶æ¥­æˆåŠŸäº‹ä¾‹ã®è¨˜éŒ²
       - é¡§å®¢ç‰¹æ€§ãƒ»ãƒ‹ãƒ¼ã‚ºåˆ†æ
       - ææ¡ˆå†…å®¹ãƒ»å‹å› åˆ†æ
       - ç«¶åˆæ¯”è¼ƒãƒ»å·®åˆ¥åŒ–è¦å› 
    
    3. ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—è¨­å®š:
       - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆé€²æ—ç¢ºèª
       - é¡§å®¢æº€è¶³åº¦èª¿æŸ»
       - è¿½åŠ æ¡ˆä»¶ã®æ©Ÿä¼šæ¢ç´¢
       - å¥‘ç´„æ›´æ–°ãƒ»æ‹¡å¤§ææ¡ˆ
    
    4. ãƒãƒ¼ãƒ ãƒ»ãƒªã‚½ãƒ¼ã‚¹èª¿æ•´:
       - æœ€é©ãªãƒãƒ¼ãƒ ç·¨æˆ
       - å¿…è¦ã‚¹ã‚­ãƒ«ãƒ»äººå“¡ã®ç¢ºä¿
       - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
       - å“è³ªç®¡ç†ãƒ»ãƒªã‚¹ã‚¯å¯¾ç­–
    
    å›ç­”å½¢å¼: å…·ä½“çš„ãªã‚¿ã‚¹ã‚¯ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒ»æ‹…å½“è€…ã‚’å«ã‚€è©³ç´°JSON
    `);

    const plan = JSON.parse(processingPlan);
    
    try {
      // 1. å¥‘ç´„ãƒ¬ã‚³ãƒ¼ãƒ‰ä½œæˆ
      const contractId = await this.createContractRecord(opportunity, contractDetails);
      
      // 2. ãƒãƒƒã‚¯ã‚ªãƒ•ã‚£ã‚¹ã‚¿ã‚¹ã‚¯è‡ªå‹•ç”Ÿæˆ
      const generatedTasks = await this.generateBackOfficeTasks(plan.tasks, contractId);
      
      // 3. ãƒŠãƒ¬ãƒƒã‚¸ã‚¢ã‚¤ãƒ†ãƒ è‡ªå‹•ç”Ÿæˆ 
      const knowledgeItems = await this.generateContractKnowledge(plan.knowledge, opportunity, contractDetails);
      
      // 4. ãƒ•ã‚©ãƒ­ãƒ¼ã‚¢ãƒƒãƒ—ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š
      const followUpSchedule = await this.scheduleFollowUps(plan.followUps, opportunity.customerId);
      
      // 5. é–¢ä¿‚è€…é€šçŸ¥
      const notifications = await this.sendContractNotifications(plan.notifications, contractDetails);
      
      // 6. å–¶æ¥­æ¡ˆä»¶ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
      await this.closeOpportunity(opportunityId, contractId);

      return {
        success: true,
        contractId,
        generatedTasks,
        knowledgeItems,
        followUpSchedule,
        notifications
      };

    } catch (error) {
      console.error('Contract processing error:', error);
      return {
        success: false,
        contractId: '',
        generatedTasks: [],
        knowledgeItems: [],
        followUpSchedule: [],
        notifications: [`å¥‘ç´„å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}`]
      };
    }
  }

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  private async getActiveOpportunities(): Promise<SalesOpportunity[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯é©åˆ‡ãªãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¯ã‚¨ãƒªã‚’ä½¿ç”¨
    return [];
  }

  private calculateDaysSinceStart(opportunity: SalesOpportunity): number {
    const startDate = opportunity.stageHistory[0]?.enteredAt || new Date();
    return Math.floor((Date.now() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  }

  private async generateBackOfficeTasks(
    taskPlans: any[], 
    contractId: string
  ): Promise<Array<{
    id: string;
    title: string;
    assignee: string;
    dueDate: Date;
    type: string;
  }>> {
    
    const tasks = [];
    
    for (const plan of taskPlans) {
      const task = await this.taskService.create({
        title: plan.title,
        description: plan.description,
        assignedTo: plan.assignee,
        dueDate: new Date(plan.dueDate),
        priority: plan.priority,
        contractId: contractId,
        taskType: plan.type,
        source: 'CONTRACT_AUTOMATION'
      });
      
      tasks.push({
        id: task.id,
        title: task.title,
        assignee: task.assignedTo,
        dueDate: task.dueDate,
        type: plan.type
      });
    }
    
    return tasks;
  }
}
```

### **4.3 AIå–¶æ¥­ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ**

#### **4.3.1 é¡§å®¢åˆ†æãƒ»ææ¡ˆç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³**
```typescript
// src/services/AISalesAssistant.ts
import { SmartRecommendationEngine } from './SmartRecommendationEngine'; // Phase 3 æˆæœæ´»ç”¨

export interface CustomerInsight {
  customerId: string;
  industryAnalysis: {
    marketSize: number;
    growthRate: number;
    competitionLevel: string;
    keyTrends: string[];
  };
  companyProfile: {
    financialHealth: number; // 0-100
    digitalMaturity: number; // 0-100
    decisionMakingStyle: string;
    budgetCycle: string;
  };
  painPoints: {
    identified: string[];
    severity: Record<string, number>;
    urgency: Record<string, number>;
  };
  buyingJourney: {
    currentStage: string;
    influencers: string[];
    decisionCriteria: string[];
    timeline: string;
  };
  proposalRecommendations: {
    approach: string;
    valueProposition: string[];
    pricing: {
      strategy: string;
      suggestedRange: { min: number; max: number };
    };
    timeline: string;
  };
}

export class AISalesAssistant {
  private recommendationEngine: SmartRecommendationEngine; // Phase 3 æˆæœæ´»ç”¨

  constructor(
    private aiService: any,
    private connectionService: any,
    private appointmentService: any,
    private knowledgeService: any
  ) {
    this.recommendationEngine = new SmartRecommendationEngine();
  }

  /**
   * åŒ…æ‹¬çš„é¡§å®¢åˆ†æãƒ»ã‚¤ãƒ³ã‚µã‚¤ãƒˆç”Ÿæˆ
   */
  async generateCustomerInsights(customerId: string): Promise<CustomerInsight> {
    
    const customer = await this.connectionService.getConnection(customerId);
    const appointmentHistory = await this.getAppointmentHistory(customerId);
    const industryData = await this.getIndustryData(customer.industry);
    const similarCustomers = await this.getSimilarCustomers(customer);
    
    const analysis = await this.aiService.evaluateWithGemini(`
    åŒ…æ‹¬çš„é¡§å®¢åˆ†æãƒ»å–¶æ¥­æˆ¦ç•¥ç«‹æ¡ˆ:
    
    é¡§å®¢åŸºæœ¬æƒ…å ±:
    - ä¼æ¥­å: ${customer.companyName}
    - æ¥­ç•Œ: ${customer.industry}
    - å¾“æ¥­å“¡æ•°: ${customer.employeeCount}å
    - å¹´å•†: ${customer.annualRevenue || 'ä¸æ˜'}
    - è¨­ç«‹: ${customer.foundedYear || 'ä¸æ˜'}å¹´
    
    éå»ã®ã‚¢ãƒã‚¤ãƒ³ãƒˆå±¥æ­´:
    ${appointmentHistory.map(apt => 
      `- ${apt.date}: ${apt.purpose} (çµæœ: ${apt.outcome})`
    ).join('\n')}
    
    æ¥­ç•Œæƒ…å ±:
    - å¸‚å ´è¦æ¨¡: ${industryData.marketSize}
    - æˆé•·ç‡: ${industryData.growthRate}%
    - ä¸»è¦èª²é¡Œ: ${industryData.challenges.join(', ')}
    - ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–å‹•å‘: ${industryData.digitalTrends.join(', ')}
    
    é¡ä¼¼é¡§å®¢ã®æˆåŠŸäº‹ä¾‹:
    ${similarCustomers.map(similar => 
      `- ${similar.companyName}: ${similar.successStory}`
    ).join('\n')}
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§åŒ…æ‹¬åˆ†æ:
    
    1. æ¥­ç•Œãƒ»å¸‚å ´åˆ†æ:
       - æ¥­ç•Œã®æˆé•·æ€§ãƒ»å°†æ¥æ€§
       - ç«¶äº‰ç’°å¢ƒãƒ»å¸‚å ´ãƒã‚¸ã‚·ãƒ§ãƒ³
       - æŠ€è¡“ãƒˆãƒ¬ãƒ³ãƒ‰ãƒ»å¤‰åŒ–è¦å› 
       - è¦åˆ¶ãƒ»æ”¿ç­–ã®å½±éŸ¿
    
    2. ä¼æ¥­åˆ†æ:
       - è²¡å‹™å¥å…¨æ€§ã®æ¨å®š
       - ãƒ‡ã‚¸ã‚¿ãƒ«æˆç†Ÿåº¦ã®è©•ä¾¡
       - æ„æ€æ±ºå®šã‚¹ã‚¿ã‚¤ãƒ«ãƒ»çµ„ç¹”æ–‡åŒ–
       - äºˆç®—ã‚µã‚¤ã‚¯ãƒ«ãƒ»èª¿é”ãƒ—ãƒ­ã‚»ã‚¹
    
    3. èª²é¡Œãƒ»ãƒ‹ãƒ¼ã‚ºåˆ†æ:
       - é¡•åœ¨åŒ–ã—ã¦ã„ã‚‹èª²é¡Œ
       - æ½œåœ¨çš„ãªãƒšã‚¤ãƒ³ãƒã‚¤ãƒ³ãƒˆ
       - ç·Šæ€¥åº¦ãƒ»é‡è¦åº¦ã®è©•ä¾¡
       - è§£æ±ºã«ã‚ˆã‚‹æœŸå¾…åŠ¹æœ
    
    4. è³¼è²·ãƒ—ãƒ­ã‚»ã‚¹åˆ†æ:
       - ç¾åœ¨ã®æ¤œè¨æ®µéš
       - æ„æ€æ±ºå®šé–¢ä¸è€…ãƒ»å½±éŸ¿è€…
       - é¸å®šåŸºæº–ãƒ»è©•ä¾¡è»¸
       - å°å…¥ãƒ»å®Ÿè¡Œã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³
    
    5. ææ¡ˆæˆ¦ç•¥ç«‹æ¡ˆ:
       - æœ€é©ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒæ–¹æ³•
       - åˆºã•ã‚‹ãƒãƒªãƒ¥ãƒ¼ãƒ—ãƒ­ãƒã‚¸ã‚·ãƒ§ãƒ³
       - ä¾¡æ ¼æˆ¦ç•¥ãƒ»äº¤æ¸‰ãƒã‚¤ãƒ³ãƒˆ
       - ææ¡ˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒ»é€²ã‚æ–¹
    
    ç‰¹ã«é‡è¦ãªåˆ†æè¦ç´ :
    - ROIãƒ»åŠ¹æœæ¸¬å®šã®è€ƒãˆæ–¹
    - ç«¶åˆä»–ç¤¾ã¨ã®å·®åˆ¥åŒ–è¦å› 
    - ãƒªã‚¹ã‚¯è¦å› ãƒ»æ‡¸å¿µäº‹é …
    - é•·æœŸçš„ãªé–¢ä¿‚æ§‹ç¯‰ã®å¯èƒ½æ€§
    
    å›ç­”å½¢å¼: è©³ç´°ãªJSONæ§‹é€ 
    `);

    return JSON.parse(analysis);
  }

  /**
   * AIææ¡ˆæ›¸è‡ªå‹•ç”Ÿæˆ
   */
  async generateProposal(
    customerId: string,
    requirements: {
      projectType: string;
      budget: { min: number; max: number };
      timeline: string;
      keyRequirements: string[];
      successCriteria: string[];
    }
  ): Promise<{
    proposalId: string;
    executiveSummary: string;
    valueProposition: string[];
    solutionOverview: string;
    implementation: {
      phases: Array<{
        name: string;
        duration: string;
        deliverables: string[];
        resources: string[];
      }>;
    };
    investment: {
      breakdown: Record<string, number>;
      total: number;
      roi: {
        timeframe: string;
        expectedReturn: number;
        paybackPeriod: string;
      };
    };
    differentiators: string[];
    nextSteps: string[];
  }> {
    
    const customerInsights = await this.generateCustomerInsights(customerId);
    const industryBestPractices = await this.getIndustryBestPractices(requirements.projectType);
    const competitiveAnalysis = await this.getCompetitiveAnalysis(customerId);
    
    const proposal = await this.aiService.evaluateWithGemini(`
    AIææ¡ˆæ›¸è‡ªå‹•ç”Ÿæˆ:
    
    é¡§å®¢ã‚¤ãƒ³ã‚µã‚¤ãƒˆ:
    ${JSON.stringify(customerInsights, null, 2)}
    
    è¦ä»¶:
    - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—: ${requirements.projectType}
    - äºˆç®—: ${requirements.budget.min}-${requirements.budget.max}å††
    - ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³: ${requirements.timeline}
    - ä¸»è¦è¦ä»¶: ${requirements.keyRequirements.join(', ')}
    - æˆåŠŸåŸºæº–: ${requirements.successCriteria.join(', ')}
    
    æ¥­ç•Œãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:
    ${industryBestPractices.map(practice => 
      `- ${practice.title}: ${practice.description}`
    ).join('\n')}
    
    ç«¶åˆåˆ†æ:
    ${competitiveAnalysis.competitors.map(comp => 
      `- ${comp.name}: ${comp.strengths.join(', ')} / ${comp.weaknesses.join(', ')}`
    ).join('\n')}
    
    ä»¥ä¸‹è¦ç´ ã‚’å«ã‚€ææ¡ˆæ›¸ç”Ÿæˆ:
    
    1. ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼:
       - é¡§å®¢ã®èª²é¡Œãƒ»ç›®æ¨™ã®ç†è§£
       - ææ¡ˆã™ã‚‹ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã®æ¦‚è¦
       - æœŸå¾…ã•ã‚Œã‚‹æˆæœãƒ»åŠ¹æœ
       - æŠ•è³‡å¯¾åŠ¹æœã®è¦ç´„
    
    2. ãƒãƒªãƒ¥ãƒ¼ãƒ—ãƒ­ãƒã‚¸ã‚·ãƒ§ãƒ³:
       - é¡§å®¢å›ºæœ‰ã®ãƒšã‚¤ãƒ³ãƒã‚¤ãƒ³ãƒˆè§£æ±º
       - æ¥­ç•Œç‰¹åŒ–ã®ä¾¡å€¤æä¾›
       - ç«¶åˆã¨ã®æ˜ç¢ºãªå·®åˆ¥åŒ–
       - å®šé‡çš„ãƒ»å®šæ€§çš„ãƒ™ãƒãƒ•ã‚£ãƒƒãƒˆ
    
    3. ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³è©³ç´°:
       - æŠ€è¡“ãƒ»ã‚µãƒ¼ãƒ“ã‚¹æ§‹æˆ
       - å®Ÿè£…ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãƒ»æ–¹æ³•è«–
       - å“è³ªä¿è¨¼ãƒ»ãƒªã‚¹ã‚¯å¯¾ç­–
       - ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒ»æŸ”è»Ÿæ€§
    
    4. å®Ÿè£…è¨ˆç”»:
       - ãƒ•ã‚§ãƒ¼ã‚ºåˆ†ã‘ãƒ»ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
       - æœŸé–“ãƒ»ãƒªã‚½ãƒ¼ã‚¹è¦‹ç©ã‚‚ã‚Š
       - æˆæœç‰©ãƒ»ãƒ‡ãƒªãƒãƒ©ãƒ–ãƒ«
       - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆç®¡ç†ãƒ»ä½“åˆ¶
    
    5. æŠ•è³‡ãƒ»ROI:
       - è©³ç´°ãªã‚³ã‚¹ãƒˆå†…è¨³
       - ROIè¨ˆç®—ãƒ»åŠ¹æœæ¸¬å®š
       - ãƒšã‚¤ãƒãƒƒã‚¯æœŸé–“
       - é•·æœŸçš„ãªä¾¡å€¤å‰µé€ 
    
    6. å·®åˆ¥åŒ–è¦å› :
       - ç‹¬è‡ªã®å¼·ã¿ãƒ»ã‚±ã‚¤ãƒ‘ãƒ“ãƒªãƒ†ã‚£
       - éå»ã®æˆåŠŸäº‹ä¾‹ãƒ»å®Ÿç¸¾
       - ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ã‚·ãƒƒãƒ—ãƒ»ã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ 
       - ç¶™ç¶šçš„ãªã‚µãƒãƒ¼ãƒˆãƒ»é€²åŒ–
    
    é¡§å®¢ã®æ–‡è„ˆã«å®Œå…¨ã«åˆã‚ã›ãŸã€èª¬å¾—åŠ›ã®ã‚ã‚‹ææ¡ˆæ›¸ã‚’ç”Ÿæˆ:
    
    å›ç­”å½¢å¼: æ§‹é€ åŒ–ã•ã‚ŒãŸJSON
    `);

    const generatedProposal = JSON.parse(proposal);
    
    // ææ¡ˆæ›¸ã‚’ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
    const proposalId = await this.saveProposal(customerId, generatedProposal);
    
    return {
      proposalId,
      ...generatedProposal
    };
  }

  /**
   * äº¤æ¸‰æˆ¦ç•¥ãƒ»ã‚·ãƒŠãƒªã‚ªææ¡ˆ
   */
  async generateNegotiationStrategy(
    customerId: string,
    currentStatus: {
      stage: string;
      customerConcerns: string[];
      competitorStatus: string;
      budgetConstraints: string;
      timelineConstraints: string;
    }
  ): Promise<{
    overallStrategy: string;
    scenarios: Array<{
      scenario: string;
      probability: number;
      approach: string;
      keyMessages: string[];
      concessionPoints: string[];
      walkAwayThreshold: string;
    }>;
    preparationTasks: Array<{
      task: string;
      priority: number;
      deadline: Date;
    }>;
    riskMitigation: string[];
  }> {
    
    const customerInsights = await this.generateCustomerInsights(customerId);
    const negotiationHistory = await this.getNegotiationHistory(customerId);
    
    const strategy = await this.aiService.evaluateWithGemini(`
    äº¤æ¸‰æˆ¦ç•¥ãƒ»ã‚·ãƒŠãƒªã‚ªç­–å®š:
    
    é¡§å®¢åˆ†æçµæœ:
    ${JSON.stringify(customerInsights, null, 2)}
    
    ç¾åœ¨ã®çŠ¶æ³:
    - å–¶æ¥­ã‚¹ãƒ†ãƒ¼ã‚¸: ${currentStatus.stage}
    - é¡§å®¢ã®æ‡¸å¿µ: ${currentStatus.customerConcerns.join(', ')}
    - ç«¶åˆçŠ¶æ³: ${currentStatus.competitorStatus}
    - äºˆç®—åˆ¶ç´„: ${currentStatus.budgetConstraints}
    - ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«åˆ¶ç´„: ${currentStatus.timelineConstraints}
    
    éå»ã®äº¤æ¸‰å±¥æ­´:
    ${negotiationHistory.map(nego => 
      `- ${nego.date}: ${nego.topic} â†’ ${nego.outcome}`
    ).join('\n')}
    
    ä»¥ä¸‹ã®è¦³ç‚¹ã§äº¤æ¸‰æˆ¦ç•¥ã‚’ç­–å®š:
    
    1. å…¨ä½“æˆ¦ç•¥:
       - åŸºæœ¬çš„ãªäº¤æ¸‰ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ
       - ç›¸æ‰‹ã®æ„æ€æ±ºå®šã‚¹ã‚¿ã‚¤ãƒ«ã«åˆã‚ã›ãŸæˆ¦ç•¥
       - Win-Winã‚·ãƒŠãƒªã‚ªã®æ§‹ç¯‰
       - é–¢ä¿‚æ€§é‡è¦– vs æ¡ä»¶é‡è¦–ã®ãƒãƒ©ãƒ³ã‚¹
    
    2. ã‚·ãƒŠãƒªã‚ªåˆ¥æˆ¦ç•¥:
       - æœ€è‰¯ã‚±ãƒ¼ã‚¹: å…¨æ¡ä»¶ã§ã®åˆæ„
       - æ¨™æº–ã‚±ãƒ¼ã‚¹: ä¸€éƒ¨æ¡ä»¶èª¿æ•´ã§ã®åˆæ„
       - å›°é›£ã‚±ãƒ¼ã‚¹: å¤§å¹…è­²æ­©ãŒå¿…è¦
       - æœ€æ‚ªã‚±ãƒ¼ã‚¹: äº¤æ¸‰æ±ºè£‚ã®ãƒªã‚¹ã‚¯
    
    3. æº–å‚™ã‚¿ã‚¹ã‚¯:
       - å¿…è¦ãªæƒ…å ±åé›†ãƒ»åˆ†æ
       - ç¤¾å†…é–¢ä¿‚è€…ã¨ã®èª¿æ•´
       - è³‡æ–™ãƒ»ãƒ‡ãƒ¼ã‚¿ã®æº–å‚™
       - ä»£æ›¿æ¡ˆãƒ»ãƒ—ãƒ©ãƒ³Bã®ç­–å®š
    
    4. ãƒªã‚¹ã‚¯å¯¾ç­–:
       - æƒ³å®šã•ã‚Œã‚‹å•é¡Œãƒ»éšœå®³
       - äºˆé˜²ç­–ãƒ»å¯¾å¿œç­–
       - ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åŸºæº–
       - æ’¤é€€ãƒ©ã‚¤ãƒ³ã®è¨­å®š
    
    å®Ÿè·µçš„ã§å…·ä½“æ€§ã®ã‚ã‚‹æˆ¦ç•¥ã‚’ææ¡ˆ:
    
    å›ç­”å½¢å¼: è©³ç´°ãªJSON
    `);

    return JSON.parse(strategy);
  }

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
  private async getAppointmentHistory(customerId: string): Promise<any[]> {
    return await this.appointmentService.getByCustomerId(customerId);
  }

  private async getIndustryData(industry: string): Promise<any> {
    // æ¥­ç•Œãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯
    return {
      marketSize: 1000000000000,
      growthRate: 5.2,
      challenges: ['ãƒ‡ã‚¸ã‚¿ãƒ«åŒ–', 'äººæä¸è¶³', 'ã‚³ã‚¹ãƒˆå‰Šæ¸›'],
      digitalTrends: ['AIæ´»ç”¨', 'ã‚¯ãƒ©ã‚¦ãƒ‰åŒ–', 'ãƒªãƒ¢ãƒ¼ãƒˆãƒ¯ãƒ¼ã‚¯']
    };
  }

  private async saveProposal(customerId: string, proposal: any): Promise<string> {
    const proposalDoc = await this.knowledgeService.create({
      title: `ææ¡ˆæ›¸: ${proposal.customer?.companyName || 'Unknown'}`,
      category: 'PROPOSAL',
      content: JSON.stringify(proposal, null, 2),
      tags: ['ai_generated', 'proposal', customerId],
      customerId: customerId,
      generatedAt: new Date()
    });
    
    return proposalDoc.id;
  }
}
```

---

## ğŸ“Š **Phase 4 æˆåŠŸæŒ‡æ¨™ (ä¿®æ­£ç‰ˆ)**

### **4.1 ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIæ“ä½œç²¾åº¦**
- [ ] **æ“ä½œæˆåŠŸç‡**: 98%ä»¥ä¸Š (å‹å®‰å…¨æ€§ã«ã‚ˆã‚Šå¤§å¹…å‘ä¸Š)
- [ ] **ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ç²¾åº¦**: 95%ä»¥ä¸Š (ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–)
- [ ] **ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦**: 4.5/5.0ä»¥ä¸Š

### **4.2 å–¶æ¥­è‡ªå‹•åŒ–åŠ¹ç‡**
- [ ] **å¥‘ç´„å‡¦ç†è‡ªå‹•åŒ–ç‡**: 85%ä»¥ä¸Š
- [ ] **ãƒãƒƒã‚¯ã‚ªãƒ•ã‚£ã‚¹é€£æº**: 100%è‡ªå‹•åŒ–
- [ ] **ãƒŠãƒ¬ãƒƒã‚¸ç”Ÿæˆç‡**: å¥‘ç´„ã®95%ä»¥ä¸Š

### **4.3 AIå–¶æ¥­ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆç²¾åº¦**
- [ ] **é¡§å®¢åˆ†æç²¾åº¦**: 80%ä»¥ä¸Š
- [ ] **ææ¡ˆæ›¸å“è³ªã‚¹ã‚³ã‚¢**: 4.0/5.0ä»¥ä¸Š
- [ ] **æˆç´„ç¢ºç‡å‘ä¸Š**: 15%ä»¥ä¸Š

---

## âš ï¸ **Phase 4 æ³¨æ„äº‹é … (ä¿®æ­£ç‰ˆ)**

### **4.1 å‹å®‰å…¨æ€§ã®ç¢ºä¿**
- TypeScriptå‹å®šç¾©ã®å³å¯†ãªéµå®ˆ
- å®Ÿè¡Œæ™‚ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®å¾¹åº•
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å …ç‰¢æ€§

### **4.2 æ®µéšçš„å®Ÿè£…**
- æ—¢å­˜æ©Ÿèƒ½ã¸ã®å½±éŸ¿ã‚’æœ€å°åŒ–
- ååˆ†ãªãƒ†ã‚¹ãƒˆãƒ»æ¤œè¨¼æœŸé–“ã®ç¢ºä¿
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®ç¶™ç¶šåé›†

---

**Phase 4 å®Œäº†åŸºæº–**: ãƒ¡ãƒ‹ãƒ¥ãƒ¼UIå®‰å…¨æ€§ç¢ºä¿ã€å–¶æ¥­è‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ å®Œå…¨å‹•ä½œã€AIå–¶æ¥­ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆå®Ÿç”¨ãƒ¬ãƒ™ãƒ«é”æˆ