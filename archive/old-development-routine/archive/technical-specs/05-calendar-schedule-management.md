# ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ãƒãƒ‹ãƒ¥ã‚¢ãƒ«

## æ¦‚è¦

FIND to DO Management Appã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€çµ±åˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã€é«˜åº¦ãªãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ“ä½œã€ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«è¨­å®šã€å¤–éƒ¨é€£æºæ©Ÿèƒ½ã‚’æä¾›ã™ã‚‹åŒ…æ‹¬çš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç†ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚

## ç›®æ¬¡

1. [çµ±åˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½](#çµ±åˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½)
2. [ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½](#ãƒ‰ãƒ©ãƒƒã‚°ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½)
3. [ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«è¨­å®š](#ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«è¨­å®š)
4. [å¤–éƒ¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é€£æº](#å¤–éƒ¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é€£æº)
5. [ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–](#ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–)
6. [é€šçŸ¥ãƒ»ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼](#é€šçŸ¥ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼)
7. [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](#ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°)

---

## çµ±åˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½

### 1.1 ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ“ãƒ¥ãƒ¼

ã‚·ã‚¹ãƒ†ãƒ ã¯3ã¤ã®ä¸»è¦ãƒ“ãƒ¥ãƒ¼ã‚’æä¾›ã—ã¾ã™ï¼š

| ãƒ“ãƒ¥ãƒ¼ | èª¬æ˜ | ç”¨é€” | ç‰¹å¾´ |
|--------|------|------|------|
| **æœˆè¡¨ç¤º** | æœˆå˜ä½ã®æ¦‚è¦è¡¨ç¤º | å…¨ä½“ã®äºˆå®šæŠŠæ¡ | å¯†åº¦ã®é«˜ã„æƒ…å ±è¡¨ç¤º |
| **é€±è¡¨ç¤º** | é€±å˜ä½ã®è©³ç´°è¡¨ç¤º | æ—¥å¸¸çš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ç®¡ç† | æ™‚é–“è»¸ã§ã®è©³ç´°ç®¡ç† |
| **æ—¥è¡¨ç¤º** | æ—¥å˜ä½ã®è©³ç´°è¡¨ç¤º | å½“æ—¥ã®è©³ç´°ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« | åˆ†å˜ä½ã®ç²¾å¯†ç®¡ç† |

```javascript
// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
const CalendarView = {
  // æœˆè¡¨ç¤ºã®å®Ÿè£…
  MonthView: ({ events, currentDate, onEventClick, onDateClick }) => {
    const monthData = generateMonthData(currentDate)
    const eventsByDate = groupEventsByDate(events)
    
    return (
      <div className="calendar-month-view">
        {monthData.weeks.map(week => (
          <div key={week.id} className="calendar-week">
            {week.days.map(day => (
              <CalendarDay
                key={day.date}
                date={day.date}
                events={eventsByDate[day.date] || []}
                isToday={isToday(day.date)}
                isCurrentMonth={day.isCurrentMonth}
                onClick={() => onDateClick(day.date)}
                onEventClick={onEventClick}
              />
            ))}
          </div>
        ))}
      </div>
    )
  },
  
  // é€±è¡¨ç¤ºã®å®Ÿè£…
  WeekView: ({ events, currentWeek, timeSlots, onTimeSlotClick }) => {
    const weekDays = generateWeekDays(currentWeek)
    const eventsByDay = groupEventsByDay(events, weekDays)
    
    return (
      <div className="calendar-week-view">
        <div className="time-slots">
          {timeSlots.map(slot => (
            <div key={slot.time} className="time-slot">
              <span className="time-label">{slot.time}</span>
              {weekDays.map(day => (
                <TimeSlot
                  key={`${day}-${slot.time}`}
                  date={day}
                  time={slot.time}
                  events={getEventsForTimeSlot(eventsByDay[day], slot)}
                  onClick={() => onTimeSlotClick(day, slot.time)}
                />
              ))}
            </div>
          ))}
        </div>
      </div>
    )
  }
}
```

### 1.2 ã‚¤ãƒ™ãƒ³ãƒˆçµ±åˆç®¡ç†

```javascript
// ç•°ãªã‚‹ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆçµ±åˆ
const EventIntegrator = {
  // è¤‡æ•°ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆçµ±åˆ
  integrateEvents: async (userId, sources = ['internal', 'google', 'outlook']) => {
    const allEvents = []
    
    for (const source of sources) {
      try {
        const events = await fetchEventsFromSource(source, userId)
        const normalizedEvents = events.map(event => normalizeEvent(event, source))
        allEvents.push(...normalizedEvents)
      } catch (error) {
        console.warn(`Failed to fetch events from ${source}:`, error)
      }
    }
    
    // é‡è¤‡ã‚¤ãƒ™ãƒ³ãƒˆã®æ¤œå‡ºã¨çµ±åˆ
    const deduplicatedEvents = removeDuplicateEvents(allEvents)
    
    // ç«¶åˆæ¤œå‡º
    const conflicts = detectEventConflicts(deduplicatedEvents)
    
    return {
      events: deduplicatedEvents,
      conflicts,
      sources: sources.map(source => ({
        name: source,
        status: getSourceStatus(source),
        lastSync: getLastSyncTime(source)
      }))
    }
  },
  
  // ã‚¤ãƒ™ãƒ³ãƒˆæ­£è¦åŒ–
  normalizeEvent: (rawEvent, source) => {
    const baseEvent = {
      id: generateEventId(rawEvent.id, source),
      title: rawEvent.title || rawEvent.summary,
      description: rawEvent.description || rawEvent.body,
      startTime: new Date(rawEvent.start || rawEvent.startTime),
      endTime: new Date(rawEvent.end || rawEvent.endTime),
      source,
      originalId: rawEvent.id,
      lastModified: new Date(rawEvent.lastModified || rawEvent.updated)
    }
    
    // ã‚½ãƒ¼ã‚¹å›ºæœ‰ã®æ‹¡å¼µãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    switch (source) {
      case 'google':
        return {
          ...baseEvent,
          location: rawEvent.location,
          attendees: rawEvent.attendees || [],
          hangoutLink: rawEvent.hangoutLink
        }
      case 'outlook':
        return {
          ...baseEvent,
          location: rawEvent.location?.displayName,
          attendees: rawEvent.attendees?.map(a => a.emailAddress) || [],
          onlineMeeting: rawEvent.onlineMeeting
        }
      default:
        return baseEvent
    }
  }
}
```

### 1.3 ã‚¤ãƒ™ãƒ³ãƒˆåˆ†é¡ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// AI ã«ã‚ˆã‚‹è‡ªå‹•ã‚¤ãƒ™ãƒ³ãƒˆåˆ†é¡
const EventClassifier = {
  // ã‚¤ãƒ™ãƒ³ãƒˆã®è‡ªå‹•åˆ†é¡
  classifyEvent: async (event) => {
    const classification = await callAI({
      model: 'event-classifier',
      input: {
        title: event.title,
        description: event.description,
        attendees: event.attendees,
        location: event.location,
        duration: event.endTime - event.startTime,
        timeOfDay: event.startTime.getHours()
      }
    })
    
    return {
      category: classification.category, // MEETING, TASK, PERSONAL, etc.
      priority: classification.priority, // HIGH, MEDIUM, LOW
      type: classification.type, // WORK, PERSONAL, HEALTH, etc.
      tags: classification.suggestedTags,
      color: getCategoryColor(classification.category),
      icon: getCategoryIcon(classification.category)
    }
  },
  
  // ã‚«ãƒ†ã‚´ãƒªåˆ¥ã®è¡¨ç¤ºè¨­å®š
  categorySettings: {
    MEETING: {
      color: '#3B82F6', // Blue
      icon: 'ğŸ‘¥',
      defaultDuration: 60, // minutes
      bufferTime: 5 // minutes before/after
    },
    TASK: {
      color: '#10B981', // Green
      icon: 'âœ…',
      defaultDuration: 120,
      bufferTime: 0
    },
    PERSONAL: {
      color: '#8B5CF6', // Purple
      icon: 'ğŸ ',
      defaultDuration: 60,
      bufferTime: 10
    },
    HEALTH: {
      color: '#F59E0B', // Yellow
      icon: 'ğŸ¥',
      defaultDuration: 30,
      bufferTime: 15
    }
  }
}
```

---

## ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½

### 2.1 é«˜åº¦ãªãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å®Ÿè£…

```javascript
// åŒ…æ‹¬çš„ãªãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚·ã‚¹ãƒ†ãƒ 
const DragDropSystem = {
  // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—åˆæœŸåŒ–
  initializeDragDrop: () => {
    const dragDropConfig = {
      // ã‚¤ãƒ™ãƒ³ãƒˆã®ç§»å‹•
      moveEvent: {
        onDragStart: (event, dragData) => {
          // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹æ™‚ã®å‡¦ç†
          showDragPreview(event)
          highlightDropZones(event.category)
          storeOriginalPosition(event.id, dragData.originalPosition)
        },
        
        onDragOver: (dropZone, dragData) => {
          // ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½æ€§ã®æ¤œè¨¼
          const canDrop = validateDropZone(dragData.event, dropZone)
          if (canDrop.valid) {
            showDropIndicator(dropZone, dragData.event)
            showConflictWarnings(canDrop.conflicts)
          }
          return canDrop.valid
        },
        
        onDrop: async (dropZone, dragData) => {
          const newDateTime = calculateNewDateTime(dropZone, dragData)
          const conflicts = await checkTimeConflicts(dragData.event.id, newDateTime)
          
          if (conflicts.length > 0) {
            const resolution = await promptConflictResolution(conflicts)
            if (resolution.cancelled) {
              revertToOriginalPosition(dragData.event.id)
              return
            }
            await resolveConflicts(conflicts, resolution.strategy)
          }
          
          await updateEventDateTime(dragData.event.id, newDateTime)
          logEventMove(dragData.event.id, dragData.originalPosition, newDateTime)
        }
      },
      
      // ã‚¤ãƒ™ãƒ³ãƒˆã®ã‚µã‚¤ã‚ºå¤‰æ›´
      resizeEvent: {
        onResizeStart: (event, handle) => {
          showResizeGuides(event)
          storeOriginalDuration(event.id)
        },
        
        onResize: (event, newDuration) => {
          const conflicts = checkDurationConflicts(event, newDuration)
          if (conflicts.length > 0) {
            showResizeWarnings(conflicts)
          }
          updateEventPreview(event.id, newDuration)
        },
        
        onResizeEnd: async (event, finalDuration) => {
          await updateEventDuration(event.id, finalDuration)
          hideResizeGuides()
          logEventResize(event.id, finalDuration)
        }
      }
    }
    
    return dragDropConfig
  },
  
  // è¤‡æ•°ã‚¤ãƒ™ãƒ³ãƒˆã®ä¸€æ‹¬ç§»å‹•
  bulkMoveEvents: async (eventIds, targetDate, targetTime) => {
    const events = await getEventsByIds(eventIds)
    const moveOperations = []
    
    for (let i = 0; i < events.length; i++) {
      const event = events[i]
      const newStartTime = new Date(targetDate)
      newStartTime.setHours(targetTime.hours + (i * event.duration / 60))
      
      moveOperations.push({
        eventId: event.id,
        originalTime: event.startTime,
        newStartTime,
        newEndTime: new Date(newStartTime.getTime() + event.duration * 60000)
      })
    }
    
    // ç«¶åˆãƒã‚§ãƒƒã‚¯
    const allConflicts = await checkBulkMoveConflicts(moveOperations)
    
    if (allConflicts.length > 0) {
      const resolution = await promptBulkConflictResolution(allConflicts)
      if (resolution.cancelled) return false
      
      await resolveBulkConflicts(allConflicts, resolution)
    }
    
    // ä¸€æ‹¬ç§»å‹•å®Ÿè¡Œ
    await executeBulkMove(moveOperations)
    return true
  }
}
```

### 2.2 ã‚¹ãƒãƒ¼ãƒˆé…ç½®ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// AI ã«ã‚ˆã‚‹æœ€é©ãªæ™‚é–“é…ç½®
const SmartScheduling = {
  // æœ€é©ãªæ™‚é–“æ ã®ææ¡ˆ
  suggestOptimalTime: async (eventRequest) => {
    const constraints = {
      duration: eventRequest.duration,
      preferences: eventRequest.preferences || {},
      attendees: eventRequest.attendees || [],
      category: eventRequest.category,
      priority: eventRequest.priority
    }
    
    const availableSlots = await findAvailableTimeSlots(constraints)
    const scoredSlots = await scoreTimeSlots(availableSlots, constraints)
    
    return {
      recommendedSlots: scoredSlots.slice(0, 3),
      reasoning: generateSchedulingReasoning(scoredSlots[0]),
      alternatives: scoredSlots.slice(3, 6),
      conflicts: await identifyPotentialConflicts(scoredSlots[0])
    }
  },
  
  // æ™‚é–“æ ã®ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
  scoreTimeSlots: async (slots, constraints) => {
    const scoredSlots = []
    
    for (const slot of slots) {
      const score = await calculateSlotScore(slot, constraints)
      scoredSlots.push({
        ...slot,
        score: score.totalScore,
        factors: score.factors
      })
    }
    
    return scoredSlots.sort((a, b) => b.score - a.score)
  },
  
  // ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
  calculateSlotScore: async (slot, constraints) => {
    const factors = {
      // æ™‚é–“å¸¯ã®é©æ€§ï¼ˆæœå‹ãƒ»å¤œå‹ãªã©ï¼‰
      timePreference: calculateTimePreferenceScore(slot.startTime, constraints.preferences),
      
      // ä»–ã®ã‚¤ãƒ™ãƒ³ãƒˆã¨ã®é–“éš”
      bufferTime: calculateBufferScore(slot, constraints.duration),
      
      // å‚åŠ è€…ã®éƒ½åˆ
      attendeeAvailability: await calculateAttendeeScore(slot, constraints.attendees),
      
      // ã‚«ãƒ†ã‚´ãƒªåˆ¥ã®æœ€é©æ€§
      categoryFit: calculateCategoryScore(slot, constraints.category),
      
      // å„ªå…ˆåº¦ã®è€ƒæ…®
      priorityWeight: calculatePriorityWeight(constraints.priority),
      
      // ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒ¬ãƒ™ãƒ«
      energyLevel: calculateEnergyScore(slot.startTime, constraints.category)
    }
    
    const weights = {
      timePreference: 0.25,
      bufferTime: 0.20,
      attendeeAvailability: 0.25,
      categoryFit: 0.15,
      priorityWeight: 0.10,
      energyLevel: 0.05
    }
    
    const totalScore = Object.entries(factors)
      .reduce((sum, [factor, score]) => sum + (score * weights[factor]), 0)
    
    return { totalScore, factors }
  }
}
```

---

## ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«è¨­å®š

### 3.1 é«˜åº¦ãªç¹°ã‚Šè¿”ã—ãƒ‘ã‚¿ãƒ¼ãƒ³

```javascript
// åŒ…æ‹¬çš„ãªç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«ç®¡ç†
const RecurrenceManager = {
  // ç¹°ã‚Šè¿”ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®šç¾©
  patterns: {
    DAILY: {
      name: 'æ¯æ—¥',
      generate: (startDate, interval = 1, count = null, until = null) => {
        const dates = []
        let currentDate = new Date(startDate)
        let iteration = 0
        
        while (
          (count === null || iteration < count) &&
          (until === null || currentDate <= until)
        ) {
          dates.push(new Date(currentDate))
          currentDate.setDate(currentDate.getDate() + interval)
          iteration++
        }
        
        return dates
      }
    },
    
    WEEKLY: {
      name: 'æ¯é€±',
      generate: (startDate, interval = 1, daysOfWeek = null, count = null, until = null) => {
        const dates = []
        let currentDate = new Date(startDate)
        let iteration = 0
        
        while (
          (count === null || iteration < count) &&
          (until === null || currentDate <= until)
        ) {
          if (daysOfWeek === null || daysOfWeek.includes(currentDate.getDay())) {
            dates.push(new Date(currentDate))
            iteration++
          }
          currentDate.setDate(currentDate.getDate() + 1)
        }
        
        return dates
      }
    },
    
    MONTHLY: {
      name: 'æ¯æœˆ',
      generate: (startDate, interval = 1, dayOfMonth = null, weekOfMonth = null, dayOfWeek = null) => {
        // è¤‡é›‘ãªæœˆæ¬¡ç¹°ã‚Šè¿”ã—ãƒ­ã‚¸ãƒƒã‚¯
        const dates = []
        let currentDate = new Date(startDate)
        
        // æœˆã®ç‰¹å®šæ—¥ï¼ˆä¾‹ï¼šæ¯æœˆ15æ—¥ï¼‰
        if (dayOfMonth !== null) {
          return generateMonthlyByDay(startDate, interval, dayOfMonth)
        }
        
        // æœˆã®ç‰¹å®šé€±ã®ç‰¹å®šæ›œæ—¥ï¼ˆä¾‹ï¼šç¬¬2ç«æ›œæ—¥ï¼‰
        if (weekOfMonth !== null && dayOfWeek !== null) {
          return generateMonthlyByWeekDay(startDate, interval, weekOfMonth, dayOfWeek)
        }
        
        return dates
      }
    },
    
    CUSTOM: {
      name: 'ã‚«ã‚¹ã‚¿ãƒ ',
      generate: (startDate, customRule) => {
        // ã‚«ã‚¹ã‚¿ãƒ ãƒ«ãƒ¼ãƒ«ã®è§£æã¨å®Ÿè¡Œ
        return parseAndExecuteCustomRule(startDate, customRule)
      }
    }
  },
  
  // ç¹°ã‚Šè¿”ã—ã‚¤ãƒ™ãƒ³ãƒˆã®ä½œæˆ
  createRecurringEvent: async (eventData, recurrenceRule) => {
    const baseEvent = await createEvent(eventData)
    const occurrenceDates = RecurrenceManager.patterns[recurrenceRule.pattern]
      .generate(eventData.startTime, ...recurrenceRule.parameters)
    
    const occurrences = []
    
    for (const date of occurrenceDates) {
      const occurrence = {
        ...eventData,
        id: generateOccurrenceId(baseEvent.id, date),
        parentEventId: baseEvent.id,
        startTime: date,
        endTime: new Date(date.getTime() + (eventData.endTime - eventData.startTime)),
        isRecurring: true,
        recurrenceRule
      }
      
      occurrences.push(occurrence)
    }
    
    await saveEventOccurrences(occurrences)
    
    return {
      baseEvent,
      occurrences,
      totalCount: occurrences.length
    }
  }
}
```

### 3.2 ä¾‹å¤–å‡¦ç†ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// ç¹°ã‚Šè¿”ã—ã‚¤ãƒ™ãƒ³ãƒˆã®ä¾‹å¤–ç®¡ç†
const RecurrenceExceptionManager = {
  // å˜ç™ºã®å¤‰æ›´
  modifyOccurrence: async (occurrenceId, changes) => {
    const occurrence = await getEventOccurrence(occurrenceId)
    
    if (changes.timeChange) {
      // æ™‚é–“å¤‰æ›´ã®ä¾‹å¤–
      await createTimeException(occurrence, changes.newTime)
    }
    
    if (changes.dataChange) {
      // ãƒ‡ãƒ¼ã‚¿å¤‰æ›´ã®ä¾‹å¤–
      await createDataException(occurrence, changes.newData)
    }
    
    if (changes.cancellation) {
      // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ä¾‹å¤–
      await createCancellationException(occurrence)
    }
    
    // ä¾‹å¤–ã®è¨˜éŒ²
    await recordRecurrenceException({
      parentEventId: occurrence.parentEventId,
      occurrenceDate: occurrence.startTime,
      exceptionType: determineExceptionType(changes),
      changes,
      timestamp: new Date()
    })
  },
  
  // ä»¥é™ã™ã¹ã¦ã®å¤‰æ›´
  modifyFutureOccurrences: async (fromOccurrenceId, changes) => {
    const fromOccurrence = await getEventOccurrence(fromOccurrenceId)
    const futureOccurrences = await getFutureOccurrences(fromOccurrence)
    
    // ãƒãƒƒãƒæ›´æ–°
    await batchUpdateOccurrences(futureOccurrences, changes)
    
    // æ–°ã—ã„ç¹°ã‚Šè¿”ã—ãƒ«ãƒ¼ãƒ«ã®ä½œæˆ
    if (changes.recurrenceChange) {
      await splitRecurrenceSeries(fromOccurrence, changes.newRecurrenceRule)
    }
  },
  
  // ç¹°ã‚Šè¿”ã—ç³»åˆ—ã®åˆ†å‰²
  splitRecurrenceSeries: async (splitPoint, newRule) => {
    const originalSeries = await getRecurrenceSeries(splitPoint.parentEventId)
    
    // å…ƒã®ç³»åˆ—ã®çµ‚äº†
    await endRecurrenceSeries(originalSeries.id, splitPoint.startTime)
    
    // æ–°ã—ã„ç³»åˆ—ã®é–‹å§‹
    const newSeries = await createRecurrenceSeries({
      ...originalSeries,
      startDate: splitPoint.startTime,
      recurrenceRule: newRule
    })
    
    return newSeries
  }
}
```

---

## å¤–éƒ¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼é€£æº

### 4.1 Google Calendaré€£æº

```javascript
// Google Calendar ã¨ã®åŒæœŸ
const GoogleCalendarSync = {
  // èªè¨¼è¨­å®š
  authenticate: async (userId) => {
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET,
      process.env.GOOGLE_REDIRECT_URI
    )
    
    const authUrl = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: ['https://www.googleapis.com/auth/calendar']
    })
    
    return authUrl
  },
  
  // ã‚¤ãƒ™ãƒ³ãƒˆåŒæœŸ
  syncEvents: async (userId, direction = 'bidirectional') => {
    const credentials = await getUserGoogleCredentials(userId)
    const oauth2Client = new google.auth.OAuth2()
    oauth2Client.setCredentials(credentials)
    
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client })
    
    if (direction === 'import' || direction === 'bidirectional') {
      await importFromGoogle(calendar, userId)
    }
    
    if (direction === 'export' || direction === 'bidirectional') {
      await exportToGoogle(calendar, userId)
    }
    
    await updateLastSyncTime(userId, 'google', new Date())
  },
  
  // Googleã‹ã‚‰ã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
  importFromGoogle: async (calendar, userId) => {
    const response = await calendar.events.list({
      calendarId: 'primary',
      timeMin: new Date().toISOString(),
      maxResults: 2500,
      singleEvents: true,
      orderBy: 'startTime'
    })
    
    const googleEvents = response.data.items
    
    for (const googleEvent of googleEvents) {
      const existingEvent = await findEventByGoogleId(googleEvent.id)
      
      if (existingEvent) {
        // æ›´æ–°ãƒã‚§ãƒƒã‚¯
        if (new Date(googleEvent.updated) > existingEvent.lastModified) {
          await updateEventFromGoogle(existingEvent.id, googleEvent)
        }
      } else {
        // æ–°è¦ä½œæˆ
        await createEventFromGoogle(googleEvent, userId)
      }
    }
  },
  
  // Googleã¸ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
  exportToGoogle: async (calendar, userId) => {
    const localEvents = await getModifiedLocalEvents(userId)
    
    for (const localEvent of localEvents) {
      if (localEvent.googleId) {
        // æ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã®æ›´æ–°
        await calendar.events.update({
          calendarId: 'primary',
          eventId: localEvent.googleId,
          resource: convertToGoogleEvent(localEvent)
        })
      } else {
        // æ–°è¦ã‚¤ãƒ™ãƒ³ãƒˆã®ä½œæˆ
        const response = await calendar.events.insert({
          calendarId: 'primary',
          resource: convertToGoogleEvent(localEvent)
        })
        
        // Google IDã®ä¿å­˜
        await updateLocalEvent(localEvent.id, {
          googleId: response.data.id
        })
      }
    }
  }
}
```

### 4.2 Outlook Calendaré€£æº

```javascript
// Microsoft Outlook ã¨ã®åŒæœŸ
const OutlookCalendarSync = {
  // Microsoft Graph APIèªè¨¼
  authenticate: async (userId) => {
    const clientApp = msal.ConfidentialClientApplication({
      auth: {
        clientId: process.env.OUTLOOK_CLIENT_ID,
        clientSecret: process.env.OUTLOOK_CLIENT_SECRET,
        authority: process.env.OUTLOOK_AUTHORITY
      }
    })
    
    const authCodeUrlParameters = {
      scopes: ['https://graph.microsoft.com/calendars.readwrite'],
      redirectUri: process.env.OUTLOOK_REDIRECT_URI
    }
    
    return await clientApp.getAuthCodeUrl(authCodeUrlParameters)
  },
  
  // Graph API ã‚’ä½¿ç”¨ã—ãŸã‚¤ãƒ™ãƒ³ãƒˆåŒæœŸ
  syncEvents: async (userId, accessToken) => {
    const graphClient = Client.init({
      authProvider: (done) => {
        done(null, accessToken)
      }
    })
    
    // Outlookã‹ã‚‰ã®ã‚¤ãƒ™ãƒ³ãƒˆå–å¾—
    const events = await graphClient
      .api('/me/events')
      .select('id,subject,body,start,end,location,attendees,isRecurring,recurrence')
      .top(1000)
      .get()
    
    for (const outlookEvent of events.value) {
      await processOutlookEvent(outlookEvent, userId)
    }
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆã®Outlookã¸ã®åŒæœŸ
    await syncLocalEventsToOutlook(graphClient, userId)
  },
  
  // Webhookã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸ
  setupWebhook: async (userId, accessToken) => {
    const subscription = {
      changeType: 'created,updated,deleted',
      notificationUrl: `${process.env.BASE_URL}/api/webhooks/outlook`,
      resource: '/me/events',
      expirationDateTime: new Date(Date.now() + 4230 * 60 * 1000) // ç´„3æ—¥
    }
    
    const graphClient = Client.init({
      authProvider: (done) => done(null, accessToken)
    })
    
    const response = await graphClient
      .api('/subscriptions')
      .post(subscription)
    
    // ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³æƒ…å ±ã®ä¿å­˜
    await saveWebhookSubscription(userId, 'outlook', response)
    
    return response
  }
}
```

### 4.3 CalDAV/CardDAVé€£æº

```javascript
// æ¨™æº–çš„ãªCalDAVé€£æº
const CalDAVSync = {
  // CalDAVã‚µãƒ¼ãƒãƒ¼ã¨ã®æ¥ç¶š
  connect: async (serverConfig) => {
    const dav = new DAVClient({
      serverUrl: serverConfig.url,
      credentials: {
        username: serverConfig.username,
        password: serverConfig.password
      }
    })
    
    await dav.login()
    return dav
  },
  
  // ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€è¦§ã®å–å¾—
  getCalendars: async (davClient) => {
    const calendars = await davClient.fetchCalendars()
    
    return calendars.map(cal => ({
      id: cal.url,
      name: cal.displayName,
      description: cal.description,
      color: cal.calendarColor,
      timezone: cal.timezone
    }))
  },
  
  // ã‚¤ãƒ™ãƒ³ãƒˆã®åŒæœŸ
  syncCalDAVEvents: async (davClient, calendarUrl) => {
    const events = await davClient.fetchCalendarObjects({
      calendar: { url: calendarUrl }
    })
    
    for (const event of events) {
      const icalData = event.calendarData
      const parsedEvent = parseICalEvent(icalData)
      
      await upsertCalDAVEvent(parsedEvent, event.url)
    }
  },
  
  // iCalãƒ‡ãƒ¼ã‚¿ã®è§£æ
  parseICalEvent: (icalData) => {
    const parsed = ICAL.parse(icalData)
    const comp = new ICAL.Component(parsed)
    const vevent = comp.getFirstSubcomponent('vevent')
    
    return {
      uid: vevent.getFirstPropertyValue('uid'),
      summary: vevent.getFirstPropertyValue('summary'),
      description: vevent.getFirstPropertyValue('description'),
      dtstart: vevent.getFirstPropertyValue('dtstart').toJSDate(),
      dtend: vevent.getFirstPropertyValue('dtend').toJSDate(),
      location: vevent.getFirstPropertyValue('location'),
      rrule: vevent.getFirstPropertyValue('rrule')
    }
  }
}
```

---

## ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–

### 5.1 AIé§†å‹•ã®æ™‚é–“æœ€é©åŒ–

```javascript
// AI ã«ã‚ˆã‚‹åŒ…æ‹¬çš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–
const ScheduleOptimizer = {
  // æ—¥æ¬¡ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–
  optimizeDailySchedule: async (userId, date) => {
    const userProfile = await getUserScheduleProfile(userId)
    const events = await getDayEvents(userId, date)
    const preferences = userProfile.preferences
    
    const optimization = await callAI({
      model: 'schedule-optimizer',
      input: {
        events,
        preferences,
        constraints: userProfile.constraints,
        energyPattern: userProfile.energyPattern,
        productivityPeaks: userProfile.productivityPeaks
      }
    })
    
    return {
      optimizedSchedule: optimization.rearrangedEvents,
      improvements: optimization.identifiedImprovements,
      efficiencyGain: optimization.projectedEfficiencyGain,
      recommendations: optimization.schedulingRecommendations
    }
  },
  
  // é€±é–“ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æœ€é©åŒ–
  optimizeWeeklySchedule: async (userId, weekStart) => {
    const weekEvents = await getWeekEvents(userId, weekStart)
    const workloadAnalysis = await analyzeWorkload(weekEvents)
    
    if (workloadAnalysis.isOverloaded) {
      return await redistributeWorkload(weekEvents, workloadAnalysis)
    }
    
    const optimization = await callAI({
      model: 'weekly-scheduler',
      input: {
        weekEvents,
        workloadMetrics: workloadAnalysis,
        recurringObligations: await getRecurringObligations(userId),
        deadlines: await getUpcomingDeadlines(userId),
        goals: await getUserGoals(userId)
      }
    })
    
    return optimization
  },
  
  // è‡ªå‹•æ™‚é–“ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°
  autoTimeBlocking: async (userId, tasks, duration = 'week') => {
    const availableSlots = await findAvailableTimeSlots(userId, duration)
    const taskPriorities = await calculateTaskPriorities(tasks)
    const userPreferences = await getUserPreferences(userId)
    
    const blocking = await callAI({
      model: 'time-blocker',
      input: {
        tasks: taskPriorities,
        availableSlots,
        preferences: userPreferences,
        constraints: await getSchedulingConstraints(userId)
      }
    })
    
    const timeBlocks = blocking.suggestedBlocks.map(block => ({
      taskId: block.taskId,
      startTime: block.startTime,
      endTime: block.endTime,
      bufferTime: block.recommendedBuffer,
      flexibility: block.flexibilityScore
    }))
    
    return {
      timeBlocks,
      unscheduledTasks: blocking.unschedulableTasks,
      efficiencyScore: blocking.overallEfficiency,
      conflicts: blocking.potentialConflicts
    }
  }
}
```

### 5.2 è² è·åˆ†æ•£ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

```javascript
// ä½œæ¥­è² è·ã®å‡ç­‰åˆ†æ•£
const WorkloadBalancer = {
  // è² è·åˆ†æ
  analyzeWorkload: (events, period = 'week') => {
    const workloadByDay = {}
    const workloadByHour = {}
    
    for (const event of events) {
      const dayKey = event.startTime.toDateString()
      const hourKey = event.startTime.getHours()
      
      // æ—¥æ¬¡è² è·
      if (!workloadByDay[dayKey]) {
        workloadByDay[dayKey] = 0
      }
      workloadByDay[dayKey] += event.duration || 60
      
      // æ™‚é–“åˆ¥è² è·
      if (!workloadByHour[hourKey]) {
        workloadByHour[hourKey] = 0
      }
      workloadByHour[hourKey] += event.duration || 60
    }
    
    return {
      totalWorkload: Object.values(workloadByDay).reduce((sum, load) => sum + load, 0),
      dailyDistribution: workloadByDay,
      hourlyDistribution: workloadByHour,
      peakDay: findPeakDay(workloadByDay),
      peakHour: findPeakHour(workloadByHour),
      balanceScore: calculateBalanceScore(workloadByDay)
    }
  },
  
  // è² è·å†åˆ†æ•£ã®ææ¡ˆ
  rebalanceWorkload: async (events, maxDailyLoad = 480) => { // 8æ™‚é–“
    const analysis = WorkloadBalancer.analyzeWorkload(events)
    const overloadedDays = Object.entries(analysis.dailyDistribution)
      .filter(([day, load]) => load > maxDailyLoad)
    
    if (overloadedDays.length === 0) {
      return { balanced: true, events }
    }
    
    const rebalancingPlan = []
    
    for (const [overloadedDay, load] of overloadedDays) {
      const excessLoad = load - maxDailyLoad
      const flexibleEvents = events.filter(e => 
        e.startTime.toDateString() === overloadedDay && 
        e.flexible === true
      )
      
      let redistributedLoad = 0
      for (const event of flexibleEvents) {
        if (redistributedLoad >= excessLoad) break
        
        const alternativeDays = await findAlternativeDays(event, analysis)
        if (alternativeDays.length > 0) {
          rebalancingPlan.push({
            eventId: event.id,
            currentDay: overloadedDay,
            suggestedDay: alternativeDays[0],
            reason: 'Load balancing'
          })
          redistributedLoad += event.duration
        }
      }
    }
    
    return {
      balanced: false,
      rebalancingPlan,
      projectedBalance: calculateProjectedBalance(events, rebalancingPlan)
    }
  }
}
```

---

## é€šçŸ¥ãƒ»ãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼

### 6.1 ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆé€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// AI é§†å‹•ã®é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
const NotificationSystem = {
  // é€šçŸ¥ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã®æœ€é©åŒ–
  optimizeNotificationTiming: async (event, userId) => {
    const userProfile = await getUserNotificationProfile(userId)
    const eventImportance = await calculateEventImportance(event)
    
    const timing = await callAI({
      model: 'notification-optimizer',
      input: {
        event,
        userProfile,
        importance: eventImportance,
        currentContext: await getCurrentUserContext(userId),
        historicalResponse: await getNotificationResponseHistory(userId)
      }
    })
    
    return {
      optimalTiming: timing.recommendedTimes,
      channels: timing.preferredChannels,
      urgency: timing.urgencyLevel,
      customMessage: timing.personalizedMessage
    }
  },
  
  // å¤šæ®µéšãƒªãƒã‚¤ãƒ³ãƒ€ãƒ¼
  setupTieredReminders: async (event, userId) => {
    const importance = await calculateEventImportance(event)
    const userPrefs = await getUserReminderPreferences(userId)
    
    const reminderTiers = []
    
    // é‡è¦åº¦ã«åŸºã¥ãæ®µéšè¨­å®š
    switch (importance.level) {
      case 'CRITICAL':
        reminderTiers.push(
          { timing: '1week', channel: 'email', message: 'advance_notice' },
          { timing: '1day', channel: 'push', message: 'final_reminder' },
          { timing: '1hour', channel: 'push', message: 'urgent_reminder' },
          { timing: '15min', channel: 'push', message: 'immediate_reminder' }
        )
        break
      case 'HIGH':
        reminderTiers.push(
          { timing: '1day', channel: 'push', message: 'day_before' },
          { timing: '1hour', channel: 'push', message: 'hour_before' },
          { timing: '15min', channel: 'push', message: 'final_reminder' }
        )
        break
      case 'MEDIUM':
        reminderTiers.push(
          { timing: '1day', channel: 'push', message: 'day_before' },
          { timing: '30min', channel: 'push', message: 'final_reminder' }
        )
        break
      default:
        reminderTiers.push(
          { timing: '1hour', channel: 'push', message: 'hour_before' }
        )
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã«ã‚ˆã‚‹èª¿æ•´
    const customizedReminders = reminderTiers.map(tier => ({
      ...tier,
      channel: userPrefs.preferredChannels.includes(tier.channel) ? 
        tier.channel : userPrefs.preferredChannels[0],
      message: personalizeMessage(tier.message, event, userId)
    }))
    
    return await scheduleReminders(event.id, customizedReminders)
  },
  
  // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆèªè­˜é€šçŸ¥
  sendContextAwareNotification: async (notification, userId) => {
    const currentContext = await getCurrentUserContext(userId)
    
    // ç¾åœ¨ã®çŠ¶æ³ã‚’è€ƒæ…®ã—ãŸé€šçŸ¥ã®èª¿æ•´
    if (currentContext.inMeeting) {
      // ä¼šè­°ä¸­ã¯ç·Šæ€¥åº¦ã®é«˜ã„ã‚‚ã®ã®ã¿
      if (notification.urgency < 4) {
        await postponeNotification(notification, '30min')
        return
      }
    }
    
    if (currentContext.doNotDisturb) {
      // é‚ªé­”ã—ãªã„ãƒ¢ãƒ¼ãƒ‰
      await queueNotificationForLater(notification)
      return
    }
    
    if (currentContext.lowBattery && notification.channel === 'push') {
      // ãƒãƒƒãƒ†ãƒªãƒ¼ä½ä¸‹æ™‚ã¯SMSã«åˆ‡ã‚Šæ›¿ãˆ
      notification.channel = 'sms'
    }
    
    await deliverNotification(notification, userId)
  }
}
```

### 6.2 ãƒãƒ«ãƒãƒãƒ£ãƒãƒ«é€šçŸ¥

```javascript
// è¤‡æ•°ãƒãƒ£ãƒãƒ«ã§ã®é€šçŸ¥é…ä¿¡
const MultiChannelNotifier = {
  // åˆ©ç”¨å¯èƒ½ãƒãƒ£ãƒãƒ«
  channels: {
    PUSH: {
      handler: async (message, userId) => {
        const devices = await getUserDevices(userId)
        for (const device of devices) {
          await sendPushNotification(device.token, message)
        }
      },
      reliability: 0.85,
      latency: 'immediate'
    },
    
    EMAIL: {
      handler: async (message, userId) => {
        const user = await getUser(userId)
        await sendEmail({
          to: user.email,
          subject: message.subject,
          body: message.body,
          template: message.template
        })
      },
      reliability: 0.95,
      latency: 'delayed'
    },
    
    SMS: {
      handler: async (message, userId) => {
        const user = await getUser(userId)
        if (user.phoneNumber) {
          await sendSMS(user.phoneNumber, message.text)
        }
      },
      reliability: 0.98,
      latency: 'immediate'
    },
    
    WEBHOOK: {
      handler: async (message, userId) => {
        const webhooks = await getUserWebhooks(userId)
        for (const webhook of webhooks) {
          await callWebhook(webhook.url, message)
        }
      },
      reliability: 0.75,
      latency: 'immediate'
    }
  },
  
  // æœ€é©ãƒãƒ£ãƒãƒ«é¸æŠ
  selectOptimalChannel: async (notification, userId) => {
    const userPrefs = await getUserNotificationPreferences(userId)
    const channelStatus = await getChannelStatus(userId)
    
    const availableChannels = Object.keys(this.channels)
      .filter(channel => 
        userPrefs.enabledChannels.includes(channel) &&
        channelStatus[channel].available
      )
    
    // ç·Šæ€¥åº¦ã¨ãƒãƒ£ãƒãƒ«ç‰¹æ€§ã®ãƒãƒƒãƒãƒ³ã‚°
    if (notification.urgency >= 4) {
      // ç·Šæ€¥æ™‚ã¯å³æ™‚æ€§ã‚’é‡è¦–
      return availableChannels
        .filter(ch => this.channels[ch].latency === 'immediate')
        .sort((a, b) => this.channels[b].reliability - this.channels[a].reliability)[0]
    }
    
    // é€šå¸¸æ™‚ã¯è¨­å®šã«å¾“ã†
    return userPrefs.preferredChannel
  },
  
  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é…ä¿¡
  sendWithFallback: async (notification, userId) => {
    const primaryChannel = await this.selectOptimalChannel(notification, userId)
    
    try {
      await this.channels[primaryChannel].handler(notification, userId)
      await logNotificationDelivery(notification.id, primaryChannel, 'success')
    } catch (error) {
      console.warn(`Primary channel ${primaryChannel} failed:`, error)
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒãƒ£ãƒãƒ«ã®è©¦è¡Œ
      const fallbackChannels = await getFallbackChannels(userId, primaryChannel)
      
      for (const channel of fallbackChannels) {
        try {
          await this.channels[channel].handler(notification, userId)
          await logNotificationDelivery(notification.id, channel, 'fallback_success')
          break
        } catch (fallbackError) {
          console.warn(`Fallback channel ${channel} failed:`, fallbackError)
        }
      }
    }
  }
}
```

---

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### 7.1 åŒæœŸå•é¡Œã®è§£æ±º

```javascript
// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼åŒæœŸã®å•é¡Œè¨ºæ–­ãƒ»ä¿®å¾©
const SyncTroubleshooter = {
  // åŒæœŸå•é¡Œã®è¨ºæ–­
  diagnoseSyncIssues: async (userId) => {
    const issues = []
    
    // èªè¨¼çŠ¶æ…‹ã®ãƒã‚§ãƒƒã‚¯
    const authStatus = await checkAuthenticationStatus(userId)
    if (!authStatus.valid) {
      issues.push({
        type: 'AUTHENTICATION',
        severity: 'HIGH',
        message: 'å¤–éƒ¨ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®èªè¨¼ãŒç„¡åŠ¹ã§ã™',
        solution: 'ã‚¢ã‚«ã‚¦ãƒ³ãƒˆè¨­å®šã§å†èªè¨¼ã‚’è¡Œã£ã¦ãã ã•ã„'
      })
    }
    
    // åŒæœŸé–“éš”ã®ãƒã‚§ãƒƒã‚¯
    const lastSync = await getLastSyncTime(userId)
    const syncInterval = await getSyncInterval(userId)
    const expectedNextSync = new Date(lastSync.getTime() + syncInterval)
    
    if (new Date() > expectedNextSync) {
      issues.push({
        type: 'SYNC_DELAY',
        severity: 'MEDIUM',
        message: 'åŒæœŸãŒé…å»¶ã—ã¦ã„ã¾ã™',
        solution: 'æ‰‹å‹•åŒæœŸã‚’è©¦ã™ã‹ã€åŒæœŸè¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„'
      })
    }
    
    // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®ãƒã‚§ãƒƒã‚¯
    const integrityCheck = await checkDataIntegrity(userId)
    if (!integrityCheck.valid) {
      issues.push({
        type: 'DATA_CORRUPTION',
        severity: 'HIGH',
        message: 'ãƒ‡ãƒ¼ã‚¿ã«ä¸æ•´åˆãŒã‚ã‚Šã¾ã™',
        solution: 'å®Œå…¨å†åŒæœŸã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„'
      })
    }
    
    return issues
  },
  
  // è‡ªå‹•ä¿®å¾©æ©Ÿèƒ½
  attemptAutoRepair: async (userId, issues) => {
    const repairResults = []
    
    for (const issue of issues) {
      try {
        switch (issue.type) {
          case 'AUTHENTICATION':
            await refreshAuthentication(userId)
            repairResults.push({ issue: issue.type, status: 'REPAIRED' })
            break
            
          case 'SYNC_DELAY':
            await forceSyncNow(userId)
            repairResults.push({ issue: issue.type, status: 'REPAIRED' })
            break
            
          case 'DATA_CORRUPTION':
            await performFullResync(userId)
            repairResults.push({ issue: issue.type, status: 'REPAIRED' })
            break
            
          default:
            repairResults.push({ issue: issue.type, status: 'MANUAL_REQUIRED' })
        }
      } catch (error) {
        repairResults.push({ 
          issue: issue.type, 
          status: 'REPAIR_FAILED', 
          error: error.message 
        })
      }
    }
    
    return repairResults
  }
}
```

### 7.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

```javascript
// ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–
const CalendarPerformanceOptimizer = {
  // ã‚¯ã‚¨ãƒªæœ€é©åŒ–
  optimizeQueries: async () => {
    // é »ç¹ã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚¯ã‚¨ãƒªã®ç‰¹å®š
    const queryStats = await analyzeQueryPerformance()
    const slowQueries = queryStats.filter(q => q.avgTime > 1000) // 1ç§’ä»¥ä¸Š
    
    for (const query of slowQueries) {
      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æœ€é©åŒ–
      if (query.table === 'calendar_events') {
        await optimizeEventQueries(query)
      }
      
      // ã‚¯ã‚¨ãƒªã®æ›¸ãæ›ãˆ
      const optimizedQuery = await rewriteQuery(query)
      await updateQueryPlan(query.id, optimizedQuery)
    }
  },
  
  // ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥
  implementCaching: async () => {
    const cacheConfig = {
      // é™çš„ãƒ‡ãƒ¼ã‚¿ï¼ˆé•·æœŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰
      static: {
        ttl: 3600, // 1æ™‚é–“
        keys: ['user_preferences', 'calendar_settings', 'timezone_data']
      },
      
      // å‹•çš„ãƒ‡ãƒ¼ã‚¿ï¼ˆçŸ­æœŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰
      dynamic: {
        ttl: 300, // 5åˆ†
        keys: ['daily_events', 'week_view', 'month_summary']
      },
      
      // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ï¼ˆæ¥µçŸ­æœŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼‰
      realtime: {
        ttl: 60, // 1åˆ†
        keys: ['current_conflicts', 'availability_status']
      }
    }
    
    await setupRedisCache(cacheConfig)
  },
  
  // é…å»¶èª­ã¿è¾¼ã¿
  implementLazyLoading: () => {
    return {
      // è¦–ç•Œå¤–ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯é…å»¶èª­ã¿è¾¼ã¿
      events: (viewport, allEvents) => {
        const visibleEvents = allEvents.filter(event => 
          isEventInViewport(event, viewport)
        )
        
        const lazyLoadTriggers = setupIntersectionObserver()
        return { visibleEvents, lazyLoadTriggers }
      },
      
      // è©³ç´°æƒ…å ±ã®é…å»¶èª­ã¿è¾¼ã¿
      eventDetails: (eventId) => {
        return new Promise((resolve) => {
          setTimeout(async () => {
            const details = await fetchEventDetails(eventId)
            resolve(details)
          }, 100)
        })
      }
    }
  }
}
```

---

**æœ€çµ‚æ›´æ–°æ—¥**: 2025-06-29  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: Phase 4 å®Œäº†ç‰ˆ  
**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: ã‚·ã‚¹ãƒ†ãƒ æ©Ÿèƒ½ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã€ã‚¢ãƒã‚¤ãƒ³ãƒˆãƒ¡ãƒ³ãƒˆç®¡ç†ãƒãƒ‹ãƒ¥ã‚¢ãƒ«