# ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ãƒãƒ‹ãƒ¥ã‚¢ãƒ«

## æ¦‚è¦

FIND to DO Management Appã®ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€7æ®µéšã‚«ãƒ³ãƒãƒ³ãƒœãƒ¼ãƒ‰ã‚’ä¸­å¿ƒã¨ã—ãŸé«˜åº¦ãªã‚¿ã‚¹ã‚¯ç®¡ç†æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚MECEï¼ˆMutually Exclusive, Collectively Exhaustiveï¼‰åŸå‰‡ã«åŸºã¥ãé–¢ä¿‚æ€§ç®¡ç†ã¨ã€AIæ©Ÿèƒ½ã‚’æ´»ç”¨ã—ãŸã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãªã‚¿ã‚¹ã‚¯å‡¦ç†ãŒç‰¹å¾´ã§ã™ã€‚

## ç›®æ¬¡

1. [7æ®µéšã‚«ãƒ³ãƒãƒ³ãƒœãƒ¼ãƒ‰](#7æ®µéšã‚«ãƒ³ãƒãƒ³ãƒœãƒ¼ãƒ‰)
2. [MECEé–¢ä¿‚æ€§ç®¡ç†](#meceé–¢ä¿‚æ€§ç®¡ç†)
3. [å„ªå…ˆåº¦ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ](#å„ªå…ˆåº¦ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ )
4. [å”åŠ›è€…ãƒ»æ‹…å½“è€…ç®¡ç†](#å”åŠ›è€…æ‹…å½“è€…ç®¡ç†)
5. [AIæ©Ÿèƒ½é€£æº](#aiæ©Ÿèƒ½é€£æº)
6. [è©³ç´°æ“ä½œã‚¬ã‚¤ãƒ‰](#è©³ç´°æ“ä½œã‚¬ã‚¤ãƒ‰)
7. [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](#ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°)

---

## 7æ®µéšã‚«ãƒ³ãƒãƒ³ãƒœãƒ¼ãƒ‰

### 1.1 ãƒœãƒ¼ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸æ§‹æˆ

| ã‚¹ãƒ†ãƒ¼ã‚¸ | è‹±èªå | èª¬æ˜ | ä¸»ãªæ“ä½œ |
|---------|--------|------|---------|
| **ã‚¢ã‚¤ãƒ‡ã‚¢** | IDEA | ã‚¿ã‚¹ã‚¯ã®ç™ºæƒ³ãƒ»æ§‹æƒ³æ®µéš | ã‚¢ã‚¤ãƒ‡ã‚¢ç™»éŒ²ã€æ¦‚è¦ä½œæˆ |
| **è¨ˆç”»** | PLAN | å…·ä½“çš„ãªè¨ˆç”»ç«‹æ¡ˆæ®µéš | è©³ç´°åŒ–ã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š |
| **å®Ÿè¡Œ** | DO | ã‚¿ã‚¹ã‚¯ã®å®Ÿéš›ã®å®Ÿè¡Œæ®µéš | é€²æ—æ›´æ–°ã€ä½œæ¥­è¨˜éŒ² |
| **ç¢ºèª** | CHECK | å®Œäº†å†…å®¹ã®ç¢ºèªãƒ»æ¤œè¨¼æ®µéš | å“è³ªãƒã‚§ãƒƒã‚¯ã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ |
| **å®Œäº†** | COMPLETE | ã‚¿ã‚¹ã‚¯ã®æ­£å¼å®Œäº†æ®µéš | å®Œäº†ç¢ºå®šã€æˆæœç‰©ç¢ºèª |
| **ãƒŠãƒ¬ãƒƒã‚¸** | KNOWLEDGE | çŸ¥è­˜ã¨ã—ã¦è“„ç©ã™ã‚‹æ®µéš | ãƒŠãƒ¬ãƒƒã‚¸åŒ–ã€å…±æœ‰è¨­å®š |
| **å‰Šé™¤** | DELETE | å‰Šé™¤ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æ®µéš | å‰Šé™¤ç†ç”±è¨˜éŒ²ã€å±¥æ­´ä¿æŒ |

### 1.2 ã‚¹ãƒ†ãƒ¼ã‚¸é·ç§»ãƒ«ãƒ¼ãƒ«

```javascript
// ã‚¿ã‚¹ã‚¯ã‚¹ãƒ†ãƒ¼ã‚¸é·ç§»ã®åˆ¶å¾¡
const allowedTransitions = {
  'IDEA': ['PLAN', 'DELETE'],
  'PLAN': ['IDEA', 'DO', 'DELETE'],
  'DO': ['PLAN', 'CHECK', 'DELETE'],
  'CHECK': ['DO', 'COMPLETE', 'DELETE'],
  'COMPLETE': ['CHECK', 'KNOWLEDGE', 'DELETE'],
  'KNOWLEDGE': ['DELETE'],
  'DELETE': [] // å‰Šé™¤å¾Œã¯é·ç§»ä¸å¯
}

const canTransition = (currentStage, targetStage) => {
  return allowedTransitions[currentStage]?.includes(targetStage) || false
}
```

### 1.3 ã‚«ãƒ³ãƒãƒ³ãƒœãƒ¼ãƒ‰æ“ä½œ

#### ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
```javascript
// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã«ã‚ˆã‚‹ç§»å‹•
const handleDragEnd = (result) => {
  const { destination, source, draggableId } = result
  
  if (!destination) return
  
  const sourceStage = source.droppableId
  const destStage = destination.droppableId
  
  // é·ç§»ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯
  if (!canTransition(sourceStage, destStage)) {
    showError('ã“ã®ç§»å‹•ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“')
    return
  }
  
  // ã‚¿ã‚¹ã‚¯ç§»å‹•å®Ÿè¡Œ
  moveTask(draggableId, destStage, destination.index)
}
```

#### ä¸€æ‹¬æ“ä½œæ©Ÿèƒ½
```javascript
// è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®ä¸€æ‹¬æ“ä½œ
const bulkMoveTask = async (taskIds, targetStage) => {
  const validTasks = taskIds.filter(id => {
    const task = getTaskById(id)
    return canTransition(task.stage, targetStage)
  })
  
  if (validTasks.length === 0) {
    showError('ç§»å‹•å¯èƒ½ãªã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“')
    return
  }
  
  await Promise.all(
    validTasks.map(id => updateTaskStage(id, targetStage))
  )
  
  showSuccess(`${validTasks.length}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’ç§»å‹•ã—ã¾ã—ãŸ`)
}
```

---

## MECEé–¢ä¿‚æ€§ç®¡ç†

### 2.1 MECEåŸå‰‡ã®é©ç”¨

MECEåŸå‰‡ã«åŸºã¥ã„ã¦ã‚¿ã‚¹ã‚¯é–“ã®é–¢ä¿‚æ€§ã‚’ç®¡ç†ã—ã¾ã™ï¼š

- **Mutually Exclusiveï¼ˆç›¸äº’æ’ä»–çš„ï¼‰**: ã‚¿ã‚¹ã‚¯ã®é‡è¤‡ã‚’æ’é™¤
- **Collectively Exhaustiveï¼ˆå…¨ä½“ç¶²ç¾…çš„ï¼‰**: å¿…è¦ãªã‚¿ã‚¹ã‚¯ã‚’æ¼ã‚Œãªãç®¡ç†

### 2.2 ã‚¿ã‚¹ã‚¯é–¢ä¿‚æ€§ã®ç¨®é¡

```javascript
// ã‚¿ã‚¹ã‚¯é–¢ä¿‚æ€§ã®å®šç¾©
const TaskRelationTypes = {
  DEPENDS_ON: 'depends_on',       // ä¾å­˜é–¢ä¿‚ï¼ˆå‰ææ¡ä»¶ï¼‰
  BLOCKS: 'blocks',               // ãƒ–ãƒ­ãƒƒã‚¯é–¢ä¿‚ï¼ˆå®Ÿè¡Œé˜»å®³ï¼‰
  PARENT_CHILD: 'parent_child',   // è¦ªå­é–¢ä¿‚ï¼ˆéšå±¤æ§‹é€ ï¼‰
  SIMILAR: 'similar',             // é¡ä¼¼é–¢ä¿‚ï¼ˆé‡è¤‡æ¤œçŸ¥ï¼‰
  SEQUENCE: 'sequence',           // é †åºé–¢ä¿‚ï¼ˆå®Ÿè¡Œé †åºï¼‰
  RESOURCE: 'resource'            // ãƒªã‚½ãƒ¼ã‚¹é–¢ä¿‚ï¼ˆå…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ï¼‰
}
```

### 2.3 é–¢ä¿‚æ€§ç®¡ç†æ©Ÿèƒ½

#### ä¾å­˜é–¢ä¿‚ã®è¨­å®š
```javascript
// ã‚¿ã‚¹ã‚¯ä¾å­˜é–¢ä¿‚ã®è¨­å®š
const setTaskDependency = async (taskId, dependsOnTaskId) => {
  // å¾ªç’°ä¾å­˜ãƒã‚§ãƒƒã‚¯
  if (await hasCyclicDependency(taskId, dependsOnTaskId)) {
    throw new Error('å¾ªç’°ä¾å­˜ãŒç™ºç”Ÿã™ã‚‹ãŸã‚è¨­å®šã§ãã¾ã›ã‚“')
  }
  
  await createTaskRelation({
    sourceTaskId: taskId,
    targetTaskId: dependsOnTaskId,
    relationType: 'DEPENDS_ON',
    createdAt: new Date()
  })
  
  // ä¾å­˜ã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯
  await checkDependencyStatus(taskId)
}
```

#### é‡è¤‡æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
```javascript
// é¡ä¼¼ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•æ¤œçŸ¥
const detectSimilarTasks = async (newTask) => {
  const similarTasks = await findSimilarTasks({
    title: newTask.title,
    description: newTask.description,
    category: newTask.category,
    threshold: 0.8 // é¡ä¼¼åº¦80%ä»¥ä¸Š
  })
  
  if (similarTasks.length > 0) {
    return {
      hasSimilar: true,
      suggestions: similarTasks.map(task => ({
        id: task.id,
        title: task.title,
        similarity: task.similarity,
        action: 'merge_or_differentiate'
      }))
    }
  }
  
  return { hasSimilar: false }
}
```

### 2.4 éšå±¤æ§‹é€ ç®¡ç†

```javascript
// è¦ªå­é–¢ä¿‚ã®ã‚ã‚‹ã‚¿ã‚¹ã‚¯éšå±¤
const TaskHierarchy = {
  // è¦ªã‚¿ã‚¹ã‚¯ã®ä½œæˆ
  createParentTask: async (parentData) => {
    const parent = await createTask({
      ...parentData,
      isParent: true,
      childTasks: []
    })
    return parent
  },
  
  // å­ã‚¿ã‚¹ã‚¯ã®è¿½åŠ 
  addChildTask: async (parentId, childData) => {
    const child = await createTask({
      ...childData,
      parentId,
      isChild: true
    })
    
    await updateParentProgress(parentId)
    return child
  },
  
  // é€²æ—ã®è‡ªå‹•è¨ˆç®—
  calculateParentProgress: (childTasks) => {
    const completedChildren = childTasks.filter(
      child => child.stage === 'COMPLETE'
    ).length
    
    return Math.round((completedChildren / childTasks.length) * 100)
  }
}
```

---

## å„ªå…ˆåº¦ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### 3.1 å„ªå…ˆåº¦ãƒ¬ãƒ™ãƒ«

| ãƒ¬ãƒ™ãƒ« | è¨˜å· | åç§° | èª¬æ˜ | è‰²åˆ†ã‘ |
|--------|------|------|------|--------|
| **A** | ğŸ”´ | æœ€é«˜å„ªå…ˆ | ç·Šæ€¥ã‹ã¤é‡è¦ | èµ¤è‰² |
| **B** | ğŸŸ¡ | é«˜å„ªå…ˆ | é‡è¦ã ãŒç·Šæ€¥ã§ãªã„ | é»„è‰² |
| **C** | ğŸŸ¢ | ä¸­å„ªå…ˆ | ç·Šæ€¥ã ãŒé‡è¦ã§ãªã„ | ç·‘è‰² |
| **D** | ğŸ”µ | ä½å„ªå…ˆ | ç·Šæ€¥ã§ã‚‚é‡è¦ã§ã‚‚ãªã„ | é’è‰² |

### 3.2 ã‚¢ã‚¤ã‚¼ãƒ³ãƒãƒ¯ãƒ¼ãƒãƒˆãƒªãƒƒã‚¯ã‚¹é©ç”¨

```javascript
// å„ªå…ˆåº¦è‡ªå‹•åˆ¤å®šã‚·ã‚¹ãƒ†ãƒ 
const determinePriority = (task) => {
  const isUrgent = checkUrgency(task)
  const isImportant = checkImportance(task)
  
  if (isUrgent && isImportant) return 'A'
  if (!isUrgent && isImportant) return 'B'
  if (isUrgent && !isImportant) return 'C'
  return 'D'
}

const checkUrgency = (task) => {
  const now = new Date()
  const deadline = new Date(task.deadline)
  const daysDiff = Math.ceil((deadline - now) / (1000 * 60 * 60 * 24))
  
  return daysDiff <= 3 // 3æ—¥ä»¥å†…ã¯ç·Šæ€¥
}

const checkImportance = (task) => {
  const importanceFactors = [
    task.businessImpact >= 8,     // ãƒ“ã‚¸ãƒã‚¹ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆ8ä»¥ä¸Š
    task.assignedBy === 'MANAGER', // ç®¡ç†è€…ã‹ã‚‰ã®ä¾é ¼
    task.category === 'CRITICAL',  // é‡è¦ã‚«ãƒ†ã‚´ãƒª
    task.stakeholders.length > 3   // é–¢ä¿‚è€…3äººä»¥ä¸Š
  ]
  
  return importanceFactors.filter(Boolean).length >= 2
}
```

### 3.3 å„ªå…ˆåº¦ãƒ™ãƒ¼ã‚¹ã‚½ãƒ¼ãƒˆ

```javascript
// å„ªå…ˆåº¦ã¨ãã®ä»–è¦ç´ ã‚’çµ„ã¿åˆã‚ã›ãŸã‚½ãƒ¼ãƒˆ
const sortTasksByPriority = (tasks) => {
  return tasks.sort((a, b) => {
    // å„ªå…ˆåº¦ãƒ¬ãƒ™ãƒ«ï¼ˆA > B > C > Dï¼‰
    const priorityOrder = { 'A': 4, 'B': 3, 'C': 2, 'D': 1 }
    const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority]
    
    if (priorityDiff !== 0) return priorityDiff
    
    // ç· åˆ‡ã®è¿‘ã•
    const deadlineDiff = new Date(a.deadline) - new Date(b.deadline)
    if (deadlineDiff !== 0) return deadlineDiff
    
    // ä½œæˆæ—¥ï¼ˆæ–°ã—ã„ã‚‚ã®å„ªå…ˆï¼‰
    return new Date(b.createdAt) - new Date(a.createdAt)
  })
}
```

### 3.4 å‹•çš„å„ªå…ˆåº¦æ›´æ–°

```javascript
// æ™‚é–“çµŒéã«ã‚ˆã‚‹å„ªå…ˆåº¦ã®å‹•çš„æ›´æ–°
const updatePriorityBasedOnTime = async () => {
  const tasks = await getActiveTasks()
  
  for (const task of tasks) {
    const newPriority = determinePriority(task)
    
    if (newPriority !== task.priority) {
      await updateTask(task.id, { priority: newPriority })
      
      // å„ªå…ˆåº¦å¤‰æ›´é€šçŸ¥
      await sendPriorityChangeNotification(task, newPriority)
    }
  }
}

// å®šæœŸå®Ÿè¡Œï¼ˆ1æ—¥1å›ï¼‰
setInterval(updatePriorityBasedOnTime, 24 * 60 * 60 * 1000)
```

---

## å”åŠ›è€…ãƒ»æ‹…å½“è€…ç®¡ç†

### 4.1 ãƒ­ãƒ¼ãƒ«å®šç¾©

```javascript
// ã‚¿ã‚¹ã‚¯å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ­ãƒ¼ãƒ«
const TaskUserRoles = {
  OWNER: 'owner',           // ã‚ªãƒ¼ãƒŠãƒ¼ï¼ˆä½œæˆè€…ãƒ»è²¬ä»»è€…ï¼‰
  ASSIGNEE: 'assignee',     // æ‹…å½“è€…ï¼ˆå®Ÿè¡Œè€…ï¼‰
  REVIEWER: 'reviewer',     // ãƒ¬ãƒ“ãƒ¥ãƒ¯ãƒ¼ï¼ˆç¢ºèªè€…ï¼‰
  COLLABORATOR: 'collaborator', // å”åŠ›è€…ï¼ˆæ”¯æ´è€…ï¼‰
  OBSERVER: 'observer'      // ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ï¼ˆé–²è¦§è€…ï¼‰
}
```

### 4.2 æ‹…å½“è€…ã‚¢ã‚µã‚¤ãƒ³æ©Ÿèƒ½

```javascript
// æ‹…å½“è€…ã®è‡ªå‹•ã‚¢ã‚µã‚¤ãƒ³
const autoAssignTask = async (taskId, criteria) => {
  const availableUsers = await getAvailableUsers(criteria)
  
  // è² è·åˆ†æ•£ã‚’è€ƒæ…®ã—ãŸæ‹…å½“è€…é¸å®š
  const bestAssignee = selectBestAssignee(availableUsers, {
    skillMatch: criteria.requiredSkills,
    workload: true,
    availability: true,
    performance: true
  })
  
  await assignUserToTask(taskId, bestAssignee, 'ASSIGNEE')
  
  // æ‹…å½“è€…ã«é€šçŸ¥
  await sendAssignmentNotification(bestAssignee, taskId)
}

const selectBestAssignee = (users, criteria) => {
  return users
    .map(user => ({
      user,
      score: calculateAssignmentScore(user, criteria)
    }))
    .sort((a, b) => b.score - a.score)[0]?.user
}
```

### 4.3 ã‚³ãƒ©ãƒœãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½

```javascript
// ã‚¿ã‚¹ã‚¯ã‚³ãƒ¡ãƒ³ãƒˆãƒ»ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³
const TaskComments = {
  addComment: async (taskId, userId, content, type = 'COMMENT') => {
    const comment = await createComment({
      taskId,
      userId,
      content,
      type, // COMMENT, QUESTION, SUGGESTION, UPDATE
      timestamp: new Date(),
      mentions: extractMentions(content)
    })
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³é€šçŸ¥
    if (comment.mentions.length > 0) {
      await sendMentionNotifications(comment.mentions, taskId, comment.id)
    }
    
    return comment
  },
  
  // é€²æ—æ›´æ–°ã‚³ãƒ¡ãƒ³ãƒˆ
  addProgressUpdate: async (taskId, userId, progress, notes) => {
    return await TaskComments.addComment(taskId, userId, 
      `é€²æ—æ›´æ–°: ${progress}%\n${notes}`, 'UPDATE')
  }
}
```

### 4.4 ãƒãƒ¼ãƒ è² è·ç®¡ç†

```javascript
// ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã®ä½œæ¥­è² è·ç›£è¦–
const WorkloadManager = {
  // å€‹äººã®ä½œæ¥­è² è·è¨ˆç®—
  calculateWorkload: (userId) => {
    const activeTasks = getUserActiveTasks(userId)
    
    return activeTasks.reduce((total, task) => {
      const priorityWeight = { 'A': 4, 'B': 3, 'C': 2, 'D': 1 }
      const stageWeight = { 'DO': 1.5, 'CHECK': 1.2, 'PLAN': 1.0 }
      
      return total + (priorityWeight[task.priority] * stageWeight[task.stage])
    }, 0)
  },
  
  // ãƒãƒ¼ãƒ å…¨ä½“ã®è² è·ãƒãƒ©ãƒ³ã‚¹
  getTeamLoadBalance: (teamMembers) => {
    const workloads = teamMembers.map(member => ({
      userId: member.id,
      name: member.name,
      workload: WorkloadManager.calculateWorkload(member.id),
      capacity: member.capacity || 10
    }))
    
    const averageLoad = workloads.reduce((sum, w) => sum + w.workload, 0) / workloads.length
    
    return {
      workloads,
      averageLoad,
      isBalanced: workloads.every(w => Math.abs(w.workload - averageLoad) < 2)
    }
  }
}
```

---

## AIæ©Ÿèƒ½é€£æº

### 5.1 AIè‡ªå‹•åˆ†é¡

```javascript
// AIã«ã‚ˆã‚‹ã‚¿ã‚¹ã‚¯è‡ªå‹•åˆ†é¡
const AITaskClassifier = {
  classifyTask: async (taskData) => {
    const classification = await callAI({
      prompt: `
        ä»¥ä¸‹ã®ã‚¿ã‚¹ã‚¯ã‚’åˆ†æã—ã¦åˆ†é¡ã—ã¦ãã ã•ã„ï¼š
        ã‚¿ã‚¤ãƒˆãƒ«: ${taskData.title}
        èª¬æ˜: ${taskData.description}
        
        ä»¥ä¸‹ã®è¦ç´ ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ï¼š
        1. ã‚«ãƒ†ã‚´ãƒªï¼ˆé–‹ç™º/ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°/å–¶æ¥­/ç®¡ç†/ãã®ä»–ï¼‰
        2. å„ªå…ˆåº¦ï¼ˆA/B/C/Dï¼‰
        3. äºˆæƒ³å·¥æ•°ï¼ˆæ™‚é–“ï¼‰
        4. å¿…è¦ã‚¹ã‚­ãƒ«
        5. ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«ï¼ˆé«˜/ä¸­/ä½ï¼‰
      `,
      model: 'text-classification'
    })
    
    return {
      category: classification.category,
      suggestedPriority: classification.priority,
      estimatedHours: classification.hours,
      requiredSkills: classification.skills,
      riskLevel: classification.risk
    }
  }
}
```

### 5.2 AIé€²æ—äºˆæ¸¬

```javascript
// AI ã«ã‚ˆã‚‹å®Œäº†äºˆæ¸¬
const AIProgressPredictor = {
  predictCompletion: async (taskId) => {
    const task = await getTask(taskId)
    const historicalData = await getHistoricalTaskData(task.category)
    
    const prediction = await callAI({
      prompt: `
        ã‚¿ã‚¹ã‚¯ã®å®Œäº†äºˆæ¸¬ã‚’è¡Œã£ã¦ãã ã•ã„ï¼š
        ç¾åœ¨ã®é€²æ—: ${task.progress}%
        ã‚«ãƒ†ã‚´ãƒª: ${task.category}
        å„ªå…ˆåº¦: ${task.priority}
        æ‹…å½“è€…: ${task.assignee}
        éå»ãƒ‡ãƒ¼ã‚¿: ${JSON.stringify(historicalData)}
      `,
      model: 'time-series-prediction'
    })
    
    return {
      estimatedCompletionDate: prediction.completionDate,
      confidence: prediction.confidence,
      bottlenecks: prediction.identifiedBottlenecks,
      recommendations: prediction.recommendations
    }
  }
}
```

### 5.3 AIä½œæ¥­ææ¡ˆ

```javascript
// AIã«ã‚ˆã‚‹æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ææ¡ˆ
const AIActionSuggester = {
  suggestNextActions: async (userId) => {
    const userTasks = await getUserTasks(userId)
    const userProfile = await getUserProfile(userId)
    const teamContext = await getTeamContext(userId)
    
    const suggestions = await callAI({
      prompt: `
        ä»¥ä¸‹ã®æƒ…å ±ã‹ã‚‰ã€æœ€é©ãªæ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ææ¡ˆã—ã¦ãã ã•ã„ï¼š
        
        ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¿ã‚¹ã‚¯: ${JSON.stringify(userTasks)}
        ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«: ${JSON.stringify(userProfile)}
        ãƒãƒ¼ãƒ çŠ¶æ³: ${JSON.stringify(teamContext)}
        
        ææ¡ˆå†…å®¹ï¼š
        1. å„ªå…ˆã—ã¦å–ã‚Šçµ„ã‚€ã¹ãã‚¿ã‚¹ã‚¯
        2. åŠ¹ç‡åŒ–ã®ãŸã‚ã®å·¥å¤«
        3. ä»–ãƒ¡ãƒ³ãƒãƒ¼ã¨ã®é€£æºææ¡ˆ
      `,
      model: 'action-recommendation'
    })
    
    return suggestions
  }
}
```

---

## è©³ç´°æ“ä½œã‚¬ã‚¤ãƒ‰

### 6.1 ã‚¿ã‚¹ã‚¯ä½œæˆ

#### åŸºæœ¬çš„ãªã‚¿ã‚¹ã‚¯ä½œæˆ
```javascript
// æ–°è¦ã‚¿ã‚¹ã‚¯ä½œæˆ
const createNewTask = async (taskData) => {
  // AIåˆ†é¡ã®å®Ÿè¡Œ
  const aiSuggestions = await AITaskClassifier.classifyTask(taskData)
  
  const newTask = {
    id: generateTaskId(),
    title: taskData.title,
    description: taskData.description,
    stage: 'IDEA',
    priority: aiSuggestions.suggestedPriority,
    category: aiSuggestions.category,
    estimatedHours: aiSuggestions.estimatedHours,
    createdBy: taskData.userId,
    createdAt: new Date(),
    updatedAt: new Date(),
    tags: extractTags(taskData.description),
    status: 'ACTIVE'
  }
  
  const createdTask = await saveTask(newTask)
  
  // é‡è¤‡ãƒã‚§ãƒƒã‚¯ã®å®Ÿè¡Œ
  const duplicateCheck = await detectSimilarTasks(newTask)
  if (duplicateCheck.hasSimilar) {
    await flagForDuplicateReview(createdTask.id, duplicateCheck.suggestions)
  }
  
  return createdTask
}
```

#### ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ã®ä½œæˆ
```javascript
// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ™ãƒ¼ã‚¹ã®ã‚¿ã‚¹ã‚¯ä½œæˆ
const createTaskFromTemplate = async (templateId, customData) => {
  const template = await getTaskTemplate(templateId)
  
  const taskData = {
    ...template.defaultValues,
    ...customData,
    title: customData.title || template.defaultValues.title,
    description: customData.description || template.defaultValues.description
  }
  
  // ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã®è‡ªå‹•ç”Ÿæˆ
  const parentTask = await createNewTask(taskData)
  
  if (template.subtasks) {
    for (const subtaskTemplate of template.subtasks) {
      await createNewTask({
        ...subtaskTemplate,
        parentId: parentTask.id,
        createdBy: customData.userId
      })
    }
  }
  
  return parentTask
}
```

### 6.2 ã‚¿ã‚¹ã‚¯æ›´æ–°æ“ä½œ

#### é€²æ—æ›´æ–°
```javascript
// é€²æ—æ›´æ–°æ©Ÿèƒ½
const updateTaskProgress = async (taskId, progress, notes) => {
  const task = await getTask(taskId)
  
  await updateTask(taskId, {
    progress,
    updatedAt: new Date(),
    lastProgressUpdate: new Date()
  })
  
  // é€²æ—ã‚³ãƒ¡ãƒ³ãƒˆè¿½åŠ 
  await TaskComments.addProgressUpdate(taskId, task.assignee, progress, notes)
  
  // å®Œäº†äºˆæ¸¬ã®æ›´æ–°
  const prediction = await AIProgressPredictor.predictCompletion(taskId)
  await updateTask(taskId, {
    estimatedCompletionDate: prediction.estimatedCompletionDate
  })
  
  // é–¢ä¿‚è€…ã¸ã®é€šçŸ¥
  await notifyTaskStakeholders(taskId, 'PROGRESS_UPDATE', {
    progress,
    notes,
    prediction
  })
}
```

#### ä¸€æ‹¬ç·¨é›†æ©Ÿèƒ½
```javascript
// è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®ä¸€æ‹¬ç·¨é›†
const bulkEditTasks = async (taskIds, updates) => {
  const validUpdates = validateBulkUpdates(updates)
  
  const results = await Promise.all(
    taskIds.map(async (taskId) => {
      try {
        await updateTask(taskId, {
          ...validUpdates,
          updatedAt: new Date()
        })
        return { taskId, success: true }
      } catch (error) {
        return { taskId, success: false, error: error.message }
      }
    })
  )
  
  const successful = results.filter(r => r.success)
  const failed = results.filter(r => !r.success)
  
  return {
    successful: successful.length,
    failed: failed.length,
    details: results
  }
}
```

### 6.3 ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ»æ¤œç´¢

#### é«˜åº¦ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
```javascript
// å¤šæ¡ä»¶ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
const filterTasks = (tasks, filters) => {
  return tasks.filter(task => {
    // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ•ã‚£ãƒ«ã‚¿
    if (filters.stages && !filters.stages.includes(task.stage)) {
      return false
    }
    
    // å„ªå…ˆåº¦ãƒ•ã‚£ãƒ«ã‚¿
    if (filters.priorities && !filters.priorities.includes(task.priority)) {
      return false
    }
    
    // æ‹…å½“è€…ãƒ•ã‚£ãƒ«ã‚¿
    if (filters.assignees && filters.assignees.length > 0) {
      const taskAssignees = task.assignees.map(a => a.userId)
      if (!filters.assignees.some(id => taskAssignees.includes(id))) {
        return false
      }
    }
    
    // æœŸé™ãƒ•ã‚£ãƒ«ã‚¿
    if (filters.dueDateRange) {
      const taskDate = new Date(task.deadline)
      const startDate = new Date(filters.dueDateRange.start)
      const endDate = new Date(filters.dueDateRange.end)
      
      if (taskDate < startDate || taskDate > endDate) {
        return false
      }
    }
    
    // ã‚¿ã‚°ãƒ•ã‚£ãƒ«ã‚¿
    if (filters.tags && filters.tags.length > 0) {
      if (!filters.tags.some(tag => task.tags.includes(tag))) {
        return false
      }
    }
    
    // ãƒ†ã‚­ã‚¹ãƒˆæ¤œç´¢
    if (filters.searchText) {
      const searchLower = filters.searchText.toLowerCase()
      const searchableText = `${task.title} ${task.description}`.toLowerCase()
      if (!searchableText.includes(searchLower)) {
        return false
      }
    }
    
    return true
  })
}
```

#### ä¿å­˜æ¸ˆã¿æ¤œç´¢ãƒ»ãƒ•ã‚£ãƒ«ã‚¿
```javascript
// æ¤œç´¢æ¡ä»¶ã®ä¿å­˜ã¨èª­ã¿è¾¼ã¿
const SavedFilters = {
  save: async (userId, filterName, filterCriteria) => {
    const savedFilter = {
      id: generateFilterId(),
      userId,
      name: filterName,
      criteria: filterCriteria,
      createdAt: new Date(),
      lastUsed: new Date()
    }
    
    await saveSavedFilter(savedFilter)
    return savedFilter
  },
  
  load: async (userId, filterId) => {
    const filter = await getSavedFilter(filterId)
    
    if (filter.userId !== userId) {
      throw new Error('Access denied')
    }
    
    // æœ€çµ‚ä½¿ç”¨æ—¥æ™‚ã‚’æ›´æ–°
    await updateSavedFilter(filterId, { lastUsed: new Date() })
    
    return filter.criteria
  },
  
  getRecentFilters: async (userId, limit = 5) => {
    return await getSavedFilters(userId, {
      orderBy: 'lastUsed',
      direction: 'DESC',
      limit
    })
  }
}
```

---

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### 7.1 ã‚ˆãã‚ã‚‹å•é¡Œ

#### ã‚¿ã‚¹ã‚¯ãŒç§»å‹•ã§ããªã„
**ç—‡çŠ¶**: ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã§ç§»å‹•ã§ããªã„
**åŸå› ã¨å¯¾å‡¦æ³•**:
1. **æ¨©é™ä¸è¶³**: ã‚¿ã‚¹ã‚¯ã®ç·¨é›†æ¨©é™ã‚’ç¢ºèª
2. **ã‚¹ãƒ†ãƒ¼ã‚¸é·ç§»ãƒ«ãƒ¼ãƒ«é•å**: è¨±å¯ã•ã‚ŒãŸé·ç§»ãƒ‘ã‚¹ã‚’ç¢ºèª
3. **ä¾å­˜é–¢ä¿‚ãƒ–ãƒ­ãƒƒã‚¯**: å‰æã‚¿ã‚¹ã‚¯ã®å®Œäº†çŠ¶æ³ã‚’ç¢ºèª

#### å„ªå…ˆåº¦ãŒè‡ªå‹•å¤‰æ›´ã•ã‚Œã‚‹
**ç—‡çŠ¶**: è¨­å®šã—ãŸå„ªå…ˆåº¦ãŒå‹æ‰‹ã«å¤‰ã‚ã‚‹
**åŸå› ã¨å¯¾å‡¦æ³•**:
1. **è‡ªå‹•å„ªå…ˆåº¦æ›´æ–°ãŒæœ‰åŠ¹**: è¨­å®šã§ç„¡åŠ¹åŒ–å¯èƒ½
2. **ç· åˆ‡æ—¥ã®æ¥è¿‘**: ç·Šæ€¥åº¦ã«ã‚ˆã‚‹è‡ªå‹•æ˜‡æ ¼
3. **AIææ¡ˆã®è‡ªå‹•é©ç”¨**: AIææ¡ˆè¨­å®šã‚’ç¢ºèª

### 7.2 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å•é¡Œ

#### å¤§é‡ã‚¿ã‚¹ã‚¯ã®è¡¨ç¤ºãŒé…ã„
```javascript
// ä»®æƒ³åŒ–ã«ã‚ˆã‚‹å¤§é‡ãƒ‡ãƒ¼ã‚¿å¯¾å¿œ
const VirtualizedTaskList = {
  // è¡¨ç¤ºé ˜åŸŸã®ã‚¿ã‚¹ã‚¯ã®ã¿ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  renderVisibleTasks: (tasks, viewport) => {
    const itemHeight = 80
    const startIndex = Math.floor(viewport.scrollTop / itemHeight)
    const endIndex = Math.min(
      startIndex + Math.ceil(viewport.height / itemHeight),
      tasks.length
    )
    
    return tasks.slice(startIndex, endIndex)
  },
  
  // æ®µéšçš„èª­ã¿è¾¼ã¿
  loadTasksInBatches: async (filters, batchSize = 50) => {
    let offset = 0
    let allTasks = []
    
    while (true) {
      const batch = await getTasks(filters, offset, batchSize)
      if (batch.length === 0) break
      
      allTasks = [...allTasks, ...batch]
      offset += batchSize
      
      // UIã®æ›´æ–°
      updateTaskList(allTasks)
    }
    
    return allTasks
  }
}
```

### 7.3 ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§å•é¡Œ

#### ä¾å­˜é–¢ä¿‚ã®å¾ªç’°å‚ç…§
```javascript
// å¾ªç’°ä¾å­˜ã®æ¤œå‡ºã¨ä¿®å¾©
const CircularDependencyResolver = {
  detect: async (taskId) => {
    const visited = new Set()
    const stack = new Set()
    
    const hasCycle = async (currentTaskId) => {
      if (stack.has(currentTaskId)) return true
      if (visited.has(currentTaskId)) return false
      
      visited.add(currentTaskId)
      stack.add(currentTaskId)
      
      const dependencies = await getTaskDependencies(currentTaskId)
      
      for (const dep of dependencies) {
        if (await hasCycle(dep.dependsOnTaskId)) {
          return true
        }
      }
      
      stack.delete(currentTaskId)
      return false
    }
    
    return await hasCycle(taskId)
  },
  
  resolve: async (cyclicPath) => {
    // æœ€ã‚‚å½±éŸ¿ã®å°‘ãªã„ä¾å­˜é–¢ä¿‚ã‚’å‰Šé™¤
    const leastCriticalDep = findLeastCriticalDependency(cyclicPath)
    await removeTaskDependency(leastCriticalDep.source, leastCriticalDep.target)
    
    // ä»£æ›¿æ‰‹æ®µã®ææ¡ˆ
    return {
      removedDependency: leastCriticalDep,
      alternatives: await suggestAlternativeDependencies(leastCriticalDep)
    }
  }
}
```

---

## çµ±è¨ˆãƒ»åˆ†ææ©Ÿèƒ½

### 8.1 ã‚¿ã‚¹ã‚¯åˆ†æãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰

```javascript
// ã‚¿ã‚¹ã‚¯å®Œäº†ç‡ã®åˆ†æ
const TaskAnalytics = {
  getCompletionStats: async (userId, period) => {
    const tasks = await getUserTasks(userId, period)
    
    return {
      total: tasks.length,
      completed: tasks.filter(t => t.stage === 'COMPLETE').length,
      inProgress: tasks.filter(t => ['DO', 'CHECK'].includes(t.stage)).length,
      planning: tasks.filter(t => ['IDEA', 'PLAN'].includes(t.stage)).length,
      overdue: tasks.filter(t => isOverdue(t)).length,
      
      // å®Œäº†ç‡
      completionRate: tasks.length > 0 ? 
        (tasks.filter(t => t.stage === 'COMPLETE').length / tasks.length) * 100 : 0,
      
      // å¹³å‡å®Œäº†æ™‚é–“
      averageCompletionTime: calculateAverageCompletionTime(tasks),
      
      // å„ªå…ˆåº¦åˆ¥åˆ†å¸ƒ
      priorityDistribution: calculatePriorityDistribution(tasks)
    }
  },
  
  // ç”Ÿç”£æ€§ãƒˆãƒ¬ãƒ³ãƒ‰åˆ†æ
  getProductivityTrend: async (userId, days = 30) => {
    const endDate = new Date()
    const startDate = new Date(endDate.getTime() - (days * 24 * 60 * 60 * 1000))
    
    const dailyStats = []
    
    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dayTasks = await getTasksCompletedOnDate(userId, d)
      dailyStats.push({
        date: new Date(d),
        tasksCompleted: dayTasks.length,
        totalHours: dayTasks.reduce((sum, t) => sum + (t.actualHours || 0), 0),
        efficiency: calculateEfficiency(dayTasks)
      })
    }
    
    return dailyStats
  }
}
```

---

**æœ€çµ‚æ›´æ–°æ—¥**: 2025-06-29  
**å¯¾è±¡ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: Phase 4 å®Œäº†ç‰ˆ  
**é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**: ã‚·ã‚¹ãƒ†ãƒ æ©Ÿèƒ½ã‚«ãƒ†ã‚´ãƒªä¸€è¦§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå®Œå…¨ãƒªã‚¹ãƒˆ